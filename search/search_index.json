{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to WSIMOD","text":"<p>This is the documentation for the WSIMOD project. WSIMOD stands for the Water Systems Integrated Modelling framework.</p> <p>The terrestrial water cycle is a highly interconnected system where the movement of water is affected by physical and human processes. Thus, environmental models may become inaccurate if they do not provide a complete picture of the water cycle, missing out on unexpected opportunities and omitting impacts that arise from complex interactions. WSIMOD is a modelling framework to integrate these different processes. It provides a message passing interface to enable different subsystem models to communicate water flux and water quality information between each other, and self-contained representations of the key parts of the water cycle (rivers, reservoirs, urban and rural hydrological catchments, treatment plants, and pipe networks). We created WSIMOD to enable a user greater flexibility in setting up their water cycle models, motivated by the abundance of non-textbook water systems that we have experienced in industry collaboration. The WSIMOD Python package provides tutorials and examples to help modellers create nodes, connect them with arcs, and create simulations.</p>"},{"location":"#table-of-contents","title":"Table Of Contents","text":"<p>The documentation follows the best practice for project documentation as described by Daniele Procida in the Di\u00e1taxis documentation framework and consists of:</p> <ol> <li> <p>About</p> </li> <li> <p>Installation</p> </li> <li> <p>Tutorials</p> <p>3.1. Quickstart</p> <p>3.2. WSIMOD model demonstration - Oxford</p> <p>3.3. Land nodes - hydrology and agriculture</p> <p>3.4. Model object - WSIMOD models</p> </li> <li> <p>How-To Guides</p> <p>4.1. Customise an arc</p> <p>4.2. Customise interactions</p> </li> <li> <p>Component library</p> </li> <li> <p>Command line interface</p> </li> <li> <p>Run WSIMOD in DAFNI</p> </li> <li> <p>API reference</p> <p>8.1. API reference - arc</p> <p>8.2. API reference - core</p> <p>8.3. API reference - land</p> <p>8.4. API reference - nodes</p> <p>8.5. API reference - sewer</p> <p>8.6. API reference - storage (reservoir, river, groundwater)</p> <p>8.7. API reference - wtw</p> <p>8.8. API reference - other components</p> <p>8.9. API reference - model</p> </li> <li> <p>Coverage</p> </li> </ol>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>WSIMOD was developed by Barnaby Dobson and Liu Leyang. Theoretical support was provided by Ana Mijic. Testing the WSIMOD over a variety of applications has been performed by Fangjun Peng, Vladimir Krivstov and Samer Muhandes.</p> <p>The design of WSIMOD was significantly influenced by CityDrain3, OpenMI, Belete, Voinov and Laniak, (2017), and smif.</p> <p>We acknowledge funding from the CAMELLIA project (Community Water Management for a Liveable London), funded by the Natural Environment Research Council (NERC) under grant NE/S003495/1.</p>"},{"location":"CODE_OF_CONDUCT/","title":"Contributor Covenant Code of Conduct","text":""},{"location":"CODE_OF_CONDUCT/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"CODE_OF_CONDUCT/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"CODE_OF_CONDUCT/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"CODE_OF_CONDUCT/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at [INSERT CONTACT METHOD]. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"CODE_OF_CONDUCT/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"CODE_OF_CONDUCT/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"CODE_OF_CONDUCT/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"CODE_OF_CONDUCT/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"CODE_OF_CONDUCT/#attribution","title":"Attribution","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p> <p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to <code>WSIMOD</code>","text":"<p>Thank you for considering contributing to <code>WSIMOD</code>.</p>"},{"location":"CONTRIBUTING/#bugs","title":"Bugs","text":"<p>Please create a new issues if you may have found a bug. Please describe the bug and instructions on recreating it (including OS and Python version). It may be helpful to use examples from the tutorials or how-to's to ensure that data is available.</p>"},{"location":"CONTRIBUTING/#confusion","title":"Confusion","text":"<p>If you are confused about how a model component works, or why it is producing results that look the way they do, please first check the documentation and existing issues. If this does not answer your question, or your question has not yet been raised, then please create a new issue where we can discuss it.</p>"},{"location":"CONTRIBUTING/#creating-new-functionality","title":"Creating new functionality","text":"<p>Is there something in the water cycle that you would like to represent that is not included in <code>WSIMOD</code>? Whatever it is, you are probably not alone! If there is not one already, please create an issue where we can discuss it. Do this before you start developing as others may be working on the same thing!</p> <p>Although the development of new functionality will depend highly on the case, there are a few generalisable points to bear in mind:</p> <ul> <li><code>WSIMOD</code> is highly object-oriented, thus, we will always try to implement a new component as a subclass of the closest component. We will collaboratively discuss this in the issue.</li> <li>Our documentation relies heavily on use of docstrings, make sure to format it following the Google Python style, see the source code of <code>Land.__init__</code> for an example. An admin will compile the documentation, but you can create your own pages to be added by following the directions below.</li> <li>We are incredibly grateful for contributions that include new tutorials or how-to's, whether for new or existing functionality. Our use of the mkdocs-jupyter extension enables notebooks to form pages in the documentation, but that can also serve as downloadable examples that people can run.</li> <li>Design new tests that instantiate your new functionality and test that it produces a specified response. New tests are stored in the <code>wsi/tests/</code> folder.</li> </ul>"},{"location":"CONTRIBUTING/#installation-for-development","title":"Installation for development","text":"<p>To install WSIMOD in development mode, first you will need a virtual environment. Here we use a <code>conda</code> environment which let us use the version of python we want to use, but you can use any other tool you are familiar with. Just make sure you use a version of Python compatible with WSIMOD.</p> <pre><code>conda create --name wsimod python=3.10\nconda activate wsimod\n</code></pre> <p>Once in the environment, you need to clone the WSIMOD GitHub repository locally and move into the right folder. You will need <code>git</code> for that, installed either following the official instructions or with <code>conda install git</code>, if you use <code>conda</code>.</p> <pre><code>git clone https://github.com/ImperialCollegeLondon/wsi.git\ncd wsi\n</code></pre> <p>We use <code>pip-tools</code> to ensure consistency in the development process, ensuring all people contributing to WSIMOD uses the same versions for all the dependencies, which minimiese the conflicts. To install the development dependencies and then WISMO in development mode run:</p> <pre><code>pip install .[dev]\npip install -e .\n</code></pre> <p>You can also install the dependencies required to run the demos and tutorials with:</p> <pre><code>pip install .[demos]\n</code></pre>"},{"location":"CONTRIBUTING/#quality-assurance-and-linting","title":"Quality assurance and linting","text":"<p>WSIMOD uses a collection of tools that ensure that a specific code style and formatting is follow thoughout the software. The tools we used for that are <code>ruff</code> and <code>markdownlint</code>. You do not need to run them manually - unless you want to - but rather they are run automatically every time you make a commit thanks to <code>pre-commit</code>.</p> <p><code>pre-commit</code> should already have been installed when installing the <code>dev</code> dependencies, if you followed the instructions above, but you need to activate the hooks that <code>git</code> will run when making a commit. To do that just run:</p> <pre><code>pre-commit install\n</code></pre> <p>You can customise the checks that <code>ruff</code> will make with the settings in <code>pyproject.toml</code>. For <code>markdownlint</code>, you need to oedit the arguments included in the .<code>pre-commit-config.yaml</code> file.</p>"},{"location":"CONTRIBUTING/#testing-and-coverage","title":"Testing and coverage","text":"<p>WSIMOD uses <code>pytests</code> as testing suite. You can run tests by navigating to the folder and running:</p> <pre><code>pytest # run all tests\npytest tests/test_file.py # run a specific file's tests\n</code></pre> <p>You can check the coverage for these tests by running:</p> <pre><code>coverage run -m pytest\ncoverage report\n</code></pre> <p>And generate a new coverage html for the documentation with</p> <pre><code>coverage html\n</code></pre>"},{"location":"CONTRIBUTING/#create-documentation","title":"Create documentation","text":"<p>If you want to compile new documentation you will need some additional packages, installed with:</p> <pre><code>pip install .[doc]\n</code></pre> <p>From here, you can make changes to the documentation pages in <code>docs</code> and view how they appear by navigating to and hosting them locally:</p> <pre><code>mkdocs serve\n</code></pre> <p>If compiling and deploying documentation, you will need to have <code>git</code> installed (see above). Then:</p> <pre><code>mkdocs gh-deploy\n</code></pre>"},{"location":"CONTRIBUTING/#changing-dependencies","title":"Changing dependencies","text":"<p>Is as the development process moves forward you find you need to add a new dependency, just add it to the relevant section of the <code>pyproject.toml</code> file.</p>"},{"location":"component-library/","title":"Component library","text":""},{"location":"component-library/#introduction","title":"Introduction","text":"<p>WSIMOD contains a variety of components to represent physical processes. We recommend viewing the API for a detailed description of the models included, however, we provide an overview of documented components, their assumptions and required input data on this page.</p>"},{"location":"component-library/#component-library","title":"Component Library","text":"Component Assumptions Data <code>Catchment</code> - Flows from <code>Catchment</code> nodes are simply read from data, thus assumed to be unresponsive to wider water cycle changes. - Flow data in the <code>data_input_dict</code> at the model timestep. Units: cubic metres/timestep - Values for each variable defined in <code>constants.POLLUTANTS</code> also stored in <code>data_input_dict</code> at the model timestep. Units: kg/m3/timestep (additive pollutants) <code>Distribution</code> - No distribution processes yet represented, this class is just for conveyance. - None <code>FWTW</code> - See <code>wtw.py/WTW</code> for treatment. - Stores treated water in a service reservoir tank, with a single tank per <code>FWTW</code> node. - Aims to satisfy a throughput that would top up the service reservoirs until full. - Currently, will not allow a deficit, thus introducing water from 'other measures' if pulls cannot fulfil demand. Behaviour under a deficit should be determined and validated before introducing. - See <code>wtw.py/WTW</code> for treatment. - Service reservoir tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres <code>Groundwater</code> - Conceptualises groundwater as a tank. - Baseflow is generated following a residence-time method. - Baseflow is sent to <code>storage.py/River</code>, <code>nodes.py/Node</code> or <code>waste.py/Waste</code> nodes. - Infiltration to <code>sewer.py/Sewer</code> nodes occurs when the storage in the tank is greater than a specified threshold, at a rate proportional to the sqrt of volume above the threshold. (Note, this behaviour is not validated and a high uncertainty process in general) - If <code>decays</code> are provided to model water quality transformations, see <code>core.py/DecayObj</code>. - Groundwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres - Infiltration behaviour determined by an <code>infiltration_threshold</code> and <code>infiltration_pct</code>. Units: proportion of capacity - Optional dictionary of decays with pollutants as keys and decay parameters (a constant and a temperature sensitivity exponent) as values. Units: - <code>GrowingSurface</code> - In the soil water module, crop stages and crop coefficients control the evapotranspiration. - Fertiliser and manure application are the major source of soil nutrients, which are added into soil nutrient pools, including dissovled inorganic, dissolved organic, fast and humus for both nitrogen and phosphorus. - Nutrient transformation processes in soil are simulated, including fluxes between the soil nutrient pools, denitrification for nitrogen, adsorption/desorption for phosphorus. These processes are affected by temperature and soil moisture. - Crop uptake of nutrients are simulated based on crop stages, which is different for spring-sown and autumn-sown crops. - Soil erosion from the growing surface is simulated as one of the major sources of suspended solids in rivers, which is mainly affected by rainfall energy and crop/ground cover. Phosphorus will also be eroded along with the soil particles, in both adsorbed inorganic and humus form. - <code>data_input_dict</code> can contain a variety of pollutant deposition data. <code>srp-fertiliser</code> describes phosphate. <code>noy-fertiliser</code> describes nitrogen as nitrates. <code>nhx-fertiliser</code> describes nitrogen as ammonia. <code>srp/noy/ nhx-manure</code> can also be used to specify manure application. Units: kg/m2/timestep (data is read at a monthly timestep) - Rooting depth. Units: m - Evapotranspiration depletion factor. Units: - Sowing day, harvest day and crop calendars. Units: day number in Julian calendar - Crop factor. Units: - Initial storage for solid pollutants. Units: kg <code>Land</code> - Percolation, surface runoff, and subsurface runoff, can be described with a residence-time method. - Flows to percolation, surface runoff, and subsurface runoff are generated by different hydrological response units (subclasses of <code>land.py/Surface</code>), but aggregated for a given land node. - Flows to percolation are distributed to <code>storage.py/Groundwater</code> nodes while surface/subsurface runoff to <code>nodes.py/Node</code> or <code>storage.py/River</code> nodes. - Input data associated with the land node (precipitation, temperature, evapotranspiartion) are the same for every surface. - Water received from <code>sewer.py/Sewer</code> objects is sent to the first <code>land.py/ImperviousSurface</code> in the surfaces list. - Precipitation and evapotranspiration are in the <code>data_input_dict</code> at the model timestep. Units: metres/timestep - Temperature in the <code>data_input_dict</code> at the model timestep. Units: C - Residence time of surface, subsurface and percolation flows. Units: number of timesteps <code>Node</code> - No physical processes represented, can be used as a junction. - All nodes require a <code>name</code> <code>NutrientPool</code> - Four nutrient pools are conceptualised for both nitrogen and phosphorus in soil, which includes humus pool, fast pool, dissolved inorganic pool, and dissolved organic pool. Humus and fast pool represent immobile pool of organic nutrients in the soil with slow and fast turnover, respectively. Dissolved inorganic and organic pool represent nutrients in dissolved phase in soil water (for phosphorus, dissolved organic pool might contain particulate phase). Given that phoshphorus can be adsorbed and attached to soil particles, an adsorbed inorganic pool is created specifically for phosphorus. - The major sources of nutrients to soil are conceptualised as - atmospheric deposition: - dry deposition: - for nitrogen, inorganic fraction of dry deposition is added to the dissovled inorganic pool, while the rest is added to the fast pool; - for phosphorus, all is added to adsorbed inorganic pool. - wet deposition: all is added to the dissolved inorganic pool. - fertilisers: all added to the dissolved inorganic pool. - manure: the inorganic fraction is added to the dissovled inorganic pool, with the rest added to the fast pool. - residue: the part with fast turnover is added to the fast pool, with the rest added to the humus pool. - Nutrient fluxes between these pools are simulated to represent the biochemical processes that can transform the nutrients between different forms. These processes include - degradation of humus pool to fast pool - dissolution of humus pool to dissovled organic pool - mineralisation of fast pool to dissolved inorganic pool - dissolution of fast pool to dissolved organic pool - immobilisation of dissolved inroganic pool to fast pool The rate of these processes are affected by the soil temperature and moisture conditions. - When soil erosion happens, a portion of both the adsorbed inorganic pool and humus pool for phosphorus will be eroded as well. - fraction_dry_n_to_dissolved_inorganic, fraction_manure_to_dissolved_inorganic, fraction_residue_to_fast. Units: -, all should in [0-1] - degrhpar, dishpar, minfpar, disfpar, immobdpar. Units: -, all should in [0-1] <code>PerviousSurface</code> - In IHACRES, the maximum infiltration per time step is controlled by an infiltration capacity, beyond which the precipitation will flow directly as surface runoff. - Evapotranspiration and effective precipitation are calculated based on soil moisture content. - Effective precipitation is then divided into percolation, surface runoff, and subsurface runoff by multiplying the corresponding coefficient. - Percolation, surface runoff, and subsurface runoff are sent into the corresponding residence tanks for rounting to downstream. - The mass of pollutants in soil water tank proportionately leaves the soil water tank into the routing residence tanks. Evapotranspiration can only bring out water, with pollutants left in the soil tank. - Field capacity and wilting point. Units: -, both should in [0-1], with field capacity &gt; wilting point - Infiltration capacity. Units: m/day - Surface, percolation coefficient. Units: -, both should in [0-1] - et0 coefficient. Units: - ihacres_p. Units: - <code>QueueGroundwater</code> - Conceptualises groundwater as a tank. - Baseflow is generated following a timearea method. - Baseflow is sent to <code>storage.py/River</code>, <code>nodes.py/Node</code> or <code>waste.py/Waste</code> nodes. - No infiltration to sewers is modelled. - If <code>decays</code> are provided to model water quality transformations, see <code>core.py/DecayObj</code>. - Groundwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres - <code>timearea</code> is a dictionary containing the timearea diagram. Units: duration of flow (in timesteps) and proportion of flow - Optional dictionary of decays with pollutants as keys and decay parameters (a constant and a temperature sensitivity exponent) as values. Units: - <code>Reservoir</code> - Conceptualised as a <code>Tank</code>. - Recharged only via pumped abstractions. - Evaporation/precipitation onto surface area currently ignored. - If <code>decays</code> are provided to model water quality transformations, see <code>core.py/DecayObj</code>. - Tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres - Optional dictionary of decays with pollutants as keys and decay parameters (a constant and a temperature sensitivity exponent) as values. Units: - <code>ResidentialDemand</code> - Per capita calculations to generate demand based on population. - Pollutant concentration of generated demand uses a fixed mass per person per timestep. - Temperature of generated wastewater is based partially on air temperature and partially on a constant. - Can interact with <code>land.py/GardenSurface</code> to simulate garden water use. - <code>population</code>. Units: n - <code>per_capita</code>. Units: m3/timestep - <code>data_input_dict</code> should contain air temperature at model timestep. Units: C <code>RiverReservoir</code> - Conceptualised as a <code>Tank</code>. - Recharged via pumped abstractions and receives water from inflowing arcs. - Reservoir aims to satisfy a static <code>environmental_flow</code>. - If tank capacity is exceeded, reservoir spills downstream towards <code>nodes.py/Node</code>, <code>storage.py/River</code> or <code>waste.py/Waste</code> nodes. Spill counts towards <code>environmental_flow</code>. - Evaporation/precipitation onto surface area currently ignored. - Currently, if a reservoir satisfies a pull from a downstream node, it does not count towards <code>environmental_flow</code>. - If <code>decays</code> are provided to model water quality transformations, see <code>core.py/DecayObj</code>. - Tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres - <code>environmental_flow</code> Units: cubic metres/timestep - Optional dictionary of decays with pollutants as keys and decay parameters (a constant and a temperature sensitivity exponent) as values. Units: - <code>River</code> - River is conceptualised as a water tank that receives flows from various sources (e.g., runoffs from urban and rural land, baseflow from groundwater), interacts with water infrastructure (e.g., abstraction for irrigation and domestic supply, sewage and treated effluent discharge), and discharges flows downstream. It has length and width as shape parameters, average velocity to indicate flow speed and capacity to indicate the maximum storage limit. - Flows from different sources into rivers will fully mix. River tank is assumed to have delay and attenuation effects when generate outflows. These effects are simulated based on the average velocity. - In-river biochemical processes are simulated as sources/sinks of nutrients in the river tank, including - denitrification (for nitrogen) - phytoplankton absorption/release (for nitrogen and phosphorus) - macrophyte uptake (for nitrogen and phosphorus) These processes are affected by river temperature. - depth, length, width Units: m - velocity Units: m/day - damping coefficient Units: - minimum required flow Units: m3/day <code>Sewer</code> - Sewer networks can be represented in an aggregated manner, where the behaviour of collections of manholes/pipes can be captured in a single component. - Travel time of water received from either <code>land.py/Land</code> objects or <code>demand.py/Demand</code> objects is assumed to be received as a non-point source and thus can be represented with the time-area method. - Travel time of water from an upstream <code>Sewer</code> object has a fixed travel time through the node. - The flow capacity of sewer network can be represented as with a <code>Tank</code>. - The <code>Sewer</code> object is not currently biochemically active. - <code>pipe_timearea</code> is a dictionary containing the timearea diagram. Units: duration of flow (in timesteps) and proportion of flow - <code>pipe_time</code> describes the travel time of water received from upstream <code>Sewer</code> objects. Units: number of timesteps - <code>capacity</code>, <code>chamber_area</code>, <code>chamber_datum</code> describe the dimensions of the <code>Tank</code> that controls flow. Units: cubic metres, squared metres, metres <code>Surface</code> - Generic <code>Surface</code> that reads data and can apply simple forms of pollution deposition. - Formulated as a <code>Tank</code> object. - Ammonia-&gt;Nitrite-&gt;Nitrate decay takes place if parameters describing this process are provided in <code>decays</code> (see <code>core.py/DecayObj</code> for transformation details). - <code>data_input_dict</code> can contain a variety of pollutant deposition data. <code>srp-dry</code> describes phosphate. <code>noy-dry</code> describes nitrogen as nitrates. <code>nhx-dry</code> describes nitrogen as ammonia. <code>srp/noy/ nhx-wet</code> can also be used to specify wet deposition. Units: kg/m2/timestep (data is read at a monthly timestep) <code>UnlimitedDistribution</code> - Water demand is always satisfied. - None <code>WTW</code> - Throughput can be modelled entirely with a set capacity. - Pollutant reduction for the entire treatment process can be modelled primarily with a single (temperature sensitive) transformation for each pollutant. - Liquor and solids are tracked and calculated with proportional multiplier parameters. - <code>treatment_throughput_capacity</code> Units: cubic metres/timestep - <code>process_parameters</code> contains the constant (non temperature sensitive) and exponent (temperature sensitive) transformations applied to treated water for each pollutant. Units: - <code>liquor_multiplier</code> and <code>percent_solids</code> describe the proportion of throughput that goes to liquor/solids. <code>WWTW</code> - See <code>wtw.py/WTW</code> for treatment. - When <code>treatment_throughput_capacity</code> is exceeded, water is first sent to a stormwater storage tank before denying pushes. Leftover water in this tank aims to be treated in subsequent timesteps. - Can be pulled from to simulate active wastewater effluent use. - See <code>wtw.py/WTW</code> for treatment. - Stormwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>. Units: cubic metres, squared metres, metres <code>Waste</code> - Water 'disappears' (leaves the model) from these nodes. - None"},{"location":"coverage/","title":"Coverage report","text":""},{"location":"dafni/","title":"Run WSIMOD in DAFNI","text":"<p>WSIMOD is available to run in DAFNI, the Data &amp; Analytics Facility for National Infrastructure to advance UK infrastructure research. This let you run WSIMOD simulations, and combining them with other tools, without the need of installing any of them.</p> <p>Assuming you have a DAFNI account, the steps to run a WSIMOD simulation will be the following:</p> <ul> <li>In the <code>Data</code> tab:</li> <li>Upload the input <code>YAML</code> file as a dataset. Please note that if your <code>YAML</code> file   contains <code>extensions</code> section, it should include additional linux path strings as   follows:   <code>extensions: [     /data/inputs/extension_1.py,     /data/inputs/extension_2.py,     ]</code></li> <li>Upload any other required input files as another dataset. This can contain     multiple files.</li> <li>In the <code>Workflow</code> tab select the <code>WSIMOD workflow</code>.</li> <li>In the <code>Parameter sets</code> section, click <code>Create</code>.</li> <li>In the page that opens, select the model in the workflow (typically <code>model-1</code>), and complete the sections at the bottom with the appropriate information:</li> <li>In the <code>Parameters</code>, choose the name of the settings file (normally     <code>settings.yaml</code> or <code>config.yaml</code>)</li> <li>In the <code>Datasets</code>, click in the pen icon and select the datasets you just uploaded     for the input <code>YAML</code> and the other data files. These all will be put together in the     same directory when running the simulation.</li> <li>Unselect <code>model-1</code>, click <code>Continue</code> and complete the required metadata in the next screen, like the name of the parameter set.</li> <li>Finally, click in <code>Execute workflow with parameter set</code>.</li> </ul> <p>If all goes well, you should then see in the <code>Workflow</code> page, <code>Instances</code> section, that there is a new <code>Instance</code> of WSIMOD running. After some time (dending on the complexity of the model and the load of the system), the run will finish and there will be a new <code>WISMOD output</code> dataset available in the <code>Data</code> tab.</p> <p>You can create new workflows to customise this process, name of the outputs, and even chain multiple models, one after the other.</p>"},{"location":"extending_wsimod/","title":"Extending and customising WSIMOD functionality","text":"<p>WSIMOD has many features built-in, but undoubtedly, to model real life scenarios, you will need to customise it to your specific needs.</p> <p>WSIMOD offers 4 ways of doing this customisation of increased complexity - and flexibility: custom orchestration, overrides, patches and custom classes.</p>"},{"location":"extending_wsimod/#custom-orchestration","title":"Custom orchestration","text":"<p>When trying to capture a given behaviour, we encourage users to first attempt to implement it by connecting <code>Nodes</code> and <code>Arcs</code> in a way that enables the behaviour to spontaneously arise from node interactions. By doing this, you create a model that is less prescribed and more likely to reveal interesting integrated mechanisms. That said, sometimes it is not possible, for example see Section 2.3 in our theory paper. In cases like this, our first recommendation is to customise your orchestration, which changes the order of operations within a timestep for a <code>Model</code> object.</p> <p>The model orchestration can be customised within the <code>orchestration</code> section of the config file. For example, the following orchestration will run the simulation with two actions: first it will run the <code>infiltrate</code> method for all nodes of <code>type_: Groundwater</code>, and then the <code>make_discharge</code> method for nodes all of <code>type_: Sewer</code>. Hint: just because the model sees a node as a given <code>type_</code>, doesn't mean the node has to be that class, see the model tutorial for more detail.</p> <pre><code>orchestration:\n- Groundwater: infiltrate\n- Sewer: make_discharge\n</code></pre> <p>If no <code>orchestration</code> is provided, then a default sequence is used. Check the Orchestration demonstration for more details on how to customise this. Note, that if you change your orchestration at all then you will have to provide a full orchestration for all <code>type_: functions</code> that need calling (even ones that are in the default orchestration, which you can find in <code>Model.__init__</code>).</p>"},{"location":"extending_wsimod/#overrides","title":"Overrides","text":"<p>Overrides are the next way of customising the behaviour of nodes or arcs. They enable specifying the value of one or more parameters of a specific - existing - node or arc. These overrides are specified in the config file for the model under a <code>overrides</code> section, and therefore they need to be objects that can be parsed in yaml - strings, floats, etc.</p> <p>Because many parameters require other states to change when they are changed, our recommendation is that any parameter changes are either changed directly in the <code>config</code> file or inside the <code>overrides</code> section of the config file (which offers a convenient location to include all changes made to a base <code>config</code>). Because of this, if you are changing parameters on-the-fly, we strongly recommend using the <code>add_overrides</code> functionality of the <code>Model</code> object.</p> <p>The following snippet shows and example on how to add overrides, in this case one node and one arc. <code>name</code> and <code>type_</code> are mandatory fields:</p> <pre><code>overrides:\n  nodes:\n    my_groundwater:\n      name: my_groundwater\n      type_: Groundwater,\n      infiltration_threshold: 200\n      infiltration_pct: 0.667\n      capacity: 1.43\n      area: 2.36\n      datum: 0.32\n  arcs:\n    storm_outflow:\n      name: storm_outflow\n      type_: Arc\n      capacity: 0.5\n</code></pre>"},{"location":"extending_wsimod/#patches","title":"Patches","text":"<p>You can make a more elaborate customisation of your WSIMOD models by using patches. Patches override the behaviour of full methods of a node. As they are fully working Python code, these patches need to be included in an extension file.</p> <p>Extensions files are extra Python modules that will be loaded when creating a model and that contain patches for specific nodes and custom classes - see below. Extension files are defined in the config file as:</p> <pre><code>extensions: [\n  extension/file/one.py,\n  extension/file/two.py\n]\n</code></pre> <p>They are imported in order, something to keep in mind if the order of applying the patches matter.</p> <p>Each python file can have any Python code, but it can only use the libraries and dependencies that are available in the system running WSIMOD. This means that, for maximum portability no other dependencies beyond those used by WSIMOD itself should be used in the extension files.</p> <p>There are several ways in which a node can be patched. For full details, visit the extensions reference section.</p> <p>A very simple example of an extensions that overrides the method <code>pull_distributed</code> for node <code>my_node</code> would be:</p> <pre><code>from wsimod.extensions import register_node_patch\n\n@register_node_patch(\"my_node\", \"pull_distributed\")\ndef empty_distributed(self, vqip):\n    return self.empty_vqip()\n</code></pre> <p>Here <code>my_node</code> must be a valid node name in the model. In this case, we are indicating that in <code>my_node</code>, when calling <code>pull_distributted</code>, our custom <code>empty_distributted</code> should be used instead.</p> <p>For further examples, see customise interactions.</p>"},{"location":"extending_wsimod/#custom-classes","title":"Custom classes","text":"<p>The patches method is very powerful and allows for a great deal of flexibility. However, there might be cases where you need more complex customisation - for example, with multiple methods that require rewriting or that depend on each other, or if new steps for the orchestration are required.</p> <p>In those cases, the simplest approach might be to create a new node class, subclassing an existing one - at the very least, subclassing <code>Node</code> if no other pre-defined node class is close enough.</p> <p>For example, we might want some new <code>Reservoir</code>-style of node that has some custom behaviour for evaporation and abstractions. In that case, we could do:</p> <pre><code>from wsimod.nodes.storage import Reservoir\n\n\nclass MyReservoir(Reservoir):\n\n    def apply_evaporation(self):\n        \"\"\"Add custom functionality here.\"\"\"\n\n    def make_abstractions(self):\n        \"\"\"Add some further customisation here.\"\"\"\n</code></pre> <p>Custom classes defined this way must be included in extension files, the same way it is done with patches, with the same rules in terms of Python packages and dependencies available to them. Also don't forget to customise the orchestration to ensure that the new <code>apply_evaporation</code> function is called during simulation.</p>"},{"location":"how-to/","title":"How-to guides","text":"<ol> <li>Extending WSIMOD</li> <li>Customise an arc</li> <li>Customise interactions</li> </ol>"},{"location":"installation/","title":"Installation","text":"<p>It is highly recommended to setup a virtual environment to install WSIMOD into. This way, its installation and that of its dependencies will not interfere with any other tool in your system.</p> <p>Here we use a <code>conda</code> environment which let us use the version of python we want to use, but you can use any other tool you are familiar with.</p> <pre><code>conda create --name wsimod python=3.10\nconda activate wsimod\n</code></pre> <p>You can install the stable version of WSIMOD from PyPI.org with:</p> <pre><code>pip install wsimod\n</code></pre> <p>If you want to install the development version, you can innstall WSIMOD directly from GitHub with:</p> <pre><code>pip install git+https://github.com/ImperialCollegeLondon/wsi@main\n</code></pre> <p>Use <code>[demos]</code> to include the dependencies required to run the demos and tutorials.</p> <pre><code>pip install wsimod[demos]\n</code></pre>"},{"location":"installation/#developing-wsimod","title":"Developing WSIMOD","text":"<p>If you want to help developing WSIMOD, or just modify it locally for your own interests, please read throgh the CONTRIBUTING guidelines in the GitHub repository.</p>"},{"location":"reference-arc/","title":"API Reference - Arcs","text":"<p>This section of the documentation provides a reference for the API of the  arcs.arcs module.</p> <p>Created on Wed Apr  7 08:43:32 2021.</p> <p>@author: Barney</p> <p>Converted to totals on Thur Apr 21 2022</p>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc","title":"<code>AltQueueArc</code>","text":"<p>               Bases: <code>QueueArc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class AltQueueArc(QueueArc):\n    \"\"\"\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"A simpler queue arc that has a queue that is a dict where each key is the\n        travel time.\n\n        Cannot be used if arc capacity is dynamic. Cannot be used for pulls.\n        \"\"\"\n        self.queue_arc_sum = self.alt_queue_arc_sum\n\n        super().__init__(**kwargs)\n        self.queue = {0: self.empty_vqip(), 1: self.empty_vqip()}\n        self.max_travel = 1\n\n    def alt_queue_arc_sum(self):\n        \"\"\"Sum the total water in the queue of the arc.\n\n        Returns:\n            (dict): A VQIP amount of water/pollutants in the arc\n        \"\"\"\n        queue_storage = self.empty_vqip()\n        for request in self.queue.values():\n            queue_storage = self.sum_vqip(queue_storage, request)\n        return queue_storage\n\n    def enter_queue(self, request, direction=\"push\", tag=\"default\"):\n        \"\"\"Add a request into the arc's queue.\n\n        Args:\n            request (dict): A dict with a VQIP under the 'vqip' key and the travel\n                time under the 'time' key.\n            direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n            tag (str, optional): Optional message for out_port's query handler, can be\n                'default' only. Defaults to 'default'.\n        \"\"\"\n        # Update inflows and format request\n        request = self.enter_arc(request, direction, tag)\n\n        # Sum into queue\n        if request[\"time\"] in self.queue.keys():\n            self.queue[request[\"time\"]] = self.sum_vqip(\n                self.queue[request[\"time\"]], request[\"vqip\"]\n            )\n        else:\n            self.queue[request[\"time\"]] = request[\"vqip\"]\n            self.max_travel = max(self.max_travel, request[\"time\"])\n\n    def update_queue(self, direction=None, backflow_enabled=True):\n        \"\"\"Trigger the push of water in the 0th key for the queue, if the out_port\n        responds that it cannot receive the push, then this water will be returned as\n        backflow (if enabled).\n\n        Args:\n            direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n            backflow_enabled (bool, optional): Enable backflow, described above, if not\n                enabled then the request will remain in the queue until all water has\n                been received. Defaults to True.\n\n        Returns:\n            backflow (dict): In the case of a push direction, any backflow will be\n                returned as a VQIP amount\n        \"\"\"\n        # TODO - can this work for pulls??\n\n        total_removed = self.copy_vqip(self.queue[0])\n\n        # Push 0 travel time water\n        backflow = self.out_port.push_set(total_removed)\n\n        if not backflow_enabled:\n            self.queue[0] = backflow\n            backflow = self.empty_vqip()\n        else:\n            self.queue[0] = self.empty_vqip()\n\n        total_removed = self.v_change_vqip(\n            total_removed, total_removed[\"volume\"] - backflow[\"volume\"]\n        )\n\n        self.flow_out += total_removed[\"volume\"]\n        self.vqip_out = self.sum_vqip(self.vqip_out, total_removed)\n\n        return backflow\n\n    def end_timestep(self):\n        \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n        capacity for that timestep.\n\n        Update timings in the queue.\n        \"\"\"\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n        self.flow_in = 0\n        self.flow_out = 0\n        self.queue_storage_ = self.copy_vqip(self.queue_storage)\n        self.queue_storage = self.empty_vqip()\n\n        queue_ = self.queue.copy()\n        keys = self.queue.keys()\n        for i in range(self.max_travel):\n            if (i + 1) in keys:\n                self.queue[i] = queue_[i + 1]\n                self.queue[i + 1] = self.empty_vqip()\n\n        self.queue[0] = self.sum_vqip(queue_[0], queue_[1])\n\n    def reinit(self):\n        \"\"\"\"\"\"\n        self.end_timestep()\n        self.queue = {0: self.empty_vqip(), 1: self.empty_vqip()}\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>A simpler queue arc that has a queue that is a dict where each key is the travel time.</p> <p>Cannot be used if arc capacity is dynamic. Cannot be used for pulls.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"A simpler queue arc that has a queue that is a dict where each key is the\n    travel time.\n\n    Cannot be used if arc capacity is dynamic. Cannot be used for pulls.\n    \"\"\"\n    self.queue_arc_sum = self.alt_queue_arc_sum\n\n    super().__init__(**kwargs)\n    self.queue = {0: self.empty_vqip(), 1: self.empty_vqip()}\n    self.max_travel = 1\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.alt_queue_arc_sum","title":"<code>alt_queue_arc_sum()</code>","text":"<p>Sum the total water in the queue of the arc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water/pollutants in the arc</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def alt_queue_arc_sum(self):\n    \"\"\"Sum the total water in the queue of the arc.\n\n    Returns:\n        (dict): A VQIP amount of water/pollutants in the arc\n    \"\"\"\n    queue_storage = self.empty_vqip()\n    for request in self.queue.values():\n        queue_storage = self.sum_vqip(queue_storage, request)\n    return queue_storage\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.end_timestep","title":"<code>end_timestep()</code>","text":"<p>End timestep in an arc, resetting flow/vqip in/out (which determine) the capacity for that timestep.</p> <p>Update timings in the queue.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def end_timestep(self):\n    \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n    capacity for that timestep.\n\n    Update timings in the queue.\n    \"\"\"\n    self.vqip_in = self.empty_vqip()\n    self.vqip_out = self.empty_vqip()\n    self.flow_in = 0\n    self.flow_out = 0\n    self.queue_storage_ = self.copy_vqip(self.queue_storage)\n    self.queue_storage = self.empty_vqip()\n\n    queue_ = self.queue.copy()\n    keys = self.queue.keys()\n    for i in range(self.max_travel):\n        if (i + 1) in keys:\n            self.queue[i] = queue_[i + 1]\n            self.queue[i + 1] = self.empty_vqip()\n\n    self.queue[0] = self.sum_vqip(queue_[0], queue_[1])\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.enter_queue","title":"<code>enter_queue(request, direction='push', tag='default')</code>","text":"<p>Add a request into the arc's queue.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>A dict with a VQIP under the 'vqip' key and the travel time under the 'time' key.</p> required <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' only. Defaults to 'push'</p> <code>'push'</code> <code>tag</code> <code>str</code> <p>Optional message for out_port's query handler, can be 'default' only. Defaults to 'default'.</p> <code>'default'</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def enter_queue(self, request, direction=\"push\", tag=\"default\"):\n    \"\"\"Add a request into the arc's queue.\n\n    Args:\n        request (dict): A dict with a VQIP under the 'vqip' key and the travel\n            time under the 'time' key.\n        direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n        tag (str, optional): Optional message for out_port's query handler, can be\n            'default' only. Defaults to 'default'.\n    \"\"\"\n    # Update inflows and format request\n    request = self.enter_arc(request, direction, tag)\n\n    # Sum into queue\n    if request[\"time\"] in self.queue.keys():\n        self.queue[request[\"time\"]] = self.sum_vqip(\n            self.queue[request[\"time\"]], request[\"vqip\"]\n        )\n    else:\n        self.queue[request[\"time\"]] = request[\"vqip\"]\n        self.max_travel = max(self.max_travel, request[\"time\"])\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.reinit","title":"<code>reinit()</code>","text":"Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def reinit(self):\n    \"\"\"\"\"\"\n    self.end_timestep()\n    self.queue = {0: self.empty_vqip(), 1: self.empty_vqip()}\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.AltQueueArc.update_queue","title":"<code>update_queue(direction=None, backflow_enabled=True)</code>","text":"<p>Trigger the push of water in the 0th key for the queue, if the out_port responds that it cannot receive the push, then this water will be returned as backflow (if enabled).</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' only. Defaults to 'push'</p> <code>None</code> <code>backflow_enabled</code> <code>bool</code> <p>Enable backflow, described above, if not enabled then the request will remain in the queue until all water has been received. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>backflow</code> <code>dict</code> <p>In the case of a push direction, any backflow will be returned as a VQIP amount</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def update_queue(self, direction=None, backflow_enabled=True):\n    \"\"\"Trigger the push of water in the 0th key for the queue, if the out_port\n    responds that it cannot receive the push, then this water will be returned as\n    backflow (if enabled).\n\n    Args:\n        direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n        backflow_enabled (bool, optional): Enable backflow, described above, if not\n            enabled then the request will remain in the queue until all water has\n            been received. Defaults to True.\n\n    Returns:\n        backflow (dict): In the case of a push direction, any backflow will be\n            returned as a VQIP amount\n    \"\"\"\n    # TODO - can this work for pulls??\n\n    total_removed = self.copy_vqip(self.queue[0])\n\n    # Push 0 travel time water\n    backflow = self.out_port.push_set(total_removed)\n\n    if not backflow_enabled:\n        self.queue[0] = backflow\n        backflow = self.empty_vqip()\n    else:\n        self.queue[0] = self.empty_vqip()\n\n    total_removed = self.v_change_vqip(\n        total_removed, total_removed[\"volume\"] - backflow[\"volume\"]\n    )\n\n    self.flow_out += total_removed[\"volume\"]\n    self.vqip_out = self.sum_vqip(self.vqip_out, total_removed)\n\n    return backflow\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc","title":"<code>Arc</code>","text":"<p>               Bases: <code>WSIObj</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class Arc(WSIObj):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name=\"\",\n        capacity=constants.UNBOUNDED_CAPACITY,\n        preference=1,\n        in_port=None,\n        out_port=None,\n        **kwargs,\n    ):\n        \"\"\"Arc objects are the way for information to be passed between nodes in WSIMOD.\n        They have an in_port (where a message comes from) and an out_port (where a\n        message goes to).\n\n        Returns:\n            name (str): Name of arc. Defaults to ''.\n            capacity (float): Capacity of flow along an arc (vol/timestep).\n                Defaults to constants.UNBOUNDED_CAPACITY.\n            preference (float): Number used to prioritise or deprioritise use of an arc\n                when flexibility exists\n            in_port: A WSIMOD node object where the arc starts\n            out_port: A WSIMOD node object where the arc ends\n        \"\"\"\n        # Default essential parameters\n        self.name = name\n        self.in_port = in_port\n        self.out_port = out_port\n        self.capacity = capacity\n        self.preference = preference\n\n        # Update args\n        WSIObj.__init__(self)\n        self.__dict__.update(kwargs)\n\n        # def all_subclasses(cls):\n        #     return set(cls.__subclasses__()).union(\n        #         [s for c in cls.__subclasses__() for s in all_subclasses(c)])\n        # node_types = [x.__name__ for x in all_subclasses(nodes.Node)] + ['Node']\n\n        # if self.name in node_types:\n        #     print('Warning: arc name should not take a node class name')\n        #     #TODO... not sure why... also currently commented for import issues..\n\n        # Initialise states\n        self.flow_in = 0\n        self.flow_out = 0\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n\n        # Update ports\n        self.in_port.out_arcs[self.name] = self\n        self.out_port.in_arcs[self.name] = self\n\n        out_type = self.out_port.__class__.__name__\n        in_type = self.in_port.__class__.__name__\n\n        if hasattr(self.in_port, \"out_arcs_type\"):\n            self.in_port.out_arcs_type[out_type][self.name] = self\n\n        if hasattr(self.out_port, \"in_arcs_type\"):\n            self.out_port.in_arcs_type[in_type][self.name] = self\n\n        # Mass balance checking\n        self.mass_balance_in = [lambda: self.vqip_in]\n        self.mass_balance_out = [lambda: self.vqip_out]\n        self.mass_balance_ds = [lambda: self.empty_vqip()]\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}) -&gt; None:\n        \"\"\"Apply overrides to the node.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.capacity = overrides.pop(\"capacity\", self.capacity)\n        self.preference = overrides.pop(\"preference\", self.preference)\n        if len(overrides) &gt; 0:\n            print(f\"No override behaviour defined for: {overrides.keys()}\")\n\n    def arc_mass_balance(self):\n        \"\"\"Checks mass balance for inflows/outflows/storage change in an arc.\n\n        Returns:\n            in_ (dict) Total vqip of vqip_in and other inputs in mass_balance_in\n            ds_ (dict): Total vqip of change in arc in mass_balance_ds\n            out_ (dict): Total vqip of vqip_out and other outputs in mass_balance_out\n\n        Examples:\n            arc_in, arc_out, arc_ds = my_arc.arc_mass_balance()\n        \"\"\"\n        in_, ds_, out_ = self.mass_balance()\n        return in_, ds_, out_\n\n    def send_push_request(self, vqip, tag=\"default\", force=False):\n        \"\"\"Function used to transmit a push request from one node (in_port) to another\n        node (out_port).\n\n        Args:\n            vqip (dict): A dict VQIP of water to push\n            tag (str, optional):  optional message to direct the out_port's query_\n                handler which function to call. Defaults to 'default'.\n            force (bool, optional): Argument used to cause function to ignore tank\n                capacity of out_port, possibly resulting in pooling. Should not be used\n                    unless\n                out_port is a tank object. Defaults to False.\n\n        Returns:\n            (dict): A VQIP amount of water that was not successfully pushed\n        \"\"\"\n        vqip = self.copy_vqip(vqip)\n\n        # Apply pipe capacity\n        if force:\n            not_pushed = self.empty_vqip()\n        else:\n            excess_in = self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n            not_pushed = self.v_change_vqip(\n                vqip, max(vqip[\"volume\"] - excess_in[\"volume\"], 0)\n            )\n\n        # Don't attempt to send volume that exceeds capacity\n        vqip = self.extract_vqip(vqip, not_pushed)\n\n        # Set push\n        reply = self.out_port.push_set(vqip, tag)\n\n        # Update total amount successfully sent\n        vqip = self.extract_vqip(vqip, reply)\n\n        # Combine non-sent water\n        reply = self.sum_vqip(reply, not_pushed)\n\n        # Update mass balance\n        self.flow_in += vqip[\"volume\"]\n        self.flow_out = self.flow_in\n\n        self.vqip_in = self.sum_vqip(self.vqip_in, vqip)\n        self.vqip_out = self.vqip_in\n\n        return reply\n\n    def send_pull_request(self, vqip, tag=\"default\"):\n        \"\"\"Function used to transmit a pull request from one node (in_port) to another\n        node (out_port).\n\n        Args:\n            vqip (dict): A dict VQIP of water to pull (by default, only 'volume' key is\n                used)\n            tag (str, optional): optional message to direct the out_port's query_handler\n                which\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): A VQIP amount of water that was successfully pulled\n        \"\"\"\n        volume = vqip[\"volume\"]\n        # Apply pipe capacity\n        excess_in = self.get_excess(direction=\"pull\", vqip=vqip, tag=tag)[\"volume\"]\n        not_pulled = max(volume - excess_in, 0)\n        volume -= not_pulled\n\n        if volume &gt; 0:\n            for pol in constants.ADDITIVE_POLLUTANTS:\n                if pol in vqip.keys():\n                    vqip[pol] *= volume / vqip[\"volume\"]\n\n        vqip[\"volume\"] = volume\n\n        # Make pull\n        vqip = self.in_port.pull_set(vqip, tag)\n\n        # Update mass balance\n        self.flow_in += vqip[\"volume\"]\n        self.flow_out = self.flow_in\n\n        self.vqip_in = self.sum_vqip(self.vqip_in, vqip)\n        self.vqip_out = self.vqip_in\n\n        return vqip\n\n    def send_push_check(self, vqip=None, tag=\"default\"):\n        \"\"\"Function used to transmit a push check from one node (in_port) to another\n        node (out_port).\n\n        Args:\n            vqip (dict): A dict VQIP of water to push that can be specified. Defaults to\n                None, which returns maximum capacity to push.\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): A VQIP amount of water that could be pushed\n        \"\"\"\n        return self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n\n    def send_pull_check(self, vqip=None, tag=\"default\"):\n        \"\"\"Function used to transmit a pull check from one node (in_port) to another\n        node (out_port).\n\n        Args:\n            vqip (dict): A dict VQIP of water to pull that can be specified (by default,\n                only the 'volume' key is used). Defaults to None, which returns all\n                    available water to pull.\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): A VQIP amount of water that could be pulled\n        \"\"\"\n        return self.get_excess(direction=\"pull\", vqip=vqip, tag=tag)\n\n    def get_excess(self, direction, vqip=None, tag=\"default\"):\n        \"\"\"Calculate how much could be pull/pulled along the arc by combining both arc\n        capacity and out_port check information.\n\n        Args:\n            direction (str): should be 'pull' or 'push'\n            vqip (dict, optional): A VQIP amount to push/pull that can be\n                specified. Defaults to None, which returns all available water to\n                pull or maximum capacity to push (depending on 'direction').\n            tag (str, optional): optional message to direct the out_port's query_handler\n                which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): A VQIP amount of water that could be pulled/pushed\n        \"\"\"\n        # Pipe capacity\n        pipe_excess = self.capacity - self.flow_in\n\n        # Node capacity\n        if direction == \"push\":\n            node_excess = self.out_port.push_check(vqip, tag)\n        elif direction == \"pull\":\n            node_excess = self.in_port.pull_check(vqip, tag)\n        excess = min(pipe_excess, node_excess[\"volume\"])\n\n        # TODO sensible to min(vqip, excess) here? (though it should be applied by node)\n\n        return self.v_change_vqip(node_excess, excess)\n\n    def end_timestep(self):\n        \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n        capacity for that timestep.\"\"\"\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n        self.flow_in = 0\n        self.flow_out = 0\n\n    def reinit(self):\n        \"\"\"Reinitiatilise.\"\"\"\n        self.end_timestep()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.__init__","title":"<code>__init__(name='', capacity=constants.UNBOUNDED_CAPACITY, preference=1, in_port=None, out_port=None, **kwargs)</code>","text":"<p>Arc objects are the way for information to be passed between nodes in WSIMOD. They have an in_port (where a message comes from) and an out_port (where a message goes to).</p> <p>Returns:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of arc. Defaults to ''.</p> <code>capacity</code> <code>float</code> <p>Capacity of flow along an arc (vol/timestep). Defaults to constants.UNBOUNDED_CAPACITY.</p> <code>preference</code> <code>float</code> <p>Number used to prioritise or deprioritise use of an arc when flexibility exists</p> <code>in_port</code> <p>A WSIMOD node object where the arc starts</p> <code>out_port</code> <p>A WSIMOD node object where the arc ends</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(\n    self,\n    name=\"\",\n    capacity=constants.UNBOUNDED_CAPACITY,\n    preference=1,\n    in_port=None,\n    out_port=None,\n    **kwargs,\n):\n    \"\"\"Arc objects are the way for information to be passed between nodes in WSIMOD.\n    They have an in_port (where a message comes from) and an out_port (where a\n    message goes to).\n\n    Returns:\n        name (str): Name of arc. Defaults to ''.\n        capacity (float): Capacity of flow along an arc (vol/timestep).\n            Defaults to constants.UNBOUNDED_CAPACITY.\n        preference (float): Number used to prioritise or deprioritise use of an arc\n            when flexibility exists\n        in_port: A WSIMOD node object where the arc starts\n        out_port: A WSIMOD node object where the arc ends\n    \"\"\"\n    # Default essential parameters\n    self.name = name\n    self.in_port = in_port\n    self.out_port = out_port\n    self.capacity = capacity\n    self.preference = preference\n\n    # Update args\n    WSIObj.__init__(self)\n    self.__dict__.update(kwargs)\n\n    # def all_subclasses(cls):\n    #     return set(cls.__subclasses__()).union(\n    #         [s for c in cls.__subclasses__() for s in all_subclasses(c)])\n    # node_types = [x.__name__ for x in all_subclasses(nodes.Node)] + ['Node']\n\n    # if self.name in node_types:\n    #     print('Warning: arc name should not take a node class name')\n    #     #TODO... not sure why... also currently commented for import issues..\n\n    # Initialise states\n    self.flow_in = 0\n    self.flow_out = 0\n    self.vqip_in = self.empty_vqip()\n    self.vqip_out = self.empty_vqip()\n\n    # Update ports\n    self.in_port.out_arcs[self.name] = self\n    self.out_port.in_arcs[self.name] = self\n\n    out_type = self.out_port.__class__.__name__\n    in_type = self.in_port.__class__.__name__\n\n    if hasattr(self.in_port, \"out_arcs_type\"):\n        self.in_port.out_arcs_type[out_type][self.name] = self\n\n    if hasattr(self.out_port, \"in_arcs_type\"):\n        self.out_port.in_arcs_type[in_type][self.name] = self\n\n    # Mass balance checking\n    self.mass_balance_in = [lambda: self.vqip_in]\n    self.mass_balance_out = [lambda: self.vqip_out]\n    self.mass_balance_ds = [lambda: self.empty_vqip()]\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the node.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def apply_overrides(self, overrides: Dict[str, Any] = {}) -&gt; None:\n    \"\"\"Apply overrides to the node.\n\n    Args:\n        overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n    \"\"\"\n    self.capacity = overrides.pop(\"capacity\", self.capacity)\n    self.preference = overrides.pop(\"preference\", self.preference)\n    if len(overrides) &gt; 0:\n        print(f\"No override behaviour defined for: {overrides.keys()}\")\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.arc_mass_balance","title":"<code>arc_mass_balance()</code>","text":"<p>Checks mass balance for inflows/outflows/storage change in an arc.</p> <p>Returns:</p> Name Type Description <p>in_ (dict) Total vqip of vqip_in and other inputs in mass_balance_in</p> <code>ds_</code> <code>dict</code> <p>Total vqip of change in arc in mass_balance_ds</p> <code>out_</code> <code>dict</code> <p>Total vqip of vqip_out and other outputs in mass_balance_out</p> <p>Examples:</p> <p>arc_in, arc_out, arc_ds = my_arc.arc_mass_balance()</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def arc_mass_balance(self):\n    \"\"\"Checks mass balance for inflows/outflows/storage change in an arc.\n\n    Returns:\n        in_ (dict) Total vqip of vqip_in and other inputs in mass_balance_in\n        ds_ (dict): Total vqip of change in arc in mass_balance_ds\n        out_ (dict): Total vqip of vqip_out and other outputs in mass_balance_out\n\n    Examples:\n        arc_in, arc_out, arc_ds = my_arc.arc_mass_balance()\n    \"\"\"\n    in_, ds_, out_ = self.mass_balance()\n    return in_, ds_, out_\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.end_timestep","title":"<code>end_timestep()</code>","text":"<p>End timestep in an arc, resetting flow/vqip in/out (which determine) the capacity for that timestep.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def end_timestep(self):\n    \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n    capacity for that timestep.\"\"\"\n    self.vqip_in = self.empty_vqip()\n    self.vqip_out = self.empty_vqip()\n    self.flow_in = 0\n    self.flow_out = 0\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.get_excess","title":"<code>get_excess(direction, vqip=None, tag='default')</code>","text":"<p>Calculate how much could be pull/pulled along the arc by combining both arc capacity and out_port check information.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>should be 'pull' or 'push'</p> required <code>vqip</code> <code>dict</code> <p>A VQIP amount to push/pull that can be specified. Defaults to None, which returns all available water to pull or maximum capacity to push (depending on 'direction').</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that could be pulled/pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def get_excess(self, direction, vqip=None, tag=\"default\"):\n    \"\"\"Calculate how much could be pull/pulled along the arc by combining both arc\n    capacity and out_port check information.\n\n    Args:\n        direction (str): should be 'pull' or 'push'\n        vqip (dict, optional): A VQIP amount to push/pull that can be\n            specified. Defaults to None, which returns all available water to\n            pull or maximum capacity to push (depending on 'direction').\n        tag (str, optional): optional message to direct the out_port's query_handler\n            which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): A VQIP amount of water that could be pulled/pushed\n    \"\"\"\n    # Pipe capacity\n    pipe_excess = self.capacity - self.flow_in\n\n    # Node capacity\n    if direction == \"push\":\n        node_excess = self.out_port.push_check(vqip, tag)\n    elif direction == \"pull\":\n        node_excess = self.in_port.pull_check(vqip, tag)\n    excess = min(pipe_excess, node_excess[\"volume\"])\n\n    # TODO sensible to min(vqip, excess) here? (though it should be applied by node)\n\n    return self.v_change_vqip(node_excess, excess)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.reinit","title":"<code>reinit()</code>","text":"<p>Reinitiatilise.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def reinit(self):\n    \"\"\"Reinitiatilise.\"\"\"\n    self.end_timestep()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.send_pull_check","title":"<code>send_pull_check(vqip=None, tag='default')</code>","text":"<p>Function used to transmit a pull check from one node (in_port) to another node (out_port).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to pull that can be specified (by default, only the 'volume' key is used). Defaults to None, which returns all     available water to pull.</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that could be pulled</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_pull_check(self, vqip=None, tag=\"default\"):\n    \"\"\"Function used to transmit a pull check from one node (in_port) to another\n    node (out_port).\n\n    Args:\n        vqip (dict): A dict VQIP of water to pull that can be specified (by default,\n            only the 'volume' key is used). Defaults to None, which returns all\n                available water to pull.\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): A VQIP amount of water that could be pulled\n    \"\"\"\n    return self.get_excess(direction=\"pull\", vqip=vqip, tag=tag)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.send_pull_request","title":"<code>send_pull_request(vqip, tag='default')</code>","text":"<p>Function used to transmit a pull request from one node (in_port) to another node (out_port).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to pull (by default, only 'volume' key is used)</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was successfully pulled</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_pull_request(self, vqip, tag=\"default\"):\n    \"\"\"Function used to transmit a pull request from one node (in_port) to another\n    node (out_port).\n\n    Args:\n        vqip (dict): A dict VQIP of water to pull (by default, only 'volume' key is\n            used)\n        tag (str, optional): optional message to direct the out_port's query_handler\n            which\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): A VQIP amount of water that was successfully pulled\n    \"\"\"\n    volume = vqip[\"volume\"]\n    # Apply pipe capacity\n    excess_in = self.get_excess(direction=\"pull\", vqip=vqip, tag=tag)[\"volume\"]\n    not_pulled = max(volume - excess_in, 0)\n    volume -= not_pulled\n\n    if volume &gt; 0:\n        for pol in constants.ADDITIVE_POLLUTANTS:\n            if pol in vqip.keys():\n                vqip[pol] *= volume / vqip[\"volume\"]\n\n    vqip[\"volume\"] = volume\n\n    # Make pull\n    vqip = self.in_port.pull_set(vqip, tag)\n\n    # Update mass balance\n    self.flow_in += vqip[\"volume\"]\n    self.flow_out = self.flow_in\n\n    self.vqip_in = self.sum_vqip(self.vqip_in, vqip)\n    self.vqip_out = self.vqip_in\n\n    return vqip\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.send_push_check","title":"<code>send_push_check(vqip=None, tag='default')</code>","text":"<p>Function used to transmit a push check from one node (in_port) to another node (out_port).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to push that can be specified. Defaults to None, which returns maximum capacity to push.</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that could be pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_push_check(self, vqip=None, tag=\"default\"):\n    \"\"\"Function used to transmit a push check from one node (in_port) to another\n    node (out_port).\n\n    Args:\n        vqip (dict): A dict VQIP of water to push that can be specified. Defaults to\n            None, which returns maximum capacity to push.\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): A VQIP amount of water that could be pushed\n    \"\"\"\n    return self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.Arc.send_push_request","title":"<code>send_push_request(vqip, tag='default', force=False)</code>","text":"<p>Function used to transmit a push request from one node (in_port) to another node (out_port).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to push</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_ handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <code>force</code> <code>bool</code> <p>Argument used to cause function to ignore tank capacity of out_port, possibly resulting in pooling. Should not be used     unless out_port is a tank object. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was not successfully pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_push_request(self, vqip, tag=\"default\", force=False):\n    \"\"\"Function used to transmit a push request from one node (in_port) to another\n    node (out_port).\n\n    Args:\n        vqip (dict): A dict VQIP of water to push\n        tag (str, optional):  optional message to direct the out_port's query_\n            handler which function to call. Defaults to 'default'.\n        force (bool, optional): Argument used to cause function to ignore tank\n            capacity of out_port, possibly resulting in pooling. Should not be used\n                unless\n            out_port is a tank object. Defaults to False.\n\n    Returns:\n        (dict): A VQIP amount of water that was not successfully pushed\n    \"\"\"\n    vqip = self.copy_vqip(vqip)\n\n    # Apply pipe capacity\n    if force:\n        not_pushed = self.empty_vqip()\n    else:\n        excess_in = self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n        not_pushed = self.v_change_vqip(\n            vqip, max(vqip[\"volume\"] - excess_in[\"volume\"], 0)\n        )\n\n    # Don't attempt to send volume that exceeds capacity\n    vqip = self.extract_vqip(vqip, not_pushed)\n\n    # Set push\n    reply = self.out_port.push_set(vqip, tag)\n\n    # Update total amount successfully sent\n    vqip = self.extract_vqip(vqip, reply)\n\n    # Combine non-sent water\n    reply = self.sum_vqip(reply, not_pushed)\n\n    # Update mass balance\n    self.flow_in += vqip[\"volume\"]\n    self.flow_out = self.flow_in\n\n    self.vqip_in = self.sum_vqip(self.vqip_in, vqip)\n    self.vqip_out = self.vqip_in\n\n    return reply\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArc","title":"<code>DecayArc</code>","text":"<p>               Bases: <code>QueueArc</code>, <code>DecayObj</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class DecayArc(QueueArc, DecayObj):\n    \"\"\"\"\"\"\n\n    def __init__(self, decays={}, **kwargs):\n        \"\"\"A QueueArc that applies decays from a DecayObj.\n\n        Args:\n            decays (dict, optional): A dict of dicts containing a key for each pollutant\n                that decays and within that, a key for each parameter (a constant and\n                exponent). Defaults to {}.\n        \"\"\"\n        self.decays = decays\n\n        QueueArc.__init__(self, **kwargs)\n        DecayObj.__init__(self, decays)\n\n        self.mass_balance_out.append(lambda: self.total_decayed)\n\n    def enter_queue(self, request, direction=None, tag=\"default\"):\n        \"\"\"Add a request into the arc's queue list. Apply the make_decay function (i.e.,\n        the decay that occur's this timestep).\n\n        Args:\n            request (dict): A dict with a VQIP under the 'vqip' key and the travel\n                time under the 'time' key.\n            direction (str): Direction of flow, can be 'push' or 'pull\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n        \"\"\"\n        # Update inflows and format\n        request = self.enter_arc(request, direction, tag)\n\n        # TODO - currently decay depends on temp at the in_port data object..\n        # surely on vqip would be more sensible? (though this is true in many\n        # places including WTW)\n\n        # Decay on entry\n        request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n\n        # Append to queue\n        self.queue.append(request)\n\n    def end_timestep(self):\n        \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n        capacity for that timestep.\n\n        Update times of requests in the queue. Apply the make_decay function (i.e., the\n        decay that occurs in the following timestep).\n        \"\"\"\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n        self.total_decayed = self.empty_vqip()\n        self.flow_in = 0\n        self.flow_out = 0\n\n        self.queue_storage_ = self.copy_vqip(self.queue_storage)\n        self.queue_storage = self.empty_vqip()\n\n        for request in self.queue:\n            request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n            request[\"time\"] = max(request[\"time\"] - 1, 0)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArc.__init__","title":"<code>__init__(decays={}, **kwargs)</code>","text":"<p>A QueueArc that applies decays from a DecayObj.</p> <p>Parameters:</p> Name Type Description Default <code>decays</code> <code>dict</code> <p>A dict of dicts containing a key for each pollutant that decays and within that, a key for each parameter (a constant and exponent). Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, decays={}, **kwargs):\n    \"\"\"A QueueArc that applies decays from a DecayObj.\n\n    Args:\n        decays (dict, optional): A dict of dicts containing a key for each pollutant\n            that decays and within that, a key for each parameter (a constant and\n            exponent). Defaults to {}.\n    \"\"\"\n    self.decays = decays\n\n    QueueArc.__init__(self, **kwargs)\n    DecayObj.__init__(self, decays)\n\n    self.mass_balance_out.append(lambda: self.total_decayed)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArc.end_timestep","title":"<code>end_timestep()</code>","text":"<p>End timestep in an arc, resetting flow/vqip in/out (which determine) the capacity for that timestep.</p> <p>Update times of requests in the queue. Apply the make_decay function (i.e., the decay that occurs in the following timestep).</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def end_timestep(self):\n    \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n    capacity for that timestep.\n\n    Update times of requests in the queue. Apply the make_decay function (i.e., the\n    decay that occurs in the following timestep).\n    \"\"\"\n    self.vqip_in = self.empty_vqip()\n    self.vqip_out = self.empty_vqip()\n    self.total_decayed = self.empty_vqip()\n    self.flow_in = 0\n    self.flow_out = 0\n\n    self.queue_storage_ = self.copy_vqip(self.queue_storage)\n    self.queue_storage = self.empty_vqip()\n\n    for request in self.queue:\n        request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n        request[\"time\"] = max(request[\"time\"] - 1, 0)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArc.enter_queue","title":"<code>enter_queue(request, direction=None, tag='default')</code>","text":"<p>Add a request into the arc's queue list. Apply the make_decay function (i.e., the decay that occur's this timestep).</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>A dict with a VQIP under the 'vqip' key and the travel time under the 'time' key.</p> required <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' or 'pull</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def enter_queue(self, request, direction=None, tag=\"default\"):\n    \"\"\"Add a request into the arc's queue list. Apply the make_decay function (i.e.,\n    the decay that occur's this timestep).\n\n    Args:\n        request (dict): A dict with a VQIP under the 'vqip' key and the travel\n            time under the 'time' key.\n        direction (str): Direction of flow, can be 'push' or 'pull\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n    \"\"\"\n    # Update inflows and format\n    request = self.enter_arc(request, direction, tag)\n\n    # TODO - currently decay depends on temp at the in_port data object..\n    # surely on vqip would be more sensible? (though this is true in many\n    # places including WTW)\n\n    # Decay on entry\n    request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n\n    # Append to queue\n    self.queue.append(request)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArcAlt","title":"<code>DecayArcAlt</code>","text":"<p>               Bases: <code>AltQueueArc</code>, <code>DecayObj</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class DecayArcAlt(AltQueueArc, DecayObj):\n    \"\"\"\"\"\"\n\n    def __init__(self, decays={}, **kwargs):\n        \"\"\"An AltQueueArc that applies decays from a DecayObj.\n\n        Args:\n            decays (dict, optional): A dict of dicts containing a key for each pollutant\n                that decays and within that, a key for each parameter (a constant and\n                exponent). Defaults to {}.\n        \"\"\"\n        self.decays = {}\n\n        # super().__init__(**kwargs)\n        AltQueueArc.__init__(self, **kwargs)\n        DecayObj.__init__(self, decays)\n\n        self.end_timestep = self._end_timestep\n\n        self.mass_balance_out.append(lambda: self.total_decayed)\n\n    def enter_queue(self, request, direction=None, tag=\"default\"):\n        \"\"\"Add a request into the arc's queue. Apply the make_decay function (i.e., the\n        decay that occur's this timestep).\n\n        Args:\n            request (dict): A dict with a VQIP under the 'vqip' key and the travel\n                time under the 'time' key.\n            direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n            tag (str, optional): Optional message for out_port's query handler, can be\n                'default' only. Defaults to 'default'.\n        \"\"\"\n        # TODO- has no tags\n\n        # Update inflows and format\n        request = self.enter_arc(request, direction, tag)\n\n        # Decay on entry\n        request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n\n        # Sum into queue\n        if request[\"time\"] in self.queue.keys():\n            self.queue[request[\"time\"]] = self.sum_vqip(\n                self.queue[request[\"time\"]], request[\"vqip\"]\n            )\n        else:\n            self.queue[request[\"time\"]] = request[\"vqip\"]\n            self.max_travel = max(self.max_travel, request[\"time\"])\n\n    def _end_timestep(self):\n        \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n        capacity for that timestep.\n\n        Update timings in the queue. Apply the make_decay function (i.e., the decay that\n        occurs in the following timestep).\n        \"\"\"\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n        self.total_decayed = self.empty_vqip()\n        self.flow_in = 0\n        self.flow_out = 0\n\n        self.queue_storage_ = self.copy_vqip(self.queue_storage)\n        self.queue_storage = (\n            self.empty_vqip()\n        )  # TODO I don't think this (or any queue_storage=  empty) is necessary\n\n        queue_ = self.queue.copy()\n        keys = self.queue.keys()\n        for i in range(self.max_travel):\n            if (i + 1) in keys:\n                self.queue[i] = self.make_decay(queue_[i + 1])\n                self.queue[i + 1] = self.empty_vqip()\n\n        self.queue[0] = self.sum_vqip(self.queue[0], self.make_decay(queue_[0]))\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArcAlt.__init__","title":"<code>__init__(decays={}, **kwargs)</code>","text":"<p>An AltQueueArc that applies decays from a DecayObj.</p> <p>Parameters:</p> Name Type Description Default <code>decays</code> <code>dict</code> <p>A dict of dicts containing a key for each pollutant that decays and within that, a key for each parameter (a constant and exponent). Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, decays={}, **kwargs):\n    \"\"\"An AltQueueArc that applies decays from a DecayObj.\n\n    Args:\n        decays (dict, optional): A dict of dicts containing a key for each pollutant\n            that decays and within that, a key for each parameter (a constant and\n            exponent). Defaults to {}.\n    \"\"\"\n    self.decays = {}\n\n    # super().__init__(**kwargs)\n    AltQueueArc.__init__(self, **kwargs)\n    DecayObj.__init__(self, decays)\n\n    self.end_timestep = self._end_timestep\n\n    self.mass_balance_out.append(lambda: self.total_decayed)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.DecayArcAlt.enter_queue","title":"<code>enter_queue(request, direction=None, tag='default')</code>","text":"<p>Add a request into the arc's queue. Apply the make_decay function (i.e., the decay that occur's this timestep).</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>A dict with a VQIP under the 'vqip' key and the travel time under the 'time' key.</p> required <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' only. Defaults to 'push'</p> <code>None</code> <code>tag</code> <code>str</code> <p>Optional message for out_port's query handler, can be 'default' only. Defaults to 'default'.</p> <code>'default'</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def enter_queue(self, request, direction=None, tag=\"default\"):\n    \"\"\"Add a request into the arc's queue. Apply the make_decay function (i.e., the\n    decay that occur's this timestep).\n\n    Args:\n        request (dict): A dict with a VQIP under the 'vqip' key and the travel\n            time under the 'time' key.\n        direction (str): Direction of flow, can be 'push' only. Defaults to 'push'\n        tag (str, optional): Optional message for out_port's query handler, can be\n            'default' only. Defaults to 'default'.\n    \"\"\"\n    # TODO- has no tags\n\n    # Update inflows and format\n    request = self.enter_arc(request, direction, tag)\n\n    # Decay on entry\n    request[\"vqip\"] = self.make_decay(request[\"vqip\"])\n\n    # Sum into queue\n    if request[\"time\"] in self.queue.keys():\n        self.queue[request[\"time\"]] = self.sum_vqip(\n            self.queue[request[\"time\"]], request[\"vqip\"]\n        )\n    else:\n        self.queue[request[\"time\"]] = request[\"vqip\"]\n        self.max_travel = max(self.max_travel, request[\"time\"])\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PullArc","title":"<code>PullArc</code>","text":"<p>               Bases: <code>Arc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class PullArc(Arc):\n    \"\"\"\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Subclass of Arc where pushes return no availability to push.\n\n        This creates an Arc where only pull requests/checks can be sent, similar to a\n        river abstraction.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.send_push_request = self.send_push_deny\n        self.send_push_check = self.send_push_check_deny\n\n    def send_push_deny(self, vqip, tag=\"default\", force=False):\n        \"\"\"Function used to deny any push requests.\n\n        Args:\n            vqip (dict): A dict VQIP of water to push\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n            force (bool, optional): Argument used to cause function to ignore tank\n                capacity of out_port, possibly resulting in pooling. Should not be used\n                unless out_port is a tank object. Defaults to False.\n\n        Returns:\n            (dict): A VQIP amount of water that was not successfully pushed\n        \"\"\"\n        return vqip\n\n    def send_push_check_deny(self, vqip=None, tag=\"default\"):\n        \"\"\"Function used to deny any push checks.\n\n        Args:\n            vqip (dict): A dict VQIP of water to push that can be specified. Defaults to\n                None, which returns maximum capacity to push.\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): An empty VQIP amount of water indicating no water can be pushed\n        \"\"\"\n        return self.empty_vqip()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PullArc.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Subclass of Arc where pushes return no availability to push.</p> <p>This creates an Arc where only pull requests/checks can be sent, similar to a river abstraction.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Subclass of Arc where pushes return no availability to push.\n\n    This creates an Arc where only pull requests/checks can be sent, similar to a\n    river abstraction.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.send_push_request = self.send_push_deny\n    self.send_push_check = self.send_push_check_deny\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PullArc.send_push_check_deny","title":"<code>send_push_check_deny(vqip=None, tag='default')</code>","text":"<p>Function used to deny any push checks.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to push that can be specified. Defaults to None, which returns maximum capacity to push.</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP amount of water indicating no water can be pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_push_check_deny(self, vqip=None, tag=\"default\"):\n    \"\"\"Function used to deny any push checks.\n\n    Args:\n        vqip (dict): A dict VQIP of water to push that can be specified. Defaults to\n            None, which returns maximum capacity to push.\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): An empty VQIP amount of water indicating no water can be pushed\n    \"\"\"\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PullArc.send_push_deny","title":"<code>send_push_deny(vqip, tag='default', force=False)</code>","text":"<p>Function used to deny any push requests.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to push</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <code>force</code> <code>bool</code> <p>Argument used to cause function to ignore tank capacity of out_port, possibly resulting in pooling. Should not be used unless out_port is a tank object. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was not successfully pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_push_deny(self, vqip, tag=\"default\", force=False):\n    \"\"\"Function used to deny any push requests.\n\n    Args:\n        vqip (dict): A dict VQIP of water to push\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n        force (bool, optional): Argument used to cause function to ignore tank\n            capacity of out_port, possibly resulting in pooling. Should not be used\n            unless out_port is a tank object. Defaults to False.\n\n    Returns:\n        (dict): A VQIP amount of water that was not successfully pushed\n    \"\"\"\n    return vqip\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PushArc","title":"<code>PushArc</code>","text":"<p>               Bases: <code>Arc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class PushArc(Arc):\n    \"\"\"\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Subclass of Arc where pushes return no availability to pull.\n\n        This creates an Arc where only push requests/checks can be sent, similar to a\n        CSO.\n        \"\"\"\n        super().__init__(**kwargs)\n        self.send_pull_request = self.send_pull_deny\n        self.send_pull_check = self.send_pull_check_deny\n\n    def send_pull_deny(self, vqip, tag=\"default\", force=False):\n        \"\"\"Function used to deny any pull requests.\n\n        Args:\n            vqip (dict): A dict VQIP of water to pull\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n            force (bool, optional): Argument used to cause function to ignore tank\n                capacity of out_port, possibly resulting in pooling. Should not be used\n                unless  out_port is a tank object. Defaults to False.\n\n        Returns:\n            (dict): A VQIP amount of water that was successfully pulled\n        \"\"\"\n        return self.empty_vqip()\n\n    def send_pull_check_deny(self, vqip=None, tag=\"default\"):\n        \"\"\"Function used to deny any pull checks.\n\n        Args:\n            vqip (dict): A dict VQIP of water to pull that can be specified. Defaults to\n                None, which returns maximum capacity to pull.\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): An empty VQIP amount of water indicating no water can be pulled\n        \"\"\"\n        return self.empty_vqip()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PushArc.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Subclass of Arc where pushes return no availability to pull.</p> <p>This creates an Arc where only push requests/checks can be sent, similar to a CSO.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Subclass of Arc where pushes return no availability to pull.\n\n    This creates an Arc where only push requests/checks can be sent, similar to a\n    CSO.\n    \"\"\"\n    super().__init__(**kwargs)\n    self.send_pull_request = self.send_pull_deny\n    self.send_pull_check = self.send_pull_check_deny\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PushArc.send_pull_check_deny","title":"<code>send_pull_check_deny(vqip=None, tag='default')</code>","text":"<p>Function used to deny any pull checks.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to pull that can be specified. Defaults to None, which returns maximum capacity to pull.</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP amount of water indicating no water can be pulled</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_pull_check_deny(self, vqip=None, tag=\"default\"):\n    \"\"\"Function used to deny any pull checks.\n\n    Args:\n        vqip (dict): A dict VQIP of water to pull that can be specified. Defaults to\n            None, which returns maximum capacity to pull.\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): An empty VQIP amount of water indicating no water can be pulled\n    \"\"\"\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.PushArc.send_pull_deny","title":"<code>send_pull_deny(vqip, tag='default', force=False)</code>","text":"<p>Function used to deny any pull requests.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A dict VQIP of water to pull</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <code>force</code> <code>bool</code> <p>Argument used to cause function to ignore tank capacity of out_port, possibly resulting in pooling. Should not be used unless  out_port is a tank object. Defaults to False.</p> <code>False</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was successfully pulled</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_pull_deny(self, vqip, tag=\"default\", force=False):\n    \"\"\"Function used to deny any pull requests.\n\n    Args:\n        vqip (dict): A dict VQIP of water to pull\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n        force (bool, optional): Argument used to cause function to ignore tank\n            capacity of out_port, possibly resulting in pooling. Should not be used\n            unless  out_port is a tank object. Defaults to False.\n\n    Returns:\n        (dict): A VQIP amount of water that was successfully pulled\n    \"\"\"\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc","title":"<code>QueueArc</code>","text":"<p>               Bases: <code>Arc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class QueueArc(Arc):\n    \"\"\"\"\"\"\n\n    def __init__(self, number_of_timesteps=0, **kwargs):\n        \"\"\"A queue arc that stores each push or pull individually in the queue. Enables\n        implementation of travel time. A fixed number of timesteps can be specified as a\n        parameter, and additional number of timesteps can be specified when the requests\n        are made.\n\n        The queue is a list of requests, where their travel time is decremented\n        by 1 each timestep. Any requests with a travel time of 0 will be sent\n        onwards if the 'update_queue' function is called.\n\n        Args:\n            number_of_timesteps (int, optional): Fixed number of timesteps that\n                it takes to traverse the arc. Defaults to 0.\n        \"\"\"\n        self.number_of_timesteps = number_of_timesteps\n        self.queue = []\n        super().__init__(**kwargs)\n\n        self.queue_storage = self.empty_vqip()\n        self.queue_storage_ = self.empty_vqip()\n\n        self.mass_balance_ds.append(lambda: self.queue_arc_ds())\n\n    def queue_arc_ds(self):\n        \"\"\"Calculate change in amount of water and other pollutants in the arc.\n\n        Returns:\n            (dict): A VQIP amount of change\n        \"\"\"\n        self.queue_storage = self.queue_arc_sum()\n        return self.extract_vqip(self.queue_storage, self.queue_storage_)\n\n    def queue_arc_sum(self):\n        \"\"\"Sum the total water in the requests in the queue of the arc.\n\n        Returns:\n            (dict): A VQIP amount of water/pollutants in the arc\n        \"\"\"\n        queue_storage = self.empty_vqip()\n        for request in self.queue:\n            queue_storage = self.sum_vqip(queue_storage, request[\"vqip\"])\n        return queue_storage\n\n    def send_pull_request(self, vqip, tag=\"default\", time=0):\n        \"\"\"Function used to transmit a pull request from one node (in_port) to another\n        node (out_port). Any pulled water is immediately removed from the out_port and\n        then takes the travel time to be received. This function has not been\n        extensively tested.\n\n        Args:\n            vqip (_type_): A dict VQIP of water to pull (by default, only 'volume' key\n                is used)\n            tag (str, optional): optional message to direct the out_port's query_handler\n                which function to call. Defaults to 'default'.\n            time (int, optional): Travel time for request to spend in the arc (in\n                addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.\n\n        Returns:\n            (dict): A VQIP amount of water that was successfully pulled.\n        \"\"\"\n        volume = vqip[\"volume\"]\n        # Apply pipe capacity\n        excess_in = self.get_excess(direction=\"pull\", vqip=vqip)[\"volume\"]\n        not_pulled = max(volume - excess_in, 0)\n        volume -= not_pulled\n\n        for pol in constants.ADDITIVE_POLLUTANTS:\n            if pol in vqip.keys():\n                vqip[pol] *= volume / vqip[\"volume\"]\n\n        vqip[\"volume\"] = volume\n\n        # Make pull\n        vqip = self.in_port.pull_set(vqip)\n\n        # Update to queue request\n        request = {\"time\": time + self.number_of_timesteps, \"vqip\": vqip}\n\n        # vqtip enters arc as a request\n        self.enter_queue(request, direction=\"pull\")\n\n        # Update request queue and return pulls from queue\n        reply = self.update_queue(direction=\"pull\")\n        return reply\n\n    def send_push_request(self, vqip_, tag=\"default\", force=False, time=0):\n        \"\"\"Function used to transmit a push request from one node (in_port) to another\n        node (out_port).\n\n        Args:\n            vqip_ (dict): A dict VQIP of water to push.\n            tag (str, optional): optional message to direct the out_port's query_handler\n                which function to call. Defaults to 'default'.\n            force (bool, optional): Ignore the capacity of the arc (note does not\n                currently, pass the force argument to the out_port). Defaults to False.\n            time (int, optional): Travel time for request to spend in the arc (in\n                addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.\n\n        Returns:\n            (dict): A VQIP amount of water that was not successfully pushed\n        \"\"\"\n        vqip = self.copy_vqip(vqip_)\n\n        if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n            return self.empty_vqip()\n\n        # Apply pipe capacity\n        if force:\n            not_pushed = self.empty_vqip()\n        else:\n            excess_in = self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n            not_pushed = self.v_change_vqip(\n                vqip, max(vqip[\"volume\"] - excess_in[\"volume\"], 0)\n            )\n\n        vqip = self.extract_vqip(vqip, not_pushed)\n\n        # Update to queue request\n        request = {\"time\": time + self.number_of_timesteps, \"vqip\": vqip}\n\n        # vqtip enters arc as a request\n        self.enter_queue(request, direction=\"push\", tag=tag)\n\n        # Update request queue\n        backflow = self.update_queue(direction=\"push\")\n        not_pushed = self.sum_vqip(not_pushed, backflow)\n\n        if backflow[\"volume\"] &gt; vqip_[\"volume\"]:\n            print(\"more backflow than vqip...\")\n\n        self.vqip_in = self.extract_vqip(self.vqip_in, backflow)\n\n        return not_pushed\n\n    def enter_arc(self, request, direction, tag):\n        \"\"\"Function used to cause format a request into the format expected by the\n        enter_queue function.\n\n        Args:\n            request (dict): A dict with a VQIP under the 'vqip' key and the travel\n                time under the 'time' key.\n            direction (str): Direction of flow, can be 'push' or 'pull\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): The request dict with additional information entered for the queue.\n        \"\"\"\n        request[\"average_flow\"] = request[\"vqip\"][\"volume\"] / (request[\"time\"] + 1)\n        request[\"direction\"] = direction\n        request[\"tag\"] = tag\n\n        self.flow_in += request[\"average_flow\"]\n        self.vqip_in = self.sum_vqip(self.vqip_in, request[\"vqip\"])\n\n        return request\n\n    def enter_queue(self, request, direction=None, tag=\"default\"):\n        \"\"\"Add a request into the arc's queue list.\n\n        Args:\n            request (dict): A dict with a VQIP under the 'vqip' key and the travel\n                time under the 'time' key.\n            direction (str): Direction of flow, can be 'push' or 'pull\n            tag (str, optional):  optional message to direct the out_port's\n                query_handler which function to call. Defaults to 'default'.\n        \"\"\"\n        # Update inflows and format request\n        request = self.enter_arc(request, direction, tag)\n\n        # Enter queue\n        self.queue.append(request)\n\n    def update_queue(self, direction=None, backflow_enabled=True):\n        \"\"\"Iterate over all requests in the queue, removing them if they have no volume.\n\n        If a request is a push and has 0 travel time remaining then\n        the push will be triggered at the out_port, if the out_port responds that\n        it cannot receive the push, then this water will be returned as backflow\n        (if enabled).\n\n        If a request is a pull and has 0 travel time remaining then it is simply summed\n        with other 0 travel time pull_requests and returned (since the pull is made at\n        the out_port when the send_pull_request is made).\n\n\n        Args:\n            direction (str, optional): Direction of flow, can be 'push' or 'pull.\n                Defaults to None.\n            backflow_enabled (bool, optional): Enable backflow, described above, if not\n                enabled then the request will remain in the queue until all water has\n                been received. Defaults to True.\n\n        Returns:\n            total_backflow (dict): In the case of a push direction, any backflow will be\n                returned as a VQIP amount\n            total_removed (dict): In the case of a pull direction, any pulled water will\n                be returned as a VQIP amount\n        \"\"\"\n        done_requests = []\n\n        total_removed = self.empty_vqip()\n        total_backflow = self.empty_vqip()\n        # Iterate over requests\n        for request in self.queue:\n            if request[\"direction\"] == direction:\n                vqip = request[\"vqip\"]\n\n                if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n                    # Add to queue for removal\n                    done_requests.append(request)\n                elif request[\"time\"] == 0:\n                    if direction == \"push\":\n                        # Attempt to push request\n                        reply = self.out_port.push_set(vqip, request[\"tag\"])\n                        removed = vqip[\"volume\"] - reply[\"volume\"]\n\n                    elif direction == \"pull\":\n                        # Water has already been pulled, so assume all received\n                        removed = vqip[\"volume\"]\n\n                    else:\n                        print(\"No direction\")\n\n                    # Update outflows\n                    self.flow_out += request[\"average_flow\"] * removed / vqip[\"volume\"]\n                    vqip_ = self.v_change_vqip(vqip, removed)\n                    total_removed = self.sum_vqip(total_removed, vqip_)\n\n                    # Assume that any water that cannot arrive at destination this\n                    # timestep is backflow\n                    rejected = self.v_change_vqip(vqip, vqip[\"volume\"] - removed)\n\n                    if backflow_enabled | (\n                        rejected[\"volume\"] &lt; constants.FLOAT_ACCURACY\n                    ):\n                        total_backflow = self.sum_vqip(rejected, total_backflow)\n                        done_requests.append(request)\n                    else:\n                        request[\"vqip\"] = rejected\n\n        self.vqip_out = self.sum_vqip(self.vqip_out, total_removed)\n\n        # Remove done requests\n        for request in done_requests:\n            self.queue.remove(request)\n\n        # return total_removed\n        if direction == \"pull\":\n            return total_removed\n        elif direction == \"push\":\n            return total_backflow\n        else:\n            print(\"No direction\")\n\n    def end_timestep(self):\n        \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n        capacity for that timestep.\n\n        Update times of requests in the queue.\n        \"\"\"\n        self.vqip_in = self.empty_vqip()\n        self.vqip_out = self.empty_vqip()\n        self.flow_in = 0\n        self.flow_out = 0\n\n        self.queue_storage_ = self.copy_vqip(self.queue_storage)\n        self.queue_storage = self.empty_vqip()\n\n        for request in self.queue:\n            request[\"time\"] = max(request[\"time\"] - 1, 0)\n\n        # TODO - update_queue here?\n\n    def reinit(self):\n        \"\"\"\"\"\"\n        self.end_timestep()\n        self.queue = []\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.__init__","title":"<code>__init__(number_of_timesteps=0, **kwargs)</code>","text":"<p>A queue arc that stores each push or pull individually in the queue. Enables implementation of travel time. A fixed number of timesteps can be specified as a parameter, and additional number of timesteps can be specified when the requests are made.</p> <p>The queue is a list of requests, where their travel time is decremented by 1 each timestep. Any requests with a travel time of 0 will be sent onwards if the 'update_queue' function is called.</p> <p>Parameters:</p> Name Type Description Default <code>number_of_timesteps</code> <code>int</code> <p>Fixed number of timesteps that it takes to traverse the arc. Defaults to 0.</p> <code>0</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def __init__(self, number_of_timesteps=0, **kwargs):\n    \"\"\"A queue arc that stores each push or pull individually in the queue. Enables\n    implementation of travel time. A fixed number of timesteps can be specified as a\n    parameter, and additional number of timesteps can be specified when the requests\n    are made.\n\n    The queue is a list of requests, where their travel time is decremented\n    by 1 each timestep. Any requests with a travel time of 0 will be sent\n    onwards if the 'update_queue' function is called.\n\n    Args:\n        number_of_timesteps (int, optional): Fixed number of timesteps that\n            it takes to traverse the arc. Defaults to 0.\n    \"\"\"\n    self.number_of_timesteps = number_of_timesteps\n    self.queue = []\n    super().__init__(**kwargs)\n\n    self.queue_storage = self.empty_vqip()\n    self.queue_storage_ = self.empty_vqip()\n\n    self.mass_balance_ds.append(lambda: self.queue_arc_ds())\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.end_timestep","title":"<code>end_timestep()</code>","text":"<p>End timestep in an arc, resetting flow/vqip in/out (which determine) the capacity for that timestep.</p> <p>Update times of requests in the queue.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def end_timestep(self):\n    \"\"\"End timestep in an arc, resetting flow/vqip in/out (which determine) the\n    capacity for that timestep.\n\n    Update times of requests in the queue.\n    \"\"\"\n    self.vqip_in = self.empty_vqip()\n    self.vqip_out = self.empty_vqip()\n    self.flow_in = 0\n    self.flow_out = 0\n\n    self.queue_storage_ = self.copy_vqip(self.queue_storage)\n    self.queue_storage = self.empty_vqip()\n\n    for request in self.queue:\n        request[\"time\"] = max(request[\"time\"] - 1, 0)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.enter_arc","title":"<code>enter_arc(request, direction, tag)</code>","text":"<p>Function used to cause format a request into the format expected by the enter_queue function.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>A dict with a VQIP under the 'vqip' key and the travel time under the 'time' key.</p> required <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' or 'pull</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>The request dict with additional information entered for the queue.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def enter_arc(self, request, direction, tag):\n    \"\"\"Function used to cause format a request into the format expected by the\n    enter_queue function.\n\n    Args:\n        request (dict): A dict with a VQIP under the 'vqip' key and the travel\n            time under the 'time' key.\n        direction (str): Direction of flow, can be 'push' or 'pull\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): The request dict with additional information entered for the queue.\n    \"\"\"\n    request[\"average_flow\"] = request[\"vqip\"][\"volume\"] / (request[\"time\"] + 1)\n    request[\"direction\"] = direction\n    request[\"tag\"] = tag\n\n    self.flow_in += request[\"average_flow\"]\n    self.vqip_in = self.sum_vqip(self.vqip_in, request[\"vqip\"])\n\n    return request\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.enter_queue","title":"<code>enter_queue(request, direction=None, tag='default')</code>","text":"<p>Add a request into the arc's queue list.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>dict</code> <p>A dict with a VQIP under the 'vqip' key and the travel time under the 'time' key.</p> required <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' or 'pull</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def enter_queue(self, request, direction=None, tag=\"default\"):\n    \"\"\"Add a request into the arc's queue list.\n\n    Args:\n        request (dict): A dict with a VQIP under the 'vqip' key and the travel\n            time under the 'time' key.\n        direction (str): Direction of flow, can be 'push' or 'pull\n        tag (str, optional):  optional message to direct the out_port's\n            query_handler which function to call. Defaults to 'default'.\n    \"\"\"\n    # Update inflows and format request\n    request = self.enter_arc(request, direction, tag)\n\n    # Enter queue\n    self.queue.append(request)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.queue_arc_ds","title":"<code>queue_arc_ds()</code>","text":"<p>Calculate change in amount of water and other pollutants in the arc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of change</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def queue_arc_ds(self):\n    \"\"\"Calculate change in amount of water and other pollutants in the arc.\n\n    Returns:\n        (dict): A VQIP amount of change\n    \"\"\"\n    self.queue_storage = self.queue_arc_sum()\n    return self.extract_vqip(self.queue_storage, self.queue_storage_)\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.queue_arc_sum","title":"<code>queue_arc_sum()</code>","text":"<p>Sum the total water in the requests in the queue of the arc.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water/pollutants in the arc</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def queue_arc_sum(self):\n    \"\"\"Sum the total water in the requests in the queue of the arc.\n\n    Returns:\n        (dict): A VQIP amount of water/pollutants in the arc\n    \"\"\"\n    queue_storage = self.empty_vqip()\n    for request in self.queue:\n        queue_storage = self.sum_vqip(queue_storage, request[\"vqip\"])\n    return queue_storage\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.reinit","title":"<code>reinit()</code>","text":"Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def reinit(self):\n    \"\"\"\"\"\"\n    self.end_timestep()\n    self.queue = []\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.send_pull_request","title":"<code>send_pull_request(vqip, tag='default', time=0)</code>","text":"<p>Function used to transmit a pull request from one node (in_port) to another node (out_port). Any pulled water is immediately removed from the out_port and then takes the travel time to be received. This function has not been extensively tested.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>_type_</code> <p>A dict VQIP of water to pull (by default, only 'volume' key is used)</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <code>time</code> <code>int</code> <p>Travel time for request to spend in the arc (in addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was successfully pulled.</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_pull_request(self, vqip, tag=\"default\", time=0):\n    \"\"\"Function used to transmit a pull request from one node (in_port) to another\n    node (out_port). Any pulled water is immediately removed from the out_port and\n    then takes the travel time to be received. This function has not been\n    extensively tested.\n\n    Args:\n        vqip (_type_): A dict VQIP of water to pull (by default, only 'volume' key\n            is used)\n        tag (str, optional): optional message to direct the out_port's query_handler\n            which function to call. Defaults to 'default'.\n        time (int, optional): Travel time for request to spend in the arc (in\n            addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.\n\n    Returns:\n        (dict): A VQIP amount of water that was successfully pulled.\n    \"\"\"\n    volume = vqip[\"volume\"]\n    # Apply pipe capacity\n    excess_in = self.get_excess(direction=\"pull\", vqip=vqip)[\"volume\"]\n    not_pulled = max(volume - excess_in, 0)\n    volume -= not_pulled\n\n    for pol in constants.ADDITIVE_POLLUTANTS:\n        if pol in vqip.keys():\n            vqip[pol] *= volume / vqip[\"volume\"]\n\n    vqip[\"volume\"] = volume\n\n    # Make pull\n    vqip = self.in_port.pull_set(vqip)\n\n    # Update to queue request\n    request = {\"time\": time + self.number_of_timesteps, \"vqip\": vqip}\n\n    # vqtip enters arc as a request\n    self.enter_queue(request, direction=\"pull\")\n\n    # Update request queue and return pulls from queue\n    reply = self.update_queue(direction=\"pull\")\n    return reply\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.send_push_request","title":"<code>send_push_request(vqip_, tag='default', force=False, time=0)</code>","text":"<p>Function used to transmit a push request from one node (in_port) to another node (out_port).</p> <p>Parameters:</p> Name Type Description Default <code>vqip_</code> <code>dict</code> <p>A dict VQIP of water to push.</p> required <code>tag</code> <code>str</code> <p>optional message to direct the out_port's query_handler which function to call. Defaults to 'default'.</p> <code>'default'</code> <code>force</code> <code>bool</code> <p>Ignore the capacity of the arc (note does not currently, pass the force argument to the out_port). Defaults to False.</p> <code>False</code> <code>time</code> <code>int</code> <p>Travel time for request to spend in the arc (in addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was not successfully pushed</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def send_push_request(self, vqip_, tag=\"default\", force=False, time=0):\n    \"\"\"Function used to transmit a push request from one node (in_port) to another\n    node (out_port).\n\n    Args:\n        vqip_ (dict): A dict VQIP of water to push.\n        tag (str, optional): optional message to direct the out_port's query_handler\n            which function to call. Defaults to 'default'.\n        force (bool, optional): Ignore the capacity of the arc (note does not\n            currently, pass the force argument to the out_port). Defaults to False.\n        time (int, optional): Travel time for request to spend in the arc (in\n            addition to the arc's 'number_of_timesteps' parameter). Defaults to 0.\n\n    Returns:\n        (dict): A VQIP amount of water that was not successfully pushed\n    \"\"\"\n    vqip = self.copy_vqip(vqip_)\n\n    if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n        return self.empty_vqip()\n\n    # Apply pipe capacity\n    if force:\n        not_pushed = self.empty_vqip()\n    else:\n        excess_in = self.get_excess(direction=\"push\", vqip=vqip, tag=tag)\n        not_pushed = self.v_change_vqip(\n            vqip, max(vqip[\"volume\"] - excess_in[\"volume\"], 0)\n        )\n\n    vqip = self.extract_vqip(vqip, not_pushed)\n\n    # Update to queue request\n    request = {\"time\": time + self.number_of_timesteps, \"vqip\": vqip}\n\n    # vqtip enters arc as a request\n    self.enter_queue(request, direction=\"push\", tag=tag)\n\n    # Update request queue\n    backflow = self.update_queue(direction=\"push\")\n    not_pushed = self.sum_vqip(not_pushed, backflow)\n\n    if backflow[\"volume\"] &gt; vqip_[\"volume\"]:\n        print(\"more backflow than vqip...\")\n\n    self.vqip_in = self.extract_vqip(self.vqip_in, backflow)\n\n    return not_pushed\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.QueueArc.update_queue","title":"<code>update_queue(direction=None, backflow_enabled=True)</code>","text":"<p>Iterate over all requests in the queue, removing them if they have no volume.</p> <p>If a request is a push and has 0 travel time remaining then the push will be triggered at the out_port, if the out_port responds that it cannot receive the push, then this water will be returned as backflow (if enabled).</p> <p>If a request is a pull and has 0 travel time remaining then it is simply summed with other 0 travel time pull_requests and returned (since the pull is made at the out_port when the send_pull_request is made).</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>Direction of flow, can be 'push' or 'pull. Defaults to None.</p> <code>None</code> <code>backflow_enabled</code> <code>bool</code> <p>Enable backflow, described above, if not enabled then the request will remain in the queue until all water has been received. Defaults to True.</p> <code>True</code> <p>Returns:</p> Name Type Description <code>total_backflow</code> <code>dict</code> <p>In the case of a push direction, any backflow will be returned as a VQIP amount</p> <code>total_removed</code> <code>dict</code> <p>In the case of a pull direction, any pulled water will be returned as a VQIP amount</p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>def update_queue(self, direction=None, backflow_enabled=True):\n    \"\"\"Iterate over all requests in the queue, removing them if they have no volume.\n\n    If a request is a push and has 0 travel time remaining then\n    the push will be triggered at the out_port, if the out_port responds that\n    it cannot receive the push, then this water will be returned as backflow\n    (if enabled).\n\n    If a request is a pull and has 0 travel time remaining then it is simply summed\n    with other 0 travel time pull_requests and returned (since the pull is made at\n    the out_port when the send_pull_request is made).\n\n\n    Args:\n        direction (str, optional): Direction of flow, can be 'push' or 'pull.\n            Defaults to None.\n        backflow_enabled (bool, optional): Enable backflow, described above, if not\n            enabled then the request will remain in the queue until all water has\n            been received. Defaults to True.\n\n    Returns:\n        total_backflow (dict): In the case of a push direction, any backflow will be\n            returned as a VQIP amount\n        total_removed (dict): In the case of a pull direction, any pulled water will\n            be returned as a VQIP amount\n    \"\"\"\n    done_requests = []\n\n    total_removed = self.empty_vqip()\n    total_backflow = self.empty_vqip()\n    # Iterate over requests\n    for request in self.queue:\n        if request[\"direction\"] == direction:\n            vqip = request[\"vqip\"]\n\n            if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n                # Add to queue for removal\n                done_requests.append(request)\n            elif request[\"time\"] == 0:\n                if direction == \"push\":\n                    # Attempt to push request\n                    reply = self.out_port.push_set(vqip, request[\"tag\"])\n                    removed = vqip[\"volume\"] - reply[\"volume\"]\n\n                elif direction == \"pull\":\n                    # Water has already been pulled, so assume all received\n                    removed = vqip[\"volume\"]\n\n                else:\n                    print(\"No direction\")\n\n                # Update outflows\n                self.flow_out += request[\"average_flow\"] * removed / vqip[\"volume\"]\n                vqip_ = self.v_change_vqip(vqip, removed)\n                total_removed = self.sum_vqip(total_removed, vqip_)\n\n                # Assume that any water that cannot arrive at destination this\n                # timestep is backflow\n                rejected = self.v_change_vqip(vqip, vqip[\"volume\"] - removed)\n\n                if backflow_enabled | (\n                    rejected[\"volume\"] &lt; constants.FLOAT_ACCURACY\n                ):\n                    total_backflow = self.sum_vqip(rejected, total_backflow)\n                    done_requests.append(request)\n                else:\n                    request[\"vqip\"] = rejected\n\n    self.vqip_out = self.sum_vqip(self.vqip_out, total_removed)\n\n    # Remove done requests\n    for request in done_requests:\n        self.queue.remove(request)\n\n    # return total_removed\n    if direction == \"pull\":\n        return total_removed\n    elif direction == \"push\":\n        return total_backflow\n    else:\n        print(\"No direction\")\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.SewerArc","title":"<code>SewerArc</code>","text":"<p>               Bases: <code>Arc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class SewerArc(Arc):\n    \"\"\"\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference-arc/#wsimod.arcs.arcs.WeirArc","title":"<code>WeirArc</code>","text":"<p>               Bases: <code>SewerArc</code></p> Source code in <code>wsimod/arcs/arcs.py</code> <pre><code>class WeirArc(SewerArc):\n    \"\"\"\"\"\"\n\n    pass\n</code></pre>"},{"location":"reference-core/","title":"API Reference - Core","text":"<p>This section of the documentation provides a reference for the API of the  core.core and core.constants modules.</p> <p>Created on Wed Apr  7 15:44:48 2021.</p> <p>@author: Barney</p> <p>Converted to totals on Thur Apr 21 2022</p> <p>Created on Fri Dec  6 15:17:07 2019.</p> <p>@author: bdobson</p>"},{"location":"reference-core/#wsimod.core.core.DecayObj","title":"<code>DecayObj</code>","text":"<p>               Bases: <code>WSIObj</code></p> Source code in <code>wsimod/core/core.py</code> <pre><code>class DecayObj(WSIObj):\n    \"\"\"\"\"\"\n\n    # TODO - internet says this is a bad idea (diamond will occur when a Node - a type\n    # of WSIObj inherits a DecayObj - also a type of WSIObj). The reason diamonds are\n    # problems is because there can be conflicts in functions. But I don't want anyone\n    # to overwrite WSIObj functions so I don't see an issue?\n    def __init__(self, decays):\n        \"\"\"A WSIObj that has decay functions built in.\n\n        Args:\n            decays (dict): A dict of dicts containing a key for each pollutant that\n            decays\n                and, within that, a key for each parameter (a constant and exponent)\n\n        Examples:\n            The 'constant' parameter represents what proportion of an amount will\n            decrease each time make_decay is called. Lower value will reduce decay.\n            Bounded between 0 and 1. The 'exponent' parameter represents how temperature\n            sensitive the decay is. The higher the value, the more pollution occurs at\n            higher values. Values expected to vary between 1 (no temperature\n            sensitivity) and 1.1 (high temperature sensitivity).\n\n            &gt;&gt;&gt; decays = {'phosphate' : {'constant' : 0.001, 'exponent' : 1.005}}\n\n        Raises:\n            Message if no access to temperature data\n        \"\"\"\n        # Store decays\n        self.decays = decays\n        super().__init__()\n\n        # Identify parent object to read temperature data\n        if \"parent\" in dir(self):\n            self.data_input_object = self.parent\n        elif \"in_port\" in dir(self):\n            self.data_input_object = self.in_port\n        else:\n            print(\"warning: decay object cannot access temperature data\")\n\n        self.total_decayed = self.empty_vqip()\n\n    def make_decay(self, vqip):\n        \"\"\"Make decay, reading tempature and updating pollutant amounts. A wrapper for\n        generic_temperature_decay.\n\n        Args:\n            vqip (dict): A VQIP to decay where pollutants are given as mass totals\n\n        Returns:\n            vqip_ (dict): A VQIP with pollutant amounts updated\n        \"\"\"\n        # Read temperature data\n        temperature = self.data_input_object.data_input_dict[\n            (\"temperature\", self.data_input_object.t)\n        ]\n        # Make decay\n        vqip_, diff = self.generic_temperature_decay(vqip, self.decays, temperature)\n        # Update total_decayed for mass balance checking\n        self.total_decayed = self.sum_vqip(self.total_decayed, diff)\n        return vqip_\n\n    def generic_temperature_decay(self, t, d, temperature):\n        \"\"\"Performs temperature sensitive pollutant decay calculations for a VQIP where\n        pollutants are given as mass totals.\n\n        Args:\n            t (dict): A VQIP to decay where pollutants are given as mass totals d\n            (dict): decays in a DecayObj temperature (float): temperature\n\n        Returns:\n            t (dict): A VQIP with updated pollutant values diff (dict): A VQIP storing\n            the change in pollutant values (decreases\n                stored as positive numbers)\n        \"\"\"\n        t = self.copy_vqip(t)\n        diff = self.empty_vqip()\n        # Iterate over pollutants in d (keys)\n        for pol, pars in d.items():\n            # Perform calculation\n            diff[pol] = t[pol] * min(\n                pars[\"constant\"]\n                * pars[\"exponent\"]\n                ** (temperature - constants.DECAY_REFERENCE_TEMPERATURE),\n                1,\n            )\n            # Update VQIP\n            t[pol] -= diff[pol]\n\n        return t, diff\n\n    def generic_temperature_decay_c(self, c, d, temperature):\n        \"\"\"Performs temperature sensitive pollutant decay calculations for a VQIP where\n        pollutants are given as concentrations.\n\n        Args:\n            c (dict): A VQIP to decay where pollutants are given as concentrations. d\n            (dict): decays in a DecayObj temperature (float): temperature\n\n        Returns:\n            t (dict): A VQIP with updated pollutant values (pollutants as\n                concentrations)\n            diff (dict): A VQIP storing the change in pollutant values (decreases\n                stored as positive numbers). Pollutants as mass totals.\n        \"\"\"\n        c = self.copy_vqip(c)\n        diff = self.empty_vqip()\n        for pol, pars in d.items():\n            diff[pol] = c[pol] * min(\n                pars[\"constant\"]\n                * pars[\"exponent\"]\n                ** (temperature - constants.DECAY_REFERENCE_TEMPERATURE),\n                1,\n            )\n            c[pol] -= diff[pol]\n\n            diff[pol] *= c[\"volume\"]\n        return c, diff\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.DecayObj.__init__","title":"<code>__init__(decays)</code>","text":"<p>A WSIObj that has decay functions built in.</p> <p>Parameters:</p> Name Type Description Default <code>decays</code> <code>dict</code> <p>A dict of dicts containing a key for each pollutant that</p> required <p>Examples:</p> <p>The 'constant' parameter represents what proportion of an amount will decrease each time make_decay is called. Lower value will reduce decay. Bounded between 0 and 1. The 'exponent' parameter represents how temperature sensitive the decay is. The higher the value, the more pollution occurs at higher values. Values expected to vary between 1 (no temperature sensitivity) and 1.1 (high temperature sensitivity).</p> <pre><code>&gt;&gt;&gt; decays = {'phosphate' : {'constant' : 0.001, 'exponent' : 1.005}}\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def __init__(self, decays):\n    \"\"\"A WSIObj that has decay functions built in.\n\n    Args:\n        decays (dict): A dict of dicts containing a key for each pollutant that\n        decays\n            and, within that, a key for each parameter (a constant and exponent)\n\n    Examples:\n        The 'constant' parameter represents what proportion of an amount will\n        decrease each time make_decay is called. Lower value will reduce decay.\n        Bounded between 0 and 1. The 'exponent' parameter represents how temperature\n        sensitive the decay is. The higher the value, the more pollution occurs at\n        higher values. Values expected to vary between 1 (no temperature\n        sensitivity) and 1.1 (high temperature sensitivity).\n\n        &gt;&gt;&gt; decays = {'phosphate' : {'constant' : 0.001, 'exponent' : 1.005}}\n\n    Raises:\n        Message if no access to temperature data\n    \"\"\"\n    # Store decays\n    self.decays = decays\n    super().__init__()\n\n    # Identify parent object to read temperature data\n    if \"parent\" in dir(self):\n        self.data_input_object = self.parent\n    elif \"in_port\" in dir(self):\n        self.data_input_object = self.in_port\n    else:\n        print(\"warning: decay object cannot access temperature data\")\n\n    self.total_decayed = self.empty_vqip()\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.DecayObj.generic_temperature_decay","title":"<code>generic_temperature_decay(t, d, temperature)</code>","text":"<p>Performs temperature sensitive pollutant decay calculations for a VQIP where pollutants are given as mass totals.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP to decay where pollutants are given as mass totals d</p> required <code></code> <code>dict</code> <p>decays in a DecayObj temperature (float): temperature</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>dict): A VQIP with updated pollutant values diff (dict</code> <p>A VQIP storing</p> <p>the change in pollutant values (decreases stored as positive numbers)</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def generic_temperature_decay(self, t, d, temperature):\n    \"\"\"Performs temperature sensitive pollutant decay calculations for a VQIP where\n    pollutants are given as mass totals.\n\n    Args:\n        t (dict): A VQIP to decay where pollutants are given as mass totals d\n        (dict): decays in a DecayObj temperature (float): temperature\n\n    Returns:\n        t (dict): A VQIP with updated pollutant values diff (dict): A VQIP storing\n        the change in pollutant values (decreases\n            stored as positive numbers)\n    \"\"\"\n    t = self.copy_vqip(t)\n    diff = self.empty_vqip()\n    # Iterate over pollutants in d (keys)\n    for pol, pars in d.items():\n        # Perform calculation\n        diff[pol] = t[pol] * min(\n            pars[\"constant\"]\n            * pars[\"exponent\"]\n            ** (temperature - constants.DECAY_REFERENCE_TEMPERATURE),\n            1,\n        )\n        # Update VQIP\n        t[pol] -= diff[pol]\n\n    return t, diff\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.DecayObj.generic_temperature_decay_c","title":"<code>generic_temperature_decay_c(c, d, temperature)</code>","text":"<p>Performs temperature sensitive pollutant decay calculations for a VQIP where pollutants are given as concentrations.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>dict</code> <p>A VQIP to decay where pollutants are given as concentrations. d</p> required <code></code> <code>dict</code> <p>decays in a DecayObj temperature (float): temperature</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>dict</code> <p>A VQIP with updated pollutant values (pollutants as concentrations)</p> <code>diff</code> <code>dict</code> <p>A VQIP storing the change in pollutant values (decreases stored as positive numbers). Pollutants as mass totals.</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def generic_temperature_decay_c(self, c, d, temperature):\n    \"\"\"Performs temperature sensitive pollutant decay calculations for a VQIP where\n    pollutants are given as concentrations.\n\n    Args:\n        c (dict): A VQIP to decay where pollutants are given as concentrations. d\n        (dict): decays in a DecayObj temperature (float): temperature\n\n    Returns:\n        t (dict): A VQIP with updated pollutant values (pollutants as\n            concentrations)\n        diff (dict): A VQIP storing the change in pollutant values (decreases\n            stored as positive numbers). Pollutants as mass totals.\n    \"\"\"\n    c = self.copy_vqip(c)\n    diff = self.empty_vqip()\n    for pol, pars in d.items():\n        diff[pol] = c[pol] * min(\n            pars[\"constant\"]\n            * pars[\"exponent\"]\n            ** (temperature - constants.DECAY_REFERENCE_TEMPERATURE),\n            1,\n        )\n        c[pol] -= diff[pol]\n\n        diff[pol] *= c[\"volume\"]\n    return c, diff\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.DecayObj.make_decay","title":"<code>make_decay(vqip)</code>","text":"<p>Make decay, reading tempature and updating pollutant amounts. A wrapper for generic_temperature_decay.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP to decay where pollutants are given as mass totals</p> required <p>Returns:</p> Name Type Description <code>vqip_</code> <code>dict</code> <p>A VQIP with pollutant amounts updated</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def make_decay(self, vqip):\n    \"\"\"Make decay, reading tempature and updating pollutant amounts. A wrapper for\n    generic_temperature_decay.\n\n    Args:\n        vqip (dict): A VQIP to decay where pollutants are given as mass totals\n\n    Returns:\n        vqip_ (dict): A VQIP with pollutant amounts updated\n    \"\"\"\n    # Read temperature data\n    temperature = self.data_input_object.data_input_dict[\n        (\"temperature\", self.data_input_object.t)\n    ]\n    # Make decay\n    vqip_, diff = self.generic_temperature_decay(vqip, self.decays, temperature)\n    # Update total_decayed for mass balance checking\n    self.total_decayed = self.sum_vqip(self.total_decayed, diff)\n    return vqip_\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj","title":"<code>WSIObj</code>","text":"Source code in <code>wsimod/core/core.py</code> <pre><code>class WSIObj:\n    \"\"\"\"\"\"\n\n    def __init__(self):\n        \"\"\"WSIObj is the base object of everything in WSIMOD. It is used to perform VQIP\n        operations and mass balance checking behaviour.\n\n        RSE has suggested that it would make more sense to leave VQIP operations as\n        regular functions in a module or associated them with a VQIP class.\n\n        Predefining empty_vqip_predefined in a class object is sensible though because\n        it is the foundation of many operations, and copying a dict is many times\n        quicker than copying a class.\n\n        For now I will leave WSIObj as the base object, but this may change.\n        \"\"\"\n        # Predefine empty concentrations because copying is quicker than defining\n        self.empty_vqip_predefined = dict.fromkeys(constants.POLLUTANTS + [\"volume\"], 0)\n\n    def empty_vqip(self):\n        \"\"\"Return a copy of the predefined empty vqip. All pollutants and volume\n        initialised in a dict and set to 0.\n\n        Returns:\n            empty_vqip_predefined (dict): Copy of empty_vqip_predefined\n\n        Examples:\n            &gt;&gt;&gt; obj = WSIObj()\n            &gt;&gt;&gt; obj.empty_vqip()\n        \"\"\"\n        return self.empty_vqip_predefined.copy()\n\n    def copy_vqip(self, t):\n        \"\"\"Wrapper to copy VQIP.\n\n        Args:\n            t (dict): A VQIP\n\n        Returns:\n            (dict): A copy of t\n        \"\"\"\n        return t.copy()\n\n    def blend_vqip(self, c1, c2):\n        \"\"\"Blends together two VQIPs that are assumed to have pollutant entries set as\n        pollution concentrations, blending occurs with proportionate mixing.\n\n        NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n        concentration. So you should only blend if you are doing it intentionally and\n        know what you're doing. This won't do anything on VQIPs with 0 volume.\n\n        Args:\n            c1 (dict): A VQIP where pollutant entries are concentrations c2 (dict): A\n            VQIP where pollutant entries are concentrations\n\n        Returns:\n            c (dict): A new VQIP where c1 and c2 have been proportionately blended\n        \"\"\"\n        # Blend two vqips given as concentrations\n        c = self.empty_vqip()\n\n        c[\"volume\"] = c1[\"volume\"] + c2[\"volume\"]\n        if c[\"volume\"] &gt; 0:\n            for pollutant in constants.POLLUTANTS:\n                c[pollutant] = (\n                    c1[pollutant] * c1[\"volume\"] + c2[pollutant] * c2[\"volume\"]\n                ) / c[\"volume\"]\n\n        return c\n\n    def sum_vqip(self, t1, t2):\n        \"\"\"Combines two VQIPs where pollutant entries are assumed to be given as mass.\n        Volume and additive pollutants are summed while non additive pollutants are\n        proportionately blended.\n\n        Args:\n            t1 (dict): A VQIP where pollutant entries are mass totals t2 (dict): A VQIP\n            where pollutant entries are mass totals\n\n        Returns:\n            t (dict): A VQIP that is the sum of t1 and t2 (except for non-additive\n                pollutants)\n\n        Examples:\n            &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n            &gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n            &gt;&gt;&gt; t = sum_vqip(t1, t2)\n            &gt;&gt;&gt; print(t)\n            {'phosphate' : 0.5, 'volume' : 110, 'temperature' : 10.45}\n        \"\"\"\n        # Sum two vqips given as totals\n        t = self.copy_vqip(t1)\n        t[\"volume\"] += t2[\"volume\"]\n        for pollutant in constants.ADDITIVE_POLLUTANTS:\n            t[pollutant] += t2[pollutant]\n\n        if t[\"volume\"] &gt; 0:\n            # Assume proportional blending of non additive pollutants\n            for pollutant in constants.NON_ADDITIVE_POLLUTANTS:\n                t[pollutant] = (\n                    t2[pollutant] * t2[\"volume\"] + t1[pollutant] * t1[\"volume\"]\n                ) / t[\"volume\"]\n\n        return t\n\n    def concentration_to_total(self, c):\n        \"\"\"Convert a VQIP that has pollutant entries as concentrations into mass totals.\n\n        Args:\n            c (dict): A VQIP where pollutant entries are concentrations\n\n        Returns:\n            c (dict): A VQIP where pollutant entries are mass totals\n        \"\"\"\n        c = self.copy_vqip(c)\n        for pollutant in constants.ADDITIVE_POLLUTANTS:\n            # Multiply concentration by volume to get mass for additive pollutants\n            c[pollutant] *= c[\"volume\"]\n        return c\n\n    def total_to_concentration(self, t):\n        \"\"\"Converts a VQIP that has pollutant entries as mass totals into\n        concentrations. Note, that this won't work for VQIPs with 0 volume.\n\n        Args:\n            t (dict): A VQIP where pollutant entries are mass totals\n\n        Returns:\n            c (dict): A VQIP where pollutant entries are concentrations\n        \"\"\"\n        c = self.copy_vqip(t)\n        for pollutant in constants.ADDITIVE_POLLUTANTS:\n            # Divide concentration by volume to get concentration for additive\n            # pollutants\n            c[pollutant] /= c[\"volume\"]\n        return c\n\n    def extract_vqip(self, t1, t2):\n        \"\"\"Extract one VQIP from another where both VQIPs have pollutants as mass\n        totals. Each volume and additive pollutant is directly subtracted.\n\n        Args:\n            t1 (dict): A VQIP where pollutant entries are mass totals to subtract\n                from\n            t2 (dict): A VQIP where pollutant entries are mass totals to subtract\n\n        Returns:\n            t (dict): A copy of t1 where each additive pollutant and volume has had\n                t2 subtracted from it\n\n        Examples:\n            &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n            &gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n\n            &gt;&gt;&gt; t = extract_vqip(t1, t2)\n            &gt;&gt;&gt; print(t)\n            {'phosphate' : 0, 'volume' : 90, 'temperature' : 10}\n        \"\"\"\n        # TODO should probably be called 'subtract_vqip' TODO need to analyse uses of\n        # this to see if it is sensible to do something for non additive\n        t = self.copy_vqip(t1)\n        # Directly subtract t2 from t1 for vol and additive pollutants\n        for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n            t[pol] -= t2[pol]\n\n        return t\n\n    def extract_vqip_c(self, c1, c2):\n        \"\"\"Extract one VQIP from another where both VQIPs have pollutants as\n        concentrations. Operation performed for volume and additive pollutants.\n\n        NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n        concentration. So you should only work with concentrations if you are doing it\n        intentionally and know what you're doing.\n\n        Args:\n            c1 (dict): A VQIP where pollutant entries are concentrations to subtract\n                from\n            c2 (dict): A VQIP where pollutant entries are concentrations to subtract\n\n        Returns:\n            c (dict): A copy of c1 where each additive pollutant and volume has had\n                c2 proportionately extracted from it\n        \"\"\"\n        c = self.copy_vqip(c1)\n\n        c1 = self.concentration_to_total(c1)\n        c2 = self.concentration_to_total(c2)\n        c[\"volume\"] = c1[\"volume\"] - c2[\"volume\"]\n        if c[\"volume\"] &gt; 0:\n            for pollutant in constants.ADDITIVE_POLLUTANTS:\n                # Subtract c2 from c1 for vol and additive pollutants\n                c[pollutant] = (c1[pollutant] - c2[pollutant]) / c[\"volume\"]\n\n        return c\n\n    def v_distill_vqip(self, t, v):\n        \"\"\"Directly remove a volume from a VQIP.\n\n        Args:\n            t (dict): A VQIP where pollutant entries are mass totals to remove\n                volume from\n            v (float): Volume to remove\n\n        Returns:\n            t (dict): Updated VQIP\n        \"\"\"\n        # Distill v from t\n        t = self.copy_vqip(t)\n        t[\"volume\"] -= v\n        return t\n\n    def v_distill_vqip_c(self, c, v):\n        \"\"\"Directly remove a volume from a VQIP, where pollutant entries are\n        concentrations.\n\n        NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n        concentration. So you should only work with concentrations if you are doing it\n        intentionally and know what you're doing.\n\n        Args:\n            c (dict): A VQIP where pollutant entries are concentrations to remove\n                volume from\n            v (float): Volume to remove\n\n        Returns:\n            c (dict): Updated VQIP\n        \"\"\"\n        # Distill v from c\n        c = self.copy_vqip(c)\n        d = self.empty_vqip()\n        d[\"volume\"] = -v\n        c_ = self.blend_vqip(c, d)\n        # Directly copy non additive pollutants\n        for pollutant in constants.NON_ADDITIVE_POLLUTANTS:\n            c_[pollutant] = c[pollutant]\n        return c_\n\n    def v_change_vqip(self, t, v):\n        \"\"\"Change the volume of a VQIP, where pollutants are mass totals, and update\n        pollutant values in proportion to the change in volume.\n\n        Args:\n            t (dict): A VQIP where pollutant entries are mass totals to get\n                pollutant concentrations from\n            v (float): Volume from t to get proportionate pollutant values in\n\n        Returns:\n            (dict): A VQIP with v volume and pollutions in proportion to t\n\n        Examples:\n            You want to extract 10m3 from 100m3 of water (store), to do this you need to\n            understand how much phosphate to extract in addition to volume.\n\n            &gt;&gt;&gt; store = {'volume' : 100, 'phosphate' : 0.25}\n            &gt;&gt;&gt; to_extract = v_change_vqip(store, 10)\n\n            &gt;&gt;&gt; print(to_extract)\n            {'volume': 10, 'phosphate': 0.025}\n        \"\"\"\n        t = self.copy_vqip(t)\n        if t[\"volume\"] &gt; 0:\n            # change all values of t by volume v in proportion to volume of t\n            ratio = v / t[\"volume\"]\n            t[\"volume\"] *= ratio\n            for pol in constants.ADDITIVE_POLLUTANTS:\n                t[pol] *= ratio\n\n        else:\n            # Assign volume directly\n            t[\"volume\"] = v\n        return t\n\n    def v_change_vqip_c(self, c, v):\n        \"\"\"Change the volume of a VQIP, where pollutants are concentrations.\n\n        NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n        concentration. So you should only work with concentrations if you are doing it\n        intentionally and know what you're doing.\n\n        Args:\n            c (dict): A VQIP where pollutant entries are concentrations v (float):\n            Volume to change c's volume to\n\n        Returns:\n            c (dict): A new VQIP with volume udpated\n        \"\"\"\n        # Change volume of vqip\n        c = self.copy_vqip(c)\n        c[\"volume\"] = v\n        return c\n\n    def ds_vqip(self, t, t_):\n        \"\"\"Get difference between each additive pollutant and volume for VQIPs where\n        pollutants are given as mass totals.\n\n        Args:\n            t (dict): A VQIP where pollutant entries are mass totals to subtract\n                values from\n            t_ (_type_): A VQIP where pollutant entries are mass totals to subtract\n\n        Returns:\n            ds (dict): Difference between t and t_ in mass totals\n\n        Examples:\n            &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n            &gt;&gt;&gt; t2 = {'phosphate' : 0.2, 'volume' : 90, 'temperature' : 9}\n\n            &gt;&gt;&gt; t = ds_vqip(t1, t2)\n            &gt;&gt;&gt; print(t)\n            {'phosphate' : 0.05, 'volume' : 10, 'temperature' : 0}\n        \"\"\"\n        ds = self.empty_vqip()\n        for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n            ds[pol] = t[pol] - t_[pol]\n        return ds\n\n    def ds_vqip_c(self, c, c_):\n        \"\"\"Get difference between each additive pollutant and volume for VQIPs where\n        pollutants are given as concentrations but difference is given as mass totals.\n\n        NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n        concentration. So you should only work with concentrations if you are doing it\n        intentionally and know what you're doing.\n\n        Args:\n            c (dict): A VQIP where pollutant entries are concentrations to subtract\n                values from\n            c_ (_type_): A VQIP where pollutant entries are concentrations to\n                subtract\n\n        Returns:\n            ds (dict): Difference between c and c_ in mass totals\n        \"\"\"\n        ds = self.empty_vqip()\n        ds[\"volume\"] = c[\"volume\"] - c_[\"volume\"]\n        for pol in constants.ADDITIVE_POLLUTANTS:\n            ds[pol] = c[\"volume\"] * c[pol] - c_[\"volume\"] * c_[pol]\n        # TODO what about non-additive ...\n        return ds\n\n    def compare_vqip(self, t1, t2):\n        \"\"\"Compare two VQIPs and check if the difference between each key is less ' than\n        constants.FLOAT_ACCURACY.\n\n        Args:\n            t1 (dict): A VQIP t2 (dict): A VQIP\n\n        Returns:\n            bool: True if the difference is less for each key, False otherwise\n        \"\"\"\n        reply = True\n        for v in t1.keys():\n            if abs(t1[v] - t2[v]) &gt; constants.FLOAT_ACCURACY:\n                reply = False\n        return reply\n\n    def mass_balance(self):\n        \"\"\"Call all mass balance functions and compare to see if discrepancy (i.e., if\n        in_ != (out_ + ds_) for volume or for any additive pollutant).\n\n        Comparison is performed in the magnitude of the largest value of in_, ds_ or\n        out_. And so judgement should be exercised as to whether a mass balance has\n        actually occurred\n\n        Returns:\n            in_ (dict): A VQIP of the total from mass_balance_in functions ds_ (dict): A\n            VQIP of the total from mass_balance_ds functions out_ (dict): A VQIP of the\n            total from mass_balance_out functions\n\n        Raises:\n            Message if mass balance does not close to constants.FLOAT_ACCURACY\n        \"\"\"\n        # Iterate over mass_balance_in functions, summing values in in_\n        in_ = self.empty_vqip()\n        for f in self.mass_balance_in:\n            in_ = self.sum_vqip(in_, f())\n\n        # Iterate over mass_balance_out functions, summing values in out_\n        out_ = self.empty_vqip()\n        for f in self.mass_balance_out:\n            out_ = self.sum_vqip(out_, f())\n\n        # Iterate over mass_balance_ds functions, summing values in ds_\n        ds_ = self.empty_vqip()\n        for f in self.mass_balance_ds:\n            ds_f = f()\n            for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                ds_[v] += ds_f[v]\n\n        # Iterate over volume and additive pollutants to perform comparison\n        for v in [\"volume\"] + constants.ADDITIVE_POLLUTANTS:\n            # Find the largest value of in_, out_, ds_\n            largest = max(in_[v], out_[v], ds_[v])\n\n            if largest &gt; constants.FLOAT_ACCURACY:\n                # Convert perform comparison in a magnitude to match the largest value\n                magnitude = 10 ** int(log10(largest))\n                in_10 = in_[v] / magnitude\n                out_10 = out_[v] / magnitude\n                ds_10 = ds_[v] / magnitude\n            else:\n                in_10 = in_[v]\n                ds_10 = ds_[v]\n                out_10 = out_[v]\n\n            if abs(in_10 - ds_10 - out_10) &gt; constants.FLOAT_ACCURACY:\n                # Print mass balance error Print actual difference rather than magnitude\n                # comparison to enable user judgement\n\n                print(\n                    \"mass balance error for {0} of {1} in {2}\".format(\n                        v, in_[v] - ds_[v] - out_[v], self.name\n                    )\n                )\n\n        return in_, ds_, out_\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.__init__","title":"<code>__init__()</code>","text":"<p>WSIObj is the base object of everything in WSIMOD. It is used to perform VQIP operations and mass balance checking behaviour.</p> <p>RSE has suggested that it would make more sense to leave VQIP operations as regular functions in a module or associated them with a VQIP class.</p> <p>Predefining empty_vqip_predefined in a class object is sensible though because it is the foundation of many operations, and copying a dict is many times quicker than copying a class.</p> <p>For now I will leave WSIObj as the base object, but this may change.</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def __init__(self):\n    \"\"\"WSIObj is the base object of everything in WSIMOD. It is used to perform VQIP\n    operations and mass balance checking behaviour.\n\n    RSE has suggested that it would make more sense to leave VQIP operations as\n    regular functions in a module or associated them with a VQIP class.\n\n    Predefining empty_vqip_predefined in a class object is sensible though because\n    it is the foundation of many operations, and copying a dict is many times\n    quicker than copying a class.\n\n    For now I will leave WSIObj as the base object, but this may change.\n    \"\"\"\n    # Predefine empty concentrations because copying is quicker than defining\n    self.empty_vqip_predefined = dict.fromkeys(constants.POLLUTANTS + [\"volume\"], 0)\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.blend_vqip","title":"<code>blend_vqip(c1, c2)</code>","text":"<p>Blends together two VQIPs that are assumed to have pollutant entries set as pollution concentrations, blending occurs with proportionate mixing.</p> <p>NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a concentration. So you should only blend if you are doing it intentionally and know what you're doing. This won't do anything on VQIPs with 0 volume.</p> <p>Parameters:</p> Name Type Description Default <code>c1</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations c2 (dict): A</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>A new VQIP where c1 and c2 have been proportionately blended</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def blend_vqip(self, c1, c2):\n    \"\"\"Blends together two VQIPs that are assumed to have pollutant entries set as\n    pollution concentrations, blending occurs with proportionate mixing.\n\n    NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n    concentration. So you should only blend if you are doing it intentionally and\n    know what you're doing. This won't do anything on VQIPs with 0 volume.\n\n    Args:\n        c1 (dict): A VQIP where pollutant entries are concentrations c2 (dict): A\n        VQIP where pollutant entries are concentrations\n\n    Returns:\n        c (dict): A new VQIP where c1 and c2 have been proportionately blended\n    \"\"\"\n    # Blend two vqips given as concentrations\n    c = self.empty_vqip()\n\n    c[\"volume\"] = c1[\"volume\"] + c2[\"volume\"]\n    if c[\"volume\"] &gt; 0:\n        for pollutant in constants.POLLUTANTS:\n            c[pollutant] = (\n                c1[pollutant] * c1[\"volume\"] + c2[pollutant] * c2[\"volume\"]\n            ) / c[\"volume\"]\n\n    return c\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.compare_vqip","title":"<code>compare_vqip(t1, t2)</code>","text":"<p>Compare two VQIPs and check if the difference between each key is less ' than constants.FLOAT_ACCURACY.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>dict</code> <p>A VQIP t2 (dict): A VQIP</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if the difference is less for each key, False otherwise</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def compare_vqip(self, t1, t2):\n    \"\"\"Compare two VQIPs and check if the difference between each key is less ' than\n    constants.FLOAT_ACCURACY.\n\n    Args:\n        t1 (dict): A VQIP t2 (dict): A VQIP\n\n    Returns:\n        bool: True if the difference is less for each key, False otherwise\n    \"\"\"\n    reply = True\n    for v in t1.keys():\n        if abs(t1[v] - t2[v]) &gt; constants.FLOAT_ACCURACY:\n            reply = False\n    return reply\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.concentration_to_total","title":"<code>concentration_to_total(c)</code>","text":"<p>Convert a VQIP that has pollutant entries as concentrations into mass totals.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def concentration_to_total(self, c):\n    \"\"\"Convert a VQIP that has pollutant entries as concentrations into mass totals.\n\n    Args:\n        c (dict): A VQIP where pollutant entries are concentrations\n\n    Returns:\n        c (dict): A VQIP where pollutant entries are mass totals\n    \"\"\"\n    c = self.copy_vqip(c)\n    for pollutant in constants.ADDITIVE_POLLUTANTS:\n        # Multiply concentration by volume to get mass for additive pollutants\n        c[pollutant] *= c[\"volume\"]\n    return c\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.copy_vqip","title":"<code>copy_vqip(t)</code>","text":"<p>Wrapper to copy VQIP.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A copy of t</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def copy_vqip(self, t):\n    \"\"\"Wrapper to copy VQIP.\n\n    Args:\n        t (dict): A VQIP\n\n    Returns:\n        (dict): A copy of t\n    \"\"\"\n    return t.copy()\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.ds_vqip","title":"<code>ds_vqip(t, t_)</code>","text":"<p>Get difference between each additive pollutant and volume for VQIPs where pollutants are given as mass totals.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals to subtract values from</p> required <code>t_</code> <code>_type_</code> <p>A VQIP where pollutant entries are mass totals to subtract</p> required <p>Returns:</p> Name Type Description <code>ds</code> <code>dict</code> <p>Difference between t and t_ in mass totals</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n&gt;&gt;&gt; t2 = {'phosphate' : 0.2, 'volume' : 90, 'temperature' : 9}\n</code></pre> <pre><code>&gt;&gt;&gt; t = ds_vqip(t1, t2)\n&gt;&gt;&gt; print(t)\n{'phosphate' : 0.05, 'volume' : 10, 'temperature' : 0}\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def ds_vqip(self, t, t_):\n    \"\"\"Get difference between each additive pollutant and volume for VQIPs where\n    pollutants are given as mass totals.\n\n    Args:\n        t (dict): A VQIP where pollutant entries are mass totals to subtract\n            values from\n        t_ (_type_): A VQIP where pollutant entries are mass totals to subtract\n\n    Returns:\n        ds (dict): Difference between t and t_ in mass totals\n\n    Examples:\n        &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n        &gt;&gt;&gt; t2 = {'phosphate' : 0.2, 'volume' : 90, 'temperature' : 9}\n\n        &gt;&gt;&gt; t = ds_vqip(t1, t2)\n        &gt;&gt;&gt; print(t)\n        {'phosphate' : 0.05, 'volume' : 10, 'temperature' : 0}\n    \"\"\"\n    ds = self.empty_vqip()\n    for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n        ds[pol] = t[pol] - t_[pol]\n    return ds\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.ds_vqip_c","title":"<code>ds_vqip_c(c, c_)</code>","text":"<p>Get difference between each additive pollutant and volume for VQIPs where pollutants are given as concentrations but difference is given as mass totals.</p> <p>NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a concentration. So you should only work with concentrations if you are doing it intentionally and know what you're doing.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations to subtract values from</p> required <code>c_</code> <code>_type_</code> <p>A VQIP where pollutant entries are concentrations to subtract</p> required <p>Returns:</p> Name Type Description <code>ds</code> <code>dict</code> <p>Difference between c and c_ in mass totals</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def ds_vqip_c(self, c, c_):\n    \"\"\"Get difference between each additive pollutant and volume for VQIPs where\n    pollutants are given as concentrations but difference is given as mass totals.\n\n    NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n    concentration. So you should only work with concentrations if you are doing it\n    intentionally and know what you're doing.\n\n    Args:\n        c (dict): A VQIP where pollutant entries are concentrations to subtract\n            values from\n        c_ (_type_): A VQIP where pollutant entries are concentrations to\n            subtract\n\n    Returns:\n        ds (dict): Difference between c and c_ in mass totals\n    \"\"\"\n    ds = self.empty_vqip()\n    ds[\"volume\"] = c[\"volume\"] - c_[\"volume\"]\n    for pol in constants.ADDITIVE_POLLUTANTS:\n        ds[pol] = c[\"volume\"] * c[pol] - c_[\"volume\"] * c_[pol]\n    # TODO what about non-additive ...\n    return ds\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.empty_vqip","title":"<code>empty_vqip()</code>","text":"<p>Return a copy of the predefined empty vqip. All pollutants and volume initialised in a dict and set to 0.</p> <p>Returns:</p> Name Type Description <code>empty_vqip_predefined</code> <code>dict</code> <p>Copy of empty_vqip_predefined</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; obj = WSIObj()\n&gt;&gt;&gt; obj.empty_vqip()\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def empty_vqip(self):\n    \"\"\"Return a copy of the predefined empty vqip. All pollutants and volume\n    initialised in a dict and set to 0.\n\n    Returns:\n        empty_vqip_predefined (dict): Copy of empty_vqip_predefined\n\n    Examples:\n        &gt;&gt;&gt; obj = WSIObj()\n        &gt;&gt;&gt; obj.empty_vqip()\n    \"\"\"\n    return self.empty_vqip_predefined.copy()\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.extract_vqip","title":"<code>extract_vqip(t1, t2)</code>","text":"<p>Extract one VQIP from another where both VQIPs have pollutants as mass totals. Each volume and additive pollutant is directly subtracted.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals to subtract from</p> required <code>t2</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals to subtract</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>dict</code> <p>A copy of t1 where each additive pollutant and volume has had t2 subtracted from it</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n&gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n</code></pre> <pre><code>&gt;&gt;&gt; t = extract_vqip(t1, t2)\n&gt;&gt;&gt; print(t)\n{'phosphate' : 0, 'volume' : 90, 'temperature' : 10}\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def extract_vqip(self, t1, t2):\n    \"\"\"Extract one VQIP from another where both VQIPs have pollutants as mass\n    totals. Each volume and additive pollutant is directly subtracted.\n\n    Args:\n        t1 (dict): A VQIP where pollutant entries are mass totals to subtract\n            from\n        t2 (dict): A VQIP where pollutant entries are mass totals to subtract\n\n    Returns:\n        t (dict): A copy of t1 where each additive pollutant and volume has had\n            t2 subtracted from it\n\n    Examples:\n        &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n        &gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n\n        &gt;&gt;&gt; t = extract_vqip(t1, t2)\n        &gt;&gt;&gt; print(t)\n        {'phosphate' : 0, 'volume' : 90, 'temperature' : 10}\n    \"\"\"\n    # TODO should probably be called 'subtract_vqip' TODO need to analyse uses of\n    # this to see if it is sensible to do something for non additive\n    t = self.copy_vqip(t1)\n    # Directly subtract t2 from t1 for vol and additive pollutants\n    for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n        t[pol] -= t2[pol]\n\n    return t\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.extract_vqip_c","title":"<code>extract_vqip_c(c1, c2)</code>","text":"<p>Extract one VQIP from another where both VQIPs have pollutants as concentrations. Operation performed for volume and additive pollutants.</p> <p>NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a concentration. So you should only work with concentrations if you are doing it intentionally and know what you're doing.</p> <p>Parameters:</p> Name Type Description Default <code>c1</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations to subtract from</p> required <code>c2</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations to subtract</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>A copy of c1 where each additive pollutant and volume has had c2 proportionately extracted from it</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def extract_vqip_c(self, c1, c2):\n    \"\"\"Extract one VQIP from another where both VQIPs have pollutants as\n    concentrations. Operation performed for volume and additive pollutants.\n\n    NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n    concentration. So you should only work with concentrations if you are doing it\n    intentionally and know what you're doing.\n\n    Args:\n        c1 (dict): A VQIP where pollutant entries are concentrations to subtract\n            from\n        c2 (dict): A VQIP where pollutant entries are concentrations to subtract\n\n    Returns:\n        c (dict): A copy of c1 where each additive pollutant and volume has had\n            c2 proportionately extracted from it\n    \"\"\"\n    c = self.copy_vqip(c1)\n\n    c1 = self.concentration_to_total(c1)\n    c2 = self.concentration_to_total(c2)\n    c[\"volume\"] = c1[\"volume\"] - c2[\"volume\"]\n    if c[\"volume\"] &gt; 0:\n        for pollutant in constants.ADDITIVE_POLLUTANTS:\n            # Subtract c2 from c1 for vol and additive pollutants\n            c[pollutant] = (c1[pollutant] - c2[pollutant]) / c[\"volume\"]\n\n    return c\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.mass_balance","title":"<code>mass_balance()</code>","text":"<p>Call all mass balance functions and compare to see if discrepancy (i.e., if in_ != (out_ + ds_) for volume or for any additive pollutant).</p> <p>Comparison is performed in the magnitude of the largest value of in_, ds_ or out_. And so judgement should be exercised as to whether a mass balance has actually occurred</p> <p>Returns:</p> Name Type Description <code>in_</code> <code>dict): A VQIP of the total from mass_balance_in functions ds_ (dict</code> <p>A</p> <p>VQIP of the total from mass_balance_ds functions out_ (dict): A VQIP of the</p> <p>total from mass_balance_out functions</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def mass_balance(self):\n    \"\"\"Call all mass balance functions and compare to see if discrepancy (i.e., if\n    in_ != (out_ + ds_) for volume or for any additive pollutant).\n\n    Comparison is performed in the magnitude of the largest value of in_, ds_ or\n    out_. And so judgement should be exercised as to whether a mass balance has\n    actually occurred\n\n    Returns:\n        in_ (dict): A VQIP of the total from mass_balance_in functions ds_ (dict): A\n        VQIP of the total from mass_balance_ds functions out_ (dict): A VQIP of the\n        total from mass_balance_out functions\n\n    Raises:\n        Message if mass balance does not close to constants.FLOAT_ACCURACY\n    \"\"\"\n    # Iterate over mass_balance_in functions, summing values in in_\n    in_ = self.empty_vqip()\n    for f in self.mass_balance_in:\n        in_ = self.sum_vqip(in_, f())\n\n    # Iterate over mass_balance_out functions, summing values in out_\n    out_ = self.empty_vqip()\n    for f in self.mass_balance_out:\n        out_ = self.sum_vqip(out_, f())\n\n    # Iterate over mass_balance_ds functions, summing values in ds_\n    ds_ = self.empty_vqip()\n    for f in self.mass_balance_ds:\n        ds_f = f()\n        for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n            ds_[v] += ds_f[v]\n\n    # Iterate over volume and additive pollutants to perform comparison\n    for v in [\"volume\"] + constants.ADDITIVE_POLLUTANTS:\n        # Find the largest value of in_, out_, ds_\n        largest = max(in_[v], out_[v], ds_[v])\n\n        if largest &gt; constants.FLOAT_ACCURACY:\n            # Convert perform comparison in a magnitude to match the largest value\n            magnitude = 10 ** int(log10(largest))\n            in_10 = in_[v] / magnitude\n            out_10 = out_[v] / magnitude\n            ds_10 = ds_[v] / magnitude\n        else:\n            in_10 = in_[v]\n            ds_10 = ds_[v]\n            out_10 = out_[v]\n\n        if abs(in_10 - ds_10 - out_10) &gt; constants.FLOAT_ACCURACY:\n            # Print mass balance error Print actual difference rather than magnitude\n            # comparison to enable user judgement\n\n            print(\n                \"mass balance error for {0} of {1} in {2}\".format(\n                    v, in_[v] - ds_[v] - out_[v], self.name\n                )\n            )\n\n    return in_, ds_, out_\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.sum_vqip","title":"<code>sum_vqip(t1, t2)</code>","text":"<p>Combines two VQIPs where pollutant entries are assumed to be given as mass. Volume and additive pollutants are summed while non additive pollutants are proportionately blended.</p> <p>Parameters:</p> Name Type Description Default <code>t1</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals t2 (dict): A VQIP</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>dict</code> <p>A VQIP that is the sum of t1 and t2 (except for non-additive pollutants)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n&gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n&gt;&gt;&gt; t = sum_vqip(t1, t2)\n&gt;&gt;&gt; print(t)\n{'phosphate' : 0.5, 'volume' : 110, 'temperature' : 10.45}\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def sum_vqip(self, t1, t2):\n    \"\"\"Combines two VQIPs where pollutant entries are assumed to be given as mass.\n    Volume and additive pollutants are summed while non additive pollutants are\n    proportionately blended.\n\n    Args:\n        t1 (dict): A VQIP where pollutant entries are mass totals t2 (dict): A VQIP\n        where pollutant entries are mass totals\n\n    Returns:\n        t (dict): A VQIP that is the sum of t1 and t2 (except for non-additive\n            pollutants)\n\n    Examples:\n        &gt;&gt;&gt; t1 = {'phosphate' : 0.25, 'volume' : 100, 'temperature' : 10}\n        &gt;&gt;&gt; t2 = {'phosphate' : 0.25, 'volume' : 10, 'temperature' : 15}\n        &gt;&gt;&gt; t = sum_vqip(t1, t2)\n        &gt;&gt;&gt; print(t)\n        {'phosphate' : 0.5, 'volume' : 110, 'temperature' : 10.45}\n    \"\"\"\n    # Sum two vqips given as totals\n    t = self.copy_vqip(t1)\n    t[\"volume\"] += t2[\"volume\"]\n    for pollutant in constants.ADDITIVE_POLLUTANTS:\n        t[pollutant] += t2[pollutant]\n\n    if t[\"volume\"] &gt; 0:\n        # Assume proportional blending of non additive pollutants\n        for pollutant in constants.NON_ADDITIVE_POLLUTANTS:\n            t[pollutant] = (\n                t2[pollutant] * t2[\"volume\"] + t1[pollutant] * t1[\"volume\"]\n            ) / t[\"volume\"]\n\n    return t\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.total_to_concentration","title":"<code>total_to_concentration(t)</code>","text":"<p>Converts a VQIP that has pollutant entries as mass totals into concentrations. Note, that this won't work for VQIPs with 0 volume.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def total_to_concentration(self, t):\n    \"\"\"Converts a VQIP that has pollutant entries as mass totals into\n    concentrations. Note, that this won't work for VQIPs with 0 volume.\n\n    Args:\n        t (dict): A VQIP where pollutant entries are mass totals\n\n    Returns:\n        c (dict): A VQIP where pollutant entries are concentrations\n    \"\"\"\n    c = self.copy_vqip(t)\n    for pollutant in constants.ADDITIVE_POLLUTANTS:\n        # Divide concentration by volume to get concentration for additive\n        # pollutants\n        c[pollutant] /= c[\"volume\"]\n    return c\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.v_change_vqip","title":"<code>v_change_vqip(t, v)</code>","text":"<p>Change the volume of a VQIP, where pollutants are mass totals, and update pollutant values in proportion to the change in volume.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals to get pollutant concentrations from</p> required <code>v</code> <code>float</code> <p>Volume from t to get proportionate pollutant values in</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP with v volume and pollutions in proportion to t</p> <p>Examples:</p> <p>You want to extract 10m3 from 100m3 of water (store), to do this you need to understand how much phosphate to extract in addition to volume.</p> <pre><code>&gt;&gt;&gt; store = {'volume' : 100, 'phosphate' : 0.25}\n&gt;&gt;&gt; to_extract = v_change_vqip(store, 10)\n</code></pre> <pre><code>&gt;&gt;&gt; print(to_extract)\n{'volume': 10, 'phosphate': 0.025}\n</code></pre> Source code in <code>wsimod/core/core.py</code> <pre><code>def v_change_vqip(self, t, v):\n    \"\"\"Change the volume of a VQIP, where pollutants are mass totals, and update\n    pollutant values in proportion to the change in volume.\n\n    Args:\n        t (dict): A VQIP where pollutant entries are mass totals to get\n            pollutant concentrations from\n        v (float): Volume from t to get proportionate pollutant values in\n\n    Returns:\n        (dict): A VQIP with v volume and pollutions in proportion to t\n\n    Examples:\n        You want to extract 10m3 from 100m3 of water (store), to do this you need to\n        understand how much phosphate to extract in addition to volume.\n\n        &gt;&gt;&gt; store = {'volume' : 100, 'phosphate' : 0.25}\n        &gt;&gt;&gt; to_extract = v_change_vqip(store, 10)\n\n        &gt;&gt;&gt; print(to_extract)\n        {'volume': 10, 'phosphate': 0.025}\n    \"\"\"\n    t = self.copy_vqip(t)\n    if t[\"volume\"] &gt; 0:\n        # change all values of t by volume v in proportion to volume of t\n        ratio = v / t[\"volume\"]\n        t[\"volume\"] *= ratio\n        for pol in constants.ADDITIVE_POLLUTANTS:\n            t[pol] *= ratio\n\n    else:\n        # Assign volume directly\n        t[\"volume\"] = v\n    return t\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.v_change_vqip_c","title":"<code>v_change_vqip_c(c, v)</code>","text":"<p>Change the volume of a VQIP, where pollutants are concentrations.</p> <p>NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a concentration. So you should only work with concentrations if you are doing it intentionally and know what you're doing.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations v (float):</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>A new VQIP with volume udpated</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def v_change_vqip_c(self, c, v):\n    \"\"\"Change the volume of a VQIP, where pollutants are concentrations.\n\n    NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n    concentration. So you should only work with concentrations if you are doing it\n    intentionally and know what you're doing.\n\n    Args:\n        c (dict): A VQIP where pollutant entries are concentrations v (float):\n        Volume to change c's volume to\n\n    Returns:\n        c (dict): A new VQIP with volume udpated\n    \"\"\"\n    # Change volume of vqip\n    c = self.copy_vqip(c)\n    c[\"volume\"] = v\n    return c\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.v_distill_vqip","title":"<code>v_distill_vqip(t, v)</code>","text":"<p>Directly remove a volume from a VQIP.</p> <p>Parameters:</p> Name Type Description Default <code>t</code> <code>dict</code> <p>A VQIP where pollutant entries are mass totals to remove volume from</p> required <code>v</code> <code>float</code> <p>Volume to remove</p> required <p>Returns:</p> Name Type Description <code>t</code> <code>dict</code> <p>Updated VQIP</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def v_distill_vqip(self, t, v):\n    \"\"\"Directly remove a volume from a VQIP.\n\n    Args:\n        t (dict): A VQIP where pollutant entries are mass totals to remove\n            volume from\n        v (float): Volume to remove\n\n    Returns:\n        t (dict): Updated VQIP\n    \"\"\"\n    # Distill v from t\n    t = self.copy_vqip(t)\n    t[\"volume\"] -= v\n    return t\n</code></pre>"},{"location":"reference-core/#wsimod.core.core.WSIObj.v_distill_vqip_c","title":"<code>v_distill_vqip_c(c, v)</code>","text":"<p>Directly remove a volume from a VQIP, where pollutant entries are concentrations.</p> <p>NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a concentration. So you should only work with concentrations if you are doing it intentionally and know what you're doing.</p> <p>Parameters:</p> Name Type Description Default <code>c</code> <code>dict</code> <p>A VQIP where pollutant entries are concentrations to remove volume from</p> required <code>v</code> <code>float</code> <p>Volume to remove</p> required <p>Returns:</p> Name Type Description <code>c</code> <code>dict</code> <p>Updated VQIP</p> Source code in <code>wsimod/core/core.py</code> <pre><code>def v_distill_vqip_c(self, c, v):\n    \"\"\"Directly remove a volume from a VQIP, where pollutant entries are\n    concentrations.\n\n    NOTE: VQIPs in WSIMOD in general store pollution as a total rather than a\n    concentration. So you should only work with concentrations if you are doing it\n    intentionally and know what you're doing.\n\n    Args:\n        c (dict): A VQIP where pollutant entries are concentrations to remove\n            volume from\n        v (float): Volume to remove\n\n    Returns:\n        c (dict): Updated VQIP\n    \"\"\"\n    # Distill v from c\n    c = self.copy_vqip(c)\n    d = self.empty_vqip()\n    d[\"volume\"] = -v\n    c_ = self.blend_vqip(c, d)\n    # Directly copy non additive pollutants\n    for pollutant in constants.NON_ADDITIVE_POLLUTANTS:\n        c_[pollutant] = c[pollutant]\n    return c_\n</code></pre>"},{"location":"reference-core/#wsimod.core.constants.set_default_pollutants","title":"<code>set_default_pollutants()</code>","text":"Source code in <code>wsimod/core/constants.py</code> <pre><code>def set_default_pollutants():\n    \"\"\"\"\"\"\n    constants.POLLUTANTS = [\n        \"do\",\n        \"org-phosphorus\",\n        \"phosphate\",\n        \"ammonia\",\n        \"solids\",\n        \"bod\",\n        \"cod\",\n        \"ph\",\n        \"temperature\",\n        \"nitrate\",\n        \"nitrite\",\n        \"org-nitrogen\",\n    ]\n    constants.NON_ADDITIVE_POLLUTANTS = [\n        \"do\",\n        \"temperature\",\n        \"ph\",\n    ]  # e.g. pollutants whose concentration should not increase if volume is distilled\n    # out\n    constants.ADDITIVE_POLLUTANTS = [\n        \"org-phosphorus\",\n        \"phosphate\",\n        \"ammonia\",\n        \"solids\",\n        \"bod\",\n        \"cod\",\n        \"nitrate\",\n        \"nitrite\",\n        \"org-nitrogen\",\n    ]\n</code></pre>"},{"location":"reference-core/#wsimod.core.constants.set_simple_pollutants","title":"<code>set_simple_pollutants()</code>","text":"Source code in <code>wsimod/core/constants.py</code> <pre><code>def set_simple_pollutants():\n    \"\"\"\"\"\"\n    constants.POLLUTANTS = [\"phosphate\", \"temperature\"]\n    constants.ADDITIVE_POLLUTANTS = [\"phosphate\"]\n    constants.NON_ADDITIVE_POLLUTANTS = [\"temperature\"]\n</code></pre>"},{"location":"reference-extensions/","title":"API Reference - Extensions","text":"<p>This section provides more details on the extension files and how to define the patches in there.</p> <p>This module contains the utilities to extend WSMOD with new features.</p> <p>The <code>register_node_patch</code> decorator is used to register a function that will be used instead of a method or attribute of a node. The <code>apply_patches</code> function applies all registered patches to a model.</p> <p>Example of patching a method:</p> <p><code>empty_distributed</code> will be called instead of <code>pull_distributed</code> of \"my_node\":</p> <pre><code>&gt;&gt;&gt; from wsimod.extensions import register_node_patch, apply_patches\n&gt;&gt;&gt; @register_node_patch(\"my_node\", \"pull_distributed\")\n&gt;&gt;&gt; def empty_distributed(self, vqip):\n&gt;&gt;&gt;      return {}\n</code></pre> <p>Attributes, methods of the node, and sub-attributes can be patched. Also, an item of a list or a dictionary can be patched if the item argument is provided.</p> <p>Example of patching an attribute:</p> <p><code>10</code> will be assigned to <code>t</code>:</p> <pre><code>&gt;&gt;&gt; @register_node_patch(\"my_node\", \"t\", is_attr=True)\n&gt;&gt;&gt; def patch_t(node):\n&gt;&gt;&gt;     return 10\n</code></pre> <p>Example of patching an attribute item:</p> <p><code>patch_default_pull_set_handler</code> will be assigned to <code>pull_set_handler[\"default\"]</code>:</p> <pre><code>&gt;&gt;&gt; @register_node_patch(\"my_node\", \"pull_set_handler\", item=\"default\")\n&gt;&gt;&gt; def patch_default_pull_set_handler(self, vqip):\n&gt;&gt;&gt;     return {}\n</code></pre> <p>If patching a method of an attribute, the <code>is_attr</code> argument should be set to <code>True</code> and the target should include the attribute name and the method name, all separated by periods, eg. <code>attribute_name.method_name</code>.</p> <p>It should be noted that the patched function should have the same signature as the original method or attribute, and the return type should be the same as well, otherwise there will be a runtime error. In particular, the first argument of the patched function should be the node object itself, which will typically be named <code>self</code>.</p> <p>The overridden method or attribute can be accessed within the patched function using the <code>_patched_{method_name}</code> attribute of the object, eg. <code>self._patched_pull_distributed</code>. The exception to this is when patching an item, in which case the original item is no available to be used within the overriding function.</p> <p>Finally, the <code>apply_patches</code> is called within the <code>Model.load</code> method and will apply all patches in the order they were registered. This means that users need to be careful with the order of the patches in their extensions files, as they may have interdependencies.</p> <p>TODO: Update documentation on extensions files.</p>"},{"location":"reference-extensions/#wsimod.extensions.apply_patches","title":"<code>apply_patches(model)</code>","text":"<p>Apply all registered patches to the model.</p> <p>TODO: Validate signature of the patched methods and type of patched attributes.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model to apply the patches to.</p> required Source code in <code>wsimod/extensions.py</code> <pre><code>def apply_patches(model: Model) -&gt; None:\n    \"\"\"Apply all registered patches to the model.\n\n    TODO: Validate signature of the patched methods and type of patched attributes.\n\n    Args:\n        model (Model): The model to apply the patches to.\n    \"\"\"\n    for (node_name, target, item, is_attr), func in extensions_registry.items():\n        starget = target.split(\".\")\n        method = starget.pop()\n\n        # Get the member to patch\n        node = obj = model.nodes[node_name]\n        for attr in starget:\n            obj = getattr(obj, attr)\n\n        # Apply the patch\n        if item is not None:\n            obj = getattr(obj, method)\n            obj[item] = func(node) if is_attr else func.__get__(node, node.__class__)\n        else:\n            setattr(obj, f\"_patched_{method}\", getattr(obj, method))\n            setattr(\n                obj, method, func(node) if is_attr else func.__get__(obj, obj.__class__)\n            )\n</code></pre>"},{"location":"reference-extensions/#wsimod.extensions.register_node_patch","title":"<code>register_node_patch(node_name, target, item=None, is_attr=False)</code>","text":"<p>Register a function to patch a node method or any of its attributes.</p> <p>Parameters:</p> Name Type Description Default <code>node_name</code> <code>str</code> <p>The name of the node to patch.</p> required <code>target</code> <code>str</code> <p>The target of the object to patch in the form of a string with the attribute, sub-attribute, etc. and finally method (or attribute) to replace, sepparated with period, eg. <code>make_discharge</code> or <code>sewer_tank.pull_storage_exact</code>.</p> required <code>item</code> <code>Hashable</code> <p>Typically a string or an integer indicating the item to replace in the selected attribue, which should be a list or a dictionary.</p> <code>None</code> <code>is_attr</code> <code>bool</code> <p>If True, the decorated function will be called when applying the patch and the result assigned to the target, instead of assigning the function itself. In this case, the only argument passed to the function is the node object.</p> <code>False</code> Source code in <code>wsimod/extensions.py</code> <pre><code>def register_node_patch(\n    node_name: str, target: str, item: Hashable = None, is_attr: bool = False\n) -&gt; Callable:\n    \"\"\"Register a function to patch a node method or any of its attributes.\n\n    Args:\n        node_name (str): The name of the node to patch.\n        target (str): The target of the object to patch in the form of a string with the\n            attribute, sub-attribute, etc. and finally method (or attribute) to replace,\n            sepparated with period, eg. `make_discharge` or\n            `sewer_tank.pull_storage_exact`.\n        item (Hashable): Typically a string or an integer indicating the item to replace\n            in the selected attribue, which should be a list or a dictionary.\n        is_attr (bool): If True, the decorated function will be called when applying\n            the patch and the result assigned to the target, instead of assigning the\n            function itself. In this case, the only argument passed to the function is\n            the node object.\n    \"\"\"\n    target_id = (node_name, target, item, is_attr)\n    if target_id in extensions_registry:\n        warnings.warn(f\"Patch for {target} already registered.\")\n\n    def decorator(func):\n        extensions_registry[target_id] = func\n        return func\n\n    return decorator\n</code></pre>"},{"location":"reference-land/","title":"API Reference - Land","text":"<p>This section of the documentation provides a reference for the API of the nodes.land and nodes.nutrient_pool modules.</p> <p>Created on Fri May 20 08:58:58 2022.</p> <p>@author: Barney</p> <p>Created on Thu May 19 16:42:20 2022.</p> <p>@author: barna</p>"},{"location":"reference-land/#wsimod.nodes.land.GardenSurface","title":"<code>GardenSurface</code>","text":"<p>               Bases: <code>GrowingSurface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class GardenSurface(GrowingSurface):\n    \"\"\"\"\"\"\n\n    # TODO - probably a simplier version of this is useful, building just on\n    # pervioussurface\n    def __init__(self, **kwargs):\n        \"\"\"A specific surface for gardens that treats the garden as a grass crop, but\n        that can calculate/receive irrigation through functions that are assigned by the\n        parent land node's handlers, which in turn are expected to be triggered by a\n        query from an attached Demand node.\"\"\"\n        super().__init__(**kwargs)\n\n    def calculate_irrigation_demand(self, ignore_vqip=None):\n        \"\"\"A check function (assigned by parent to push check from demand nodes) that\n        calculations irrigation demand (i.e., difference between evaporation and\n        preciptiation).\n\n        Args:\n            ignore_vqip (any, optional): Conventional push checks send an optional\n                VQIP amount, however the intention with this check is to get the\n                irrigation demand\n\n        Returns:\n            reply (dict): A VQIP amount of irrigation demand (note only 'volume' key\n                is used)\n        \"\"\"\n        # Calculate irrigation demand\n        irrigation_demand = max(\n            self.evaporation[\"volume\"] - self.precipitation[\"volume\"], 0\n        )\n\n        root_zone_depletion = self.get_cmd()\n        if root_zone_depletion &lt;= constants.FLOAT_ACCURACY:\n            # TODO this isn't in FAO... but seems sensible\n            irrigation_demand = 0\n\n        # Reply as VQIP\n        reply = self.empty_vqip()\n        reply[\"volume\"] = irrigation_demand\n        return reply\n\n    def receive_irrigation_demand(self, vqip):\n        \"\"\"A set function (assigned by parent to push set from demand nodes) that\n        assigns irrigation water supply to the surface tank.\n\n        Args:\n            vqip (dict): A VQIP amount of irrigation to receive\n\n        Returns:\n            (dict): A VQIP amount of irrigation that was not received (should always\n                be empty)\n        \"\"\"\n        # update tank\n        return self.push_storage(vqip, force=True)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GardenSurface.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>A specific surface for gardens that treats the garden as a grass crop, but that can calculate/receive irrigation through functions that are assigned by the parent land node's handlers, which in turn are expected to be triggered by a query from an attached Demand node.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"A specific surface for gardens that treats the garden as a grass crop, but\n    that can calculate/receive irrigation through functions that are assigned by the\n    parent land node's handlers, which in turn are expected to be triggered by a\n    query from an attached Demand node.\"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GardenSurface.calculate_irrigation_demand","title":"<code>calculate_irrigation_demand(ignore_vqip=None)</code>","text":"<p>A check function (assigned by parent to push check from demand nodes) that calculations irrigation demand (i.e., difference between evaporation and preciptiation).</p> <p>Parameters:</p> Name Type Description Default <code>ignore_vqip</code> <code>any</code> <p>Conventional push checks send an optional VQIP amount, however the intention with this check is to get the irrigation demand</p> <code>None</code> <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>A VQIP amount of irrigation demand (note only 'volume' key is used)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calculate_irrigation_demand(self, ignore_vqip=None):\n    \"\"\"A check function (assigned by parent to push check from demand nodes) that\n    calculations irrigation demand (i.e., difference between evaporation and\n    preciptiation).\n\n    Args:\n        ignore_vqip (any, optional): Conventional push checks send an optional\n            VQIP amount, however the intention with this check is to get the\n            irrigation demand\n\n    Returns:\n        reply (dict): A VQIP amount of irrigation demand (note only 'volume' key\n            is used)\n    \"\"\"\n    # Calculate irrigation demand\n    irrigation_demand = max(\n        self.evaporation[\"volume\"] - self.precipitation[\"volume\"], 0\n    )\n\n    root_zone_depletion = self.get_cmd()\n    if root_zone_depletion &lt;= constants.FLOAT_ACCURACY:\n        # TODO this isn't in FAO... but seems sensible\n        irrigation_demand = 0\n\n    # Reply as VQIP\n    reply = self.empty_vqip()\n    reply[\"volume\"] = irrigation_demand\n    return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GardenSurface.receive_irrigation_demand","title":"<code>receive_irrigation_demand(vqip)</code>","text":"<p>A set function (assigned by parent to push set from demand nodes) that assigns irrigation water supply to the surface tank.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of irrigation to receive</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of irrigation that was not received (should always be empty)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def receive_irrigation_demand(self, vqip):\n    \"\"\"A set function (assigned by parent to push set from demand nodes) that\n    assigns irrigation water supply to the surface tank.\n\n    Args:\n        vqip (dict): A VQIP amount of irrigation to receive\n\n    Returns:\n        (dict): A VQIP amount of irrigation that was not received (should always\n            be empty)\n    \"\"\"\n    # update tank\n    return self.push_storage(vqip, force=True)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface","title":"<code>GrowingSurface</code>","text":"<p>               Bases: <code>PerviousSurface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class GrowingSurface(PerviousSurface):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        rooting_depth=1,\n        ET_depletion_factor=1,\n        crop_factor_stages=[1, 1],\n        crop_factor_stage_dates=[0, 365],\n        sowing_day=1,\n        harvest_day=365,\n        initial_soil_storage=None,\n        **kwargs,\n    ):\n        \"\"\"Extensive surface subclass that implements the CatchWat equations (Liu,\n        Dobson &amp; Mijic (2022) Science of the total environment), which in turn are\n        primarily based on FAO document:\n        https://www.fao.org/3/x0490e/x0490e0ehtm#soil%20water%20availability. This\n        surface is a pervious surface that also has things that grow on it. This\n        behaviour includes soil nutrient pools, crop planting/harvest calendars,\n        erosion, crop behaviour.\n\n        A key complexity of this surface is the nutrient pool (see wsimod/nodes/\n        nutrient_pool.py), which is a class that tracks the amount of phosphorus and\n        nitrogen in different states and performs transformations that occur in the\n        phosphorus/nitrogen cycle. It is assumed that the phosphate/nitrate/nitrite/\n        ammonia amounts in this Surface tank should track the dissolved inorganic pool\n        in the nutrient pool. Meanwhile, the org-phosphorus/org-nitrogen amounts in this\n        tank should track the dissolved organic pool in the nutrient pool. The total\n        amount of pollutants that enter this tank may not be the same as the total\n        amount that leave, because pollutants are transformed between inorganic/ organic\n        and between wet/dry states - these transformations are accounted for in mass\n        balance.\n\n        For users to quickly enable/disable these nutrient processes, which are\n        computationally intensive (in current case studies they account for about half\n        of the total runtime), they are only active if 'nitrate' is one of the modelled\n        pollutants. Note that the code will not check if nitrite/phosphate/\n        org-phosphorus/org-nitrogen/ammonia are also included, but they should be if\n        nitrate is included and otherwise the code will crash with a key error.\n\n        Args:\n            rooting_depth (float, optional): Depth of the soil tank (i.e., how deep do\n                crop roots go). Defaults to 1.\n            ET_depletion_factor (float, optional): Average fraction of soil that can be\n                depleted from the root zone before moisture stress (reduction in ET)\n                occurs. Defaults to 1.\n            crop_factor_stages (list, optional): Crop factor is a multiplier on et0,\n                more grown plants have higher transpiration and higher crop factors.\n                This list shows changing crop factor at different times of year in\n                relation to crop_factor_stage_dates. See wsimod/preprocessing/\n                england_data_formatting.py/format_surfaces for further details on\n                formulating these - since the interpolation used to find crop_factors in\n                between the given values in the list is a bit involved. Defaults to\n                [1,1].\n            crop_factor_stage_dates (list, optional): Dates associated with\n                crop_factor_stages. Defaults to [0, 365].\n            sowing_day (int, optional): day of year that crops are sown. Defaults to 1.\n            harvest_day (int, optional): day of year that crops are harvest. Defaults\n                to 365.\n            initial_soil_storage (dict or float, optional): Initial mass of solid\n            pollutants\n                in the soil nutrient pools (fast and adsorbed inorganic pools)\n\n        Key assumptions:\n             - In the soil water module, crop stages and crop coefficients control the\n               evapotranspiration.\n             - Fertiliser and manure application are the major source of soil nutrients,\n               which are added\n                into soil nutrient pools, including dissovled inorganic, dissolved\n                organic, fast and humus for both nitrogen and phosphorus.\n             - Nutrient transformation processes in soil are simulated, including fluxes\n               between the soil\n                nutrient pools, denitrification for nitrogen, adsorption/desorption for\n                phosphorus. These processes are affected by temperature and soil\n                moisture.\n             - Crop uptake of nutrients are simulated based on crop stages, which is\n               different for spring-sown\n                and autumn-sown crops.\n             - Soil erosion from the growing surface is simulated as one of the major\n               sources of suspended solids\n                in rivers, which is mainly affected by rainfall energy and crop/ground\n                cover. Phosphorus will also be eroded along with the soil particles, in\n                both adsorbed inorganic and humus form.\n\n        Input data and parameter requirements:\n             - `data_input_dict` can contain a variety of pollutant deposition data.\n                `srp-fertiliser` describes phosphate. `noy-fertiliser` describes\n                nitrogen as nitrates. `nhx-fertiliser` describes nitrogen as ammonia.\n                `srp/noy/ nhx-manure` can also be used to specify manure application.\n                _Units_: kg/m2/timestep (data is read at a monthly timestep)\n             - Rooting depth.\n                _Units_: m\n             - Evapotranspiration depletion factor.\n                _Units_: -\n             - Sowing day, harvest day and crop calendars.\n                _Units_: day number in Julian calendar\n             - Crop factor.\n                _Units_: -\n             - Initial storage for solid pollutants.\n                _Units_: kg\n\n        \"\"\"\n        # Crop factors (set when creating object)\n        self.ET_depletion_factor = (\n            ET_depletion_factor  # To do with water availability, p from FAOSTAT\n        )\n        self.rooting_depth = (\n            rooting_depth  # maximum depth that plants can absorb, Zr from FAOSTAT\n        )\n        depth = rooting_depth\n\n        # Crop parameters\n        self.crop_cover_max = 0.9  # [-] 0~1\n        self.ground_cover_max = 0.3  # [-]\n        # TODO... really I should just have this as an annual profile parameter and do\n        # away with interpolation etc.\n        self.crop_factor_stages = crop_factor_stages\n        self.crop_factor_stage_dates = crop_factor_stage_dates\n        self.sowing_day = sowing_day\n        self.harvest_day = harvest_day\n\n        # Soil moisture dependence parameters\n        self.satact = 0.6  # [-] for calculating soil_moisture_dependence_factor\n        self.thetaupp = 0.12  # [-] for calculating soil_moisture_dependence_factor\n        self.thetalow = 0.08  # [-] for calculating soil_moisture_dependence_factor\n        self.thetapow = 1  # [-] for calculating soil_moisture_dependence_factorself.\n        # satact = 0.6 # [-] for calculating soil_moisture_dependence_factor\n\n        # Crop uptake parameters\n        self.uptake1 = (\n            15  # [g/m2/y] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n        )\n        self.uptake2 = (\n            1  # [-] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n        )\n        self.uptake3 = (\n            0.02  # [1/day] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n        )\n        self.uptake_PNratio = 1 / 7.2  # [-] P:N during crop uptake\n\n        # Erosion parameters\n        self.erodibility = 0.0025  # [g * d / (J * mm)]\n        self.sreroexp = 1.2  # [-] surface runoff erosion exponent\n        self.cohesion = 1  # [kPa]\n        self.slope = 5  # [-] every 100\n        self.srfilt = (\n            0.7  # [-] ratio of eroded sediment left in surface runoff after filtration\n        )\n        self.macrofilt = 0.01  # [-] ratio of eroded sediment left in subsurface flow\n        # after filtration\n\n        # Denitrification parameters\n        self.limpar = 0.7  # [-] above which denitrification begins\n        self.exppar = 2.5  # [-] exponential parameter for\n        # soil_moisture_dependence_factor_exp calculation\n        self.hsatINs = 1  # [mg/l] for calculation of half-saturation concentration\n        # dependence factor\n        self.denpar = 0.015  # [-] denitrification rate coefficient\n\n        # Adsorption parameters\n        self.adosorption_nr_limit = 0.00001\n        self.adsorption_nr_maxiter = 20\n        self.kfr = 153.7  # [litter/kg] freundlich adsorption isoterm\n        self.nfr = 1 / 2.6  # [-] freundlich exponential coefficient\n        self.kadsdes = 0.03  # [1/day] adsorption/desorption coefficient\n\n        # Other soil parameters\n        self.bulk_density = 1300  # [kg/m3]\n        super().__init__(depth=depth, **kwargs)\n\n        (\n            self.harvest_sow_calendar,\n            self.ground_cover_stages,\n            self.crop_cover_stages,\n            self.autumn_sow,\n        ) = self.infer_sow_harvest_calendar()\n\n        # State variables\n        self.days_after_sow = None\n        self.crop_cover = 0\n        self.ground_cover = 0\n        self.crop_factor = 0\n        self.et0_coefficient = 1\n\n        (\n            self.total_available_water,\n            self.readily_available_water,\n        ) = self.calculate_available_water()\n\n        # Initiliase nutrient pools\n        self.nutrient_pool = NutrientPool()\n\n        self.inflows.insert(0, self.calc_crop_cover)\n        if \"nitrate\" in constants.POLLUTANTS:\n            # Populate function lists\n            self.inflows.append(self.effective_precipitation_flushing)\n            self.inflows.append(self.fertiliser)\n            self.inflows.append(self.manure)\n            # self.inflows.append(self.residue)\n\n            self.processes.append(self.calc_temperature_dependence_factor)\n            self.processes.append(self.calc_soil_moisture_dependence_factor)\n            self.processes.append(self.soil_pool_transformation)\n            self.processes.append(self.calc_crop_uptake)\n\n            # TODO possibly move these into nutrient pool\n            self.processes.append(self.erosion)\n            self.processes.append(self.denitrification)\n            self.processes.append(self.adsorption)\n\n            # Reflect initial water concentration in dissolved nutrient pools\n            self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"] = self.storage[\n                \"phosphate\"\n            ]\n            self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"] = (\n                self.storage[\"nitrate\"]\n                + self.storage[\"ammonia\"]\n                + self.storage[\"nitrite\"]\n            )\n            self.nutrient_pool.dissolved_organic_pool.storage[\"P\"] = self.storage[\n                \"org-phosphorus\"\n            ]\n            self.nutrient_pool.dissolved_organic_pool.storage[\"N\"] = self.storage[\n                \"org-nitrogen\"\n            ]\n            if initial_soil_storage:\n                self.initial_soil_storage = initial_soil_storage\n                # Reflect initial nutrient stores in solid nutrient pools\n                self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"] = (\n                    initial_soil_storage[\"phosphate\"]\n                )\n                self.nutrient_pool.adsorbed_inorganic_pool.storage[\"N\"] = (\n                    initial_soil_storage[\"ammonia\"]\n                    + initial_soil_storage[\"nitrate\"]\n                    + initial_soil_storage[\"nitrite\"]\n                )\n                self.nutrient_pool.fast_pool.storage[\"N\"] = initial_soil_storage[\n                    \"org-nitrogen\"\n                ]\n                self.nutrient_pool.fast_pool.storage[\"P\"] = initial_soil_storage[\n                    \"org-phosphorus\"\n                ]\n\n    def infer_sow_harvest_calendar(self):\n        \"\"\"Infer basic sow/harvest calendar and indicate autumn-sown.\n        Returns:\n            (list): havest/sow calendar\n            (list): ground cover stages\n            (list): crop cover stages\n            (boolean): indication for autumn-sown crops\n        \"\"\"\n        # Infer basic sow/harvest calendar\n        harvest_sow_calendar = [\n            0,\n            self.sowing_day,\n            self.harvest_day,\n            self.harvest_day + 1,\n            365,\n        ]\n        ground_cover_stages = [0, 0, self.ground_cover_max, 0, 0]\n        crop_cover_stages = [0, 0, self.crop_cover_max, 0, 0]\n\n        # Use day number of 181 to indicate autumn-sown (from HYPE)\n        if self.sowing_day &gt; 181:\n            autumn_sow = True\n        else:\n            autumn_sow = False\n\n        return harvest_sow_calendar, ground_cover_stages, crop_cover_stages, autumn_sow\n\n    def calculate_available_water(self):\n        \"\"\"Calculate total/readily available water based on capacity/wp.\n        Returns:\n            (float): total available water\n            (float): readily available water\n        \"\"\"\n        # Calculate parameters based on capacity/wp\n        total_available_water = self.field_capacity_m - self.wilting_point_m\n        if total_available_water &lt; 0:\n            print(\"warning: TAW &lt; 0...\")\n        readily_available_water = total_available_water * self.ET_depletion_factor\n\n        return total_available_water, readily_available_water\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        overwrite_params = [\n            \"ET_depletion_factor\",\n            \"crop_cover_max\",\n            \"ground_cover_max\",\n            \"crop_factor_stages\",\n            \"crop_factor_stage_dates\",\n            \"sowing_day\",\n            \"harvest_day\",\n            \"satact\",\n            \"thetaupp\",\n            \"thetalow\",\n            \"thetapow\",\n            \"uptake1\",\n            \"uptake2\",\n            \"uptake3\",\n            \"uptake_PNratio\",\n            \"erodibility\",\n            \"sreroexp\",\n            \"cohesion\",\n            \"slope\",\n            \"srfilt\",\n            \"macrofilt\",\n            \"limpar\",\n            \"exppar\",\n            \"hsatINs\",\n            \"denpar\",\n            \"adosorption_nr_limit\",\n            \"adsorption_nr_maxiter\",\n            \"kfr\",\n            \"nfr\",\n            \"kadsdes\",\n            \"bulk_density\",\n        ]\n        for param in overwrite_params:\n            setattr(self, param, overrides.pop(param, getattr(self, param)))\n\n        if \"depth\" in overrides.keys():\n            overrides.pop(\"depth\")\n            print(\n                \"ERROR: specifying depth is depreciated in overrides for \\\n\t\tGrowingSurface, please specify rooting_depth instead\"\n            )\n        self.rooting_depth = overrides.pop(\"rooting_depth\", self.rooting_depth)\n        overrides[\"depth\"] = self.rooting_depth\n        super().apply_overrides(overrides)\n\n        (\n            self.harvest_sow_calendar,\n            self.ground_cover_stages,\n            self.crop_cover_stages,\n            self.autumn_sow,\n        ) = self.infer_sow_harvest_calendar()\n        (\n            self.total_available_water,\n            self.readily_available_water,\n        ) = self.calculate_available_water()\n\n    def pull_storage(self, vqip):\n        \"\"\"Pull water from the surface, updating the surface storage VQIP. Nutrient pool\n        pollutants (nitrate/nitrite/ammonia/phosphate/org- phosphorus/ org-nitrogen) are\n        removed in proportion to their amounts in the dissolved nutrient pools, if they\n        are simulated. Other pollutants are removed in proportion to their amount in the\n        surface tank.\n\n        Args:\n            vqip (dict): VQIP amount to be pulled, (only 'volume' key is needed)\n\n        Returns:\n            reply (dict): A VQIP amount successfully pulled from the tank\n        \"\"\"\n        if self.storage[\"volume\"] == 0:\n            return self.empty_vqip()\n\n        # Adjust based on available volume\n        reply = min(vqip[\"volume\"], self.storage[\"volume\"])\n\n        # Update reply to vqip (get concentration for non-nutrients)\n        reply = self.v_change_vqip(self.storage, reply)\n\n        if \"nitrate\" in constants.POLLUTANTS:\n            # Update nutrient pool and get concentration for nutrients\n            prop = reply[\"volume\"] / self.storage[\"volume\"]\n            nutrients = self.nutrient_pool.extract_dissolved(prop)\n            reply[\"nitrate\"] = (\n                nutrients[\"inorganic\"][\"N\"]\n                * self.storage[\"nitrate\"]\n                / (\n                    self.storage[\"nitrate\"]\n                    + self.storage[\"ammonia\"]\n                    + self.storage[\"nitrite\"]\n                )\n            )\n            reply[\"ammonia\"] = (\n                nutrients[\"inorganic\"][\"N\"]\n                * self.storage[\"ammonia\"]\n                / (\n                    self.storage[\"nitrate\"]\n                    + self.storage[\"ammonia\"]\n                    + self.storage[\"nitrite\"]\n                )\n            )\n            reply[\"nitrite\"] = (\n                nutrients[\"inorganic\"][\"N\"]\n                * self.storage[\"nitrite\"]\n                / (\n                    self.storage[\"nitrate\"]\n                    + self.storage[\"ammonia\"]\n                    + self.storage[\"nitrite\"]\n                )\n            )\n            reply[\"phosphate\"] = nutrients[\"inorganic\"][\"P\"]\n            reply[\"org-phosphorus\"] = nutrients[\"organic\"][\"P\"]\n            reply[\"org-nitrogen\"] = nutrients[\"organic\"][\"N\"]\n\n        # Extract from storage\n        self.storage = self.extract_vqip(self.storage, reply)\n\n        return reply\n\n    def quick_interp(self, x, xp, yp):\n        \"\"\"A simple version of np.interp to intepolate crop information on the fly.\n\n        Args:\n            x (int): Current time (i.e., day of year) xp (list): Predefined times (i.e.,\n            list of days of year) yp (list): Predefined values associated with xp\n\n        Returns:\n            y (float): Interpolated value for current time\n        \"\"\"\n        x_ind = bisect_left(xp, x)\n        x_left = xp[x_ind - 1]\n        x_right = xp[x_ind]\n        dif = x - x_left\n        y_left = yp[x_ind - 1]\n        y_right = yp[x_ind]\n        y = y_left + (y_right - y_left) * dif / (x_right - x_left)\n        return y\n\n    def calc_crop_cover(self):\n        \"\"\"Process function that calculates how much crop cover there is, assigns\n        whether crops are sown/harvested, and calculates et0_coefficient based on growth\n        stage of crops.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Get current day of year\n        doy = self.parent.t.dayofyear\n\n        if self.parent.t.is_leap_year:\n            # Hacky way to handle leap years\n            if doy &gt; 59:\n                doy -= 1\n\n        if self.days_after_sow is None:\n            if self.parent.t.dayofyear == self.sowing_day:\n                # sow\n                self.days_after_sow = 0\n        else:\n            if self.parent.t.dayofyear == self.harvest_day:\n                # harvest\n                self.days_after_sow = None\n                self.crop_factor = self.crop_factor_stages[0]\n                self.crop_cover = 0\n                self.ground_cover = 0\n            else:\n                # increment days since sow\n                self.days_after_sow += 1\n\n        # Calculate relevant parameters\n        self.crop_factor = self.quick_interp(\n            doy, self.crop_factor_stage_dates, self.crop_factor_stages\n        )\n        if self.days_after_sow:\n            # Move outside of this if, if you want nonzero crop/ground cover outside of\n            # season\n            self.crop_cover = self.quick_interp(\n                doy, self.harvest_sow_calendar, self.crop_cover_stages\n            )\n            self.ground_cover = self.quick_interp(\n                doy, self.harvest_sow_calendar, self.ground_cover_stages\n            )\n\n        root_zone_depletion = max(self.field_capacity_m - self.get_smc(), 0)\n        if root_zone_depletion &lt; self.readily_available_water:\n            crop_water_stress_coefficient = 1\n        else:\n            crop_water_stress_coefficient = max(\n                0,\n                (self.total_available_water - root_zone_depletion)\n                / ((1 - self.ET_depletion_factor) * self.total_available_water),\n            )\n\n        self.et0_coefficient = crop_water_stress_coefficient * self.crop_factor\n\n        return (self.empty_vqip(), self.empty_vqip())\n\n    def adjust_vqip_to_liquid(self, vqip, deposition, in_):\n        \"\"\"Function to interoperate between surface tank and nutrient pool. Most\n        depositions are given in terms of ammonia/nitrate/phosphate - they are then\n        aggregated to total N or P to enter the nutrient pools. Depending on the source\n        of deposition these may transform (e.g., some go to dissolved and some to\n        solids) upon entering the nutrient pool. To reflect these transformations in the\n        soil tank, the amounts entering the soil tank are adjusted proportionately.\n\n        Args:\n            vqip (dict): A VQIP amount of pollutants originally intended to enter the\n                soil tank\n            deposition (dict): A dict with nutrients (N and P) as keys, showing the\n                total amount of nutrients entering the nutrient pool\n            in_ (dict): A dict with nutrients as keys, showing the updated amount of\n                nutrients that entered the nutrient pool as dissolved pollutants\n\n        Returns:\n            vqip (dict): A VQIP amount of pollutants that have been scaled to account\n                for nutrient pool transformations\n        \"\"\"\n        if \"nitrate\" in constants.POLLUTANTS:\n            if deposition[\"N\"] &gt; 0:\n                vqip[\"nitrate\"] *= in_[\"N\"] / deposition[\"N\"]\n                vqip[\"ammonia\"] *= in_[\"N\"] / deposition[\"N\"]\n                vqip[\"org-nitrogen\"] *= in_[\"N\"] / deposition[\"N\"]\n            if deposition[\"P\"] &gt; 0:\n                vqip[\"phosphate\"] *= in_[\"P\"] / deposition[\"P\"]\n                vqip[\"org-phosphorus\"] *= in_[\"P\"] / deposition[\"P\"]\n\n        return vqip\n\n    def effective_precipitation_flushing(self):\n        \"\"\"Remove the nutrients brought out by effective precipitation, which is surface\n        runoff, subsurface runoff, and percolation, from the nutrients pool.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                    for mass balance checking.\n        \"\"\"\n        # inorganic\n        out = self.nutrient_pool.get_empty_nutrient()\n        out[\"N\"] = (\n            self.subsurface_flow[\"ammonia\"]\n            + self.subsurface_flow[\"nitrite\"]\n            + self.subsurface_flow[\"nitrate\"]\n            + self.percolation[\"ammonia\"]\n            + self.percolation[\"nitrite\"]\n            + self.percolation[\"nitrate\"]\n            + self.infiltration_excess[\"ammonia\"]\n            + self.infiltration_excess[\"nitrite\"]\n            + self.infiltration_excess[\"nitrate\"]\n        )  # TODO what happens if infiltration excess (the real part) has pollutants?\n        out[\"P\"] = (\n            self.subsurface_flow[\"phosphate\"]\n            + self.percolation[\"phosphate\"]\n            + self.infiltration_excess[\"phosphate\"]\n        )\n        self.nutrient_pool.dissolved_inorganic_pool.extract(out)\n\n        # organic\n        out = self.nutrient_pool.get_empty_nutrient()\n        out[\"N\"] = (\n            self.subsurface_flow[\"org-nitrogen\"]\n            + self.percolation[\"org-nitrogen\"]\n            + self.infiltration_excess[\"org-nitrogen\"]\n        )\n        out[\"P\"] = (\n            self.subsurface_flow[\"org-phosphorus\"]\n            + self.percolation[\"org-phosphorus\"]\n            + self.infiltration_excess[\"org-phosphorus\"]\n        )\n        self.nutrient_pool.dissolved_organic_pool.extract(out)\n\n        return (self.empty_vqip(), self.empty_vqip())\n\n    def fertiliser(self):\n        \"\"\"Read, scale and allocate fertiliser, updating the tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # TODO tidy up fertiliser/manure/residue/deposition once preprocessing is sorted\n\n        # Scale for surface\n        nhx = self.get_data_input_surface(\"nhx-fertiliser\") * self.area\n        noy = self.get_data_input_surface(\"noy-fertiliser\") * self.area\n        srp = self.get_data_input_surface(\"srp-fertiliser\") * self.area\n\n        # Update as VQIP\n        vqip = self.empty_vqip()\n        vqip[\"ammonia\"] = nhx\n        vqip[\"nitrate\"] = noy\n        vqip[\"phosphate\"] = srp\n\n        # Enter nutrient pool\n        deposition = self.nutrient_pool.get_empty_nutrient()\n        deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n        deposition[\"P\"] = vqip[\"phosphate\"]\n        in_ = self.nutrient_pool.allocate_fertiliser(deposition)\n\n        # Update tank\n        vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n        self.push_storage(vqip, force=True)\n\n        return (vqip, self.empty_vqip())\n\n    def manure(self):\n        \"\"\"Read, scale and allocate manure, updating the tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Scale for surface\n        nhx = self.get_data_input_surface(\"nhx-manure\") * self.area\n        noy = self.get_data_input_surface(\"noy-manure\") * self.area\n        srp = self.get_data_input_surface(\"srp-manure\") * self.area\n\n        # Formulate as VQIP\n        vqip = self.empty_vqip()\n        vqip[\"ammonia\"] = nhx\n        vqip[\"nitrate\"] = noy\n        vqip[\"phosphate\"] = srp\n\n        # Enter nutrient pool\n        deposition = self.nutrient_pool.get_empty_nutrient()\n        deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n        deposition[\"P\"] = vqip[\"phosphate\"]\n        in_ = self.nutrient_pool.allocate_manure(deposition)\n\n        # Update tank\n        vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n        self.push_storage(vqip, force=True)\n\n        return (vqip, self.empty_vqip())\n\n    def residue(self):\n        \"\"\"Read, scale and allocate residue, updating the tank (NOT CURRENTLY USED\n        BECAUSE NO DATA SOURCES FOR RESIDUE CAN BE IDENTIFIED).\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        nhx = self.get_data_input_surface(\"nhx-residue\") * self.area\n        noy = self.get_data_input_surface(\"noy-residue\") * self.area\n        srp = self.get_data_input_surface(\"srp-residue\") * self.area\n\n        vqip = self.empty_vqip()\n        vqip[\"ammonia\"] = nhx * self.nutrient_pool.fraction_residue_to_fast[\"N\"]\n        vqip[\"nitrate\"] = noy * self.nutrient_pool.fraction_residue_to_fast[\"N\"]\n        vqip[\"org-nitrogen\"] = (\n            nhx + noy\n        ) * self.nutrient_pool.fraction_residue_to_humus[\"N\"]\n        vqip[\"phosphate\"] = srp * self.nutrient_pool.fraction_residue_to_fast[\"P\"]\n        vqip[\"org-phosphorus\"] = srp * self.nutrient_pool.fraction_residue_to_humus[\"P\"]\n\n        deposition = self.nutrient_pool.get_empty_nutrient()\n        deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"] + vqip[\"org-nitrogen\"]\n        deposition[\"P\"] = vqip[\"phosphate\"] + vqip[\"org-phosphorus\"]\n\n        in_ = self.nutrient_pool.allocate_residue(deposition)\n        vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n        self.push_storage(vqip, force=True)\n\n        return (vqip, self.empty_vqip())\n\n    def soil_pool_transformation(self):\n        \"\"\"A process function that run transformation functions in the nutrient pool and\n        updates the pollutant concentrations in the surface tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Initialise mass balance tracking variables\n        in_ = self.empty_vqip()\n        out_ = self.empty_vqip()\n\n        # Get proportion of nitrogen that is nitrate in the soil tank NOTE ignores\n        # nitrite - couldn't find enough information on it\n        nitrate_proportion = self.storage[\"nitrate\"] / (\n            self.storage[\"nitrate\"] + self.storage[\"ammonia\"]\n        )\n\n        # Run soil pool functions\n        (\n            increase_in_dissolved_inorganic,\n            increase_in_dissolved_organic,\n        ) = self.nutrient_pool.soil_pool_transformation()\n\n        # Update tank and mass balance TODO .. there is definitely a neater way to write\n        # this\n        if increase_in_dissolved_inorganic[\"N\"] &gt; 0:\n            # Increase in inorganic nitrogen, rescale back to nitrate and ammonia\n            in_[\"nitrate\"] = increase_in_dissolved_inorganic[\"N\"] * nitrate_proportion\n            in_[\"ammonia\"] = increase_in_dissolved_inorganic[\"N\"] * (\n                1 - nitrate_proportion\n            )\n        else:\n            # Decrease in inorganic nitrogen, rescale back to nitrate and ammonia\n            out_[\"nitrate\"] = -increase_in_dissolved_inorganic[\"N\"] * nitrate_proportion\n            out_[\"ammonia\"] = -increase_in_dissolved_inorganic[\"N\"] * (\n                1 - nitrate_proportion\n            )\n\n        if increase_in_dissolved_organic[\"N\"] &gt; 0:\n            # Increase in organic nitrogen\n            in_[\"org-nitrogen\"] = increase_in_dissolved_organic[\"N\"]\n        else:\n            # Decrease in organic nitrogen\n            out_[\"org-nitrogen\"] = -increase_in_dissolved_organic[\"N\"]\n\n        if increase_in_dissolved_inorganic[\"P\"] &gt; 0:\n            # Increase in inorganic phosphate\n            in_[\"phosphate\"] = increase_in_dissolved_inorganic[\"P\"]\n        else:\n            # Decrease in inorganic phosphate\n            out_[\"phosphate\"] = -increase_in_dissolved_inorganic[\"P\"]\n\n        if increase_in_dissolved_organic[\"P\"] &gt; 0:\n            # Increase in organic phosphorus\n            in_[\"org-phosphorus\"] = increase_in_dissolved_organic[\"P\"]\n        else:\n            # Decrease in organic phosphorus\n            out_[\"org-phosphorus\"] = -increase_in_dissolved_organic[\"P\"]\n\n        # Update tank with inputs/outputs of pollutants\n        _ = self.push_storage(in_, force=True)\n        out2_ = self.pull_pollutants(out_)\n\n        if not self.compare_vqip(out_, out2_):\n            print(\"nutrient pool not tracking soil tank\")\n\n        return (in_, out_)\n\n    def calc_temperature_dependence_factor(self):\n        \"\"\"Process function that calculates the temperature dependence factor for the\n        nutrient pool (which impacts soil pool transformations).\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation\n        if self.storage[\"temperature\"] &gt; 5:\n            temperature_dependence_factor = 2 ** (\n                (self.storage[\"temperature\"] - 20) / 10\n            )\n        elif self.storage[\"temperature\"] &gt; 0:\n            temperature_dependence_factor = self.storage[\"temperature\"] / 5\n        else:\n            temperature_dependence_factor = 0\n        self.nutrient_pool.temperature_dependence_factor = temperature_dependence_factor\n        return (self.empty_vqip(), self.empty_vqip())\n\n    def calc_soil_moisture_dependence_factor(self):\n        \"\"\"Process function that calculates the soil moisture dependence factor for the\n        nutrient pool (which impacts soil pool transformations).\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation\n        current_soil_moisture = self.get_smc()\n        if current_soil_moisture &gt;= self.field_capacity_m:\n            self.nutrient_pool.soil_moisture_dependence_factor = self.satact\n        elif current_soil_moisture &lt;= self.wilting_point_m:\n            self.nutrient_pool.soil_moisture_dependence_factor = 0\n        else:\n            fc_diff = self.field_capacity_m - current_soil_moisture\n            fc_comp = (fc_diff / (self.thetaupp * self.rooting_depth)) ** self.thetapow\n            fc_comp = (1 - self.satact) * fc_comp + self.satact\n            wp_diff = current_soil_moisture - self.wilting_point_m\n            wp_comp = (wp_diff / (self.thetalow * self.rooting_depth)) ** self.thetapow\n            self.nutrient_pool.soil_moisture_dependence_factor = min(\n                1, wp_comp, fc_comp\n            )\n        return (self.empty_vqip(), self.empty_vqip())\n\n    def calc_crop_uptake(self):\n        \"\"\"Process function that calculates how much nutrient crops uptake and updates\n        nutrient pool and surface tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation\n\n        # Initialise\n        N_common_uptake = 0\n        P_common_uptake = 0\n\n        if self.days_after_sow:\n            # If there are crops\n\n            days_after_sow = self.days_after_sow\n\n            if self.autumn_sow:\n                temp_func = max(0, min(1, (self.storage[\"temperature\"] - 5) / 20))\n                days_after_sow -= 25  # Not sure why this is (but it's in HYPE)\n            else:\n                temp_func = 1\n\n            # Calculate uptake\n            uptake_par = (self.uptake1 - self.uptake2) * exp(\n                -self.uptake3 * days_after_sow\n            )\n            if (uptake_par + self.uptake2) &gt; 0:\n                N_common_uptake = (\n                    self.uptake1\n                    * self.uptake2\n                    * self.uptake3\n                    * uptake_par\n                    / ((self.uptake2 + uptake_par) ** 2)\n                )\n            N_common_uptake *= temp_func * constants.G_M2_TO_KG_M2 * self.area  # [kg]\n            P_common_uptake = N_common_uptake * self.uptake_PNratio\n            # calculate maximum available uptake\n            N_maximum_available_uptake = (\n                max(0, self.storage[\"volume\"] - self.wilting_point_m * self.area)\n                / self.storage[\"volume\"]\n                * self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n            )\n            P_maximum_available_uptake = (\n                max(0, self.storage[\"volume\"] - self.wilting_point_m * self.area)\n                / self.storage[\"volume\"]\n                * self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"]\n            )\n\n            uptake = {\n                \"P\": min(P_common_uptake, P_maximum_available_uptake),\n                \"N\": min(N_common_uptake, N_maximum_available_uptake),\n            }\n            crop_uptake = self.nutrient_pool.dissolved_inorganic_pool.extract(uptake)\n            out_ = self.empty_vqip()\n\n            # Assuming plants eat N and P as nitrate and phosphate\n            out_[\"nitrate\"] = crop_uptake[\"N\"]\n            out_[\"phosphate\"] = crop_uptake[\"P\"]\n\n            out2_ = self.pull_pollutants(out_)\n            if not self.compare_vqip(out_, out2_):\n                print(\"nutrient pool not tracking soil tank\")\n\n            return (self.empty_vqip(), out_)\n        else:\n            return (self.empty_vqip(), self.empty_vqip())\n\n    def erosion(self):\n        \"\"\"Outflow function that erodes adsorbed/humus phosphorus and sediment and sends\n        onwards to percolation/surface runoff/subsurface runoff.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation (which explains why my\n        # documentation is a bit ambiguous - because theirs is too)\n\n        # Convert precipitation to MM since all the equations assume that\n        precipitation_depth = self.get_data_input(\"precipitation\") * constants.M_TO_MM\n\n        # Calculate how much rain is mobilising erosion\n        if precipitation_depth &gt; 5:\n            rainfall_energy = 8.95 + 8.44 * log10(\n                precipitation_depth\n                * (\n                    0.257\n                    + sin(2 * constants.PI * ((self.parent.t.dayofyear - 70) / 365))\n                    * 0.09\n                )\n                * 2\n            )\n            rainfall_energy *= precipitation_depth\n            mobilised_rain = rainfall_energy * (1 - self.crop_cover) * self.erodibility\n        else:\n            mobilised_rain = 0\n\n        # Calculate if any infiltration is mobilising erosion\n        if self.infiltration_excess[\"volume\"] &gt; 0:\n            mobilised_flow = (\n                self.infiltration_excess[\"volume\"] / self.area * constants.M_TO_MM * 365\n            ) ** self.sreroexp\n            mobilised_flow *= (\n                (1 - self.ground_cover)\n                * (1 / (0.5 * self.cohesion))\n                * sin(self.slope / 100)\n                / 365\n            )\n        else:\n            mobilised_flow = 0\n\n        # Sum flows (not sure why surface runoff isn't included) TODO I'm pretty sure it\n        # should be included here\n        total_flows = (\n            self.infiltration_excess[\"volume\"]\n            + self.subsurface_flow[\"volume\"]\n            + self.percolation[\"volume\"]\n        )  # m3/dt + self.tank_recharge['volume'] (guess not needed)\n\n        # Convert to MM/M2\n        erodingflow = total_flows / self.area * constants.M_TO_MM\n\n        # Calculate eroded sediment\n        transportfactor = min(1, (erodingflow / 4) ** 1.3)\n        erodedsed = (\n            1000 * (mobilised_flow + mobilised_rain) * transportfactor\n        )  # [kg/km2]\n        # TODO not sure what conversion this HYPE 1000 is referring to\n\n        # soil erosion with adsorbed inorganic phosphorus and humus phosphorus (erodedP\n        # as P in eroded sediments and effect of enrichment)\n        if erodingflow &gt; 4:\n            enrichment = 1.5\n        elif erodingflow &gt; 0:\n            enrichment = 4 - (4 - 1.5) * erodingflow / 4\n        else:\n            return (self.empty_vqip(), self.empty_vqip())\n\n        # Get erodable phosphorus\n        erodableP = (\n            self.nutrient_pool.get_erodable_P() / self.area * constants.KG_M2_TO_KG_KM2\n        )\n        erodedP = (\n            erodedsed\n            * (\n                erodableP\n                / (\n                    self.rooting_depth\n                    * constants.M_TO_KM\n                    * self.bulk_density\n                    * constants.KG_M3_TO_KG_KM3\n                )\n            )\n            * enrichment\n        )  # [kg/km2]\n\n        # Convert to kg\n        erodedP *= self.area * constants.M2_TO_KM2  # [kg]\n        erodedsed *= self.area * constants.M2_TO_KM2  # [kg]\n\n        # Allocate to different flows\n        surface_erodedP = (\n            self.srfilt * self.infiltration_excess[\"volume\"] / total_flows * erodedP\n        )  # [kg]\n        surface_erodedsed = (\n            self.srfilt * self.infiltration_excess[\"volume\"] / total_flows * erodedsed\n        )  # [kg]\n\n        subsurface_erodedP = (\n            self.macrofilt * self.subsurface_flow[\"volume\"] / total_flows * erodedP\n        )  # [kg]\n        subsurface_erodedsed = (\n            self.macrofilt * self.subsurface_flow[\"volume\"] / total_flows * erodedsed\n        )  # [kg]\n\n        percolation_erodedP = (\n            self.macrofilt * self.percolation[\"volume\"] / total_flows * erodedP\n        )  # [kg]\n        percolation_erodedsed = (\n            self.macrofilt * self.percolation[\"volume\"] / total_flows * erodedsed\n        )  # [kg]\n\n        # Track mass balance\n        in_ = self.empty_vqip()\n\n        # Total eroded phosphorus\n        eff_erodedP = percolation_erodedP + surface_erodedP + subsurface_erodedP  # [kg]\n        if eff_erodedP &gt; 0:\n            # Update nutrient pool\n            org_removed, inorg_removed = self.nutrient_pool.erode_P(eff_erodedP)\n            total_removed = inorg_removed + org_removed\n\n            if abs(total_removed - eff_erodedP) &gt; constants.FLOAT_ACCURACY:\n                print(\"weird nutrients\")\n\n            # scale flows to split between inorganic and organic eroded P\n            self.infiltration_excess[\"org-phosphorus\"] += (\n                surface_erodedP * org_removed / eff_erodedP\n            )\n            self.subsurface_flow[\"org-phosphorus\"] += (\n                subsurface_erodedP * org_removed / eff_erodedP\n            )\n            self.percolation[\"org-phosphorus\"] += (\n                percolation_erodedP * org_removed / eff_erodedP\n            )\n\n            # TODO Leon reckons this is conceptually dodgy.. but i'm not sure where else\n            # adsorbed inorganic phosphorus should go\n            self.infiltration_excess[\"phosphate\"] += (\n                surface_erodedP * inorg_removed / eff_erodedP\n            )\n            self.subsurface_flow[\"phosphate\"] += (\n                subsurface_erodedP * inorg_removed / eff_erodedP\n            )\n            self.percolation[\"phosphate\"] += (\n                percolation_erodedP * inorg_removed / eff_erodedP\n            )\n\n            # Entering the model (no need to uptake surface tank because both adsorbed\n            # inorganic pool and humus pool are solids and so no tracked in the soil\n            # water tank)\n            in_[\"phosphate\"] = inorg_removed\n            in_[\"org-phosphorus\"] = org_removed\n        else:\n            pass\n\n        # Track sediment as solids\n        self.infiltration_excess[\"solids\"] += surface_erodedsed\n        self.subsurface_flow[\"solids\"] += subsurface_erodedsed\n        self.percolation[\"solids\"] += percolation_erodedsed\n\n        in_[\"solids\"] = surface_erodedsed + subsurface_erodedsed + percolation_erodedsed\n\n        return (in_, self.empty_vqip())\n\n    def denitrification(self):\n        \"\"\"Outflow function that performs denitirication processes, updating nutrient\n        pool and soil tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation TODO could more of this be moved\n        # to NutrientPool Calculate soil moisture dependence of denitrification\n        soil_moisture_content = self.get_smc()\n        if soil_moisture_content &gt; self.field_capacity_m:\n            denitrifying_soil_moisture_dependence = 1\n        elif soil_moisture_content / self.field_capacity_m &gt; self.limpar:\n            denitrifying_soil_moisture_dependence = (\n                ((soil_moisture_content / self.field_capacity_m) - self.limpar)\n                / (1 - self.limpar)\n            ) ** self.exppar\n        else:\n            denitrifying_soil_moisture_dependence = 0\n            return (self.empty_vqip(), self.empty_vqip())\n\n        # Get dissolved inorg nitrogen as a concentration and calculate factor\n        din_conc = (\n            self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n            / self.storage[\"volume\"]\n        )  # [kg/m3]\n        din_conc *= constants.KG_M3_TO_MG_L\n        half_saturation_concentration_dependence_factor = din_conc / (\n            din_conc + self.hsatINs\n        )\n\n        # Calculate and extract dentrified nitrogen\n        denitrified_N = (\n            self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n            * half_saturation_concentration_dependence_factor\n            * denitrifying_soil_moisture_dependence\n            * self.nutrient_pool.temperature_dependence_factor\n            * self.denpar\n        )\n        denitrified_request = self.nutrient_pool.get_empty_nutrient()\n        denitrified_request[\"N\"] = denitrified_N\n        denitrified_N = self.nutrient_pool.dissolved_inorganic_pool.extract(\n            denitrified_request\n        )\n\n        # Leon reckons this should leave the model (though I think technically some\n        # small amount goes to nitrite)\n        out_ = self.empty_vqip()\n        out_[\"nitrate\"] = denitrified_N[\"N\"]\n\n        # Update tank\n        out2_ = self.pull_pollutants(out_)\n        if not self.compare_vqip(out_, out2_):\n            print(\"nutrient pool not tracking soil tank\")\n\n        return (self.empty_vqip(), out_)\n\n    def adsorption(self):\n        \"\"\"Outflow function that calculates phosphorus adsorption/desorptions and\n        updates soil tank and nutrient pools.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Parameters/equations from HYPE documentation TODO could this be moved to the\n        # nutrient pool?\n\n        # Initialise mass balance checking\n        in_ = self.empty_vqip()\n        out_ = self.empty_vqip()\n\n        # Get total phosphorus in pool available for adsorption/desorption\n        limit = self.adosorption_nr_limit\n        ad_de_P_pool = (\n            self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"]\n            + self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"]\n        )  # [kg]\n        ad_de_P_pool /= self.area * constants.M2_TO_KM2  # [kg/km2]\n        if ad_de_P_pool == 0:\n            return (self.empty_vqip(), self.empty_vqip())\n\n        # Calculate coefficient and concentration of adsorbed phosphorus\n        soil_moisture_content = (\n            self.get_smc() * constants.M_TO_MM\n        )  # [mm] (not sure why HYPE has this in mm but whatever)\n        conc_sol = (\n            self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"]\n            * constants.KG_TO_MG\n            / (self.bulk_density * self.rooting_depth * self.area)\n        )  # [mg P/kg soil]\n        coeff = self.kfr * self.bulk_density * self.rooting_depth  # [mm]\n\n        # calculate equilibrium concentration\n        if conc_sol &lt;= 0:\n            # Not sure how this would happen\n            print(\"Warning: soil partP &lt;=0. Freundlich will give error, take shortcut.\")\n            xn_1 = ad_de_P_pool / (soil_moisture_content + coeff)  # [mg/l]\n            ad_P_equi_conc = self.kfr * xn_1  # [mg/ kg]\n        else:\n            # Newton-Raphson method\n            x0 = exp(\n                (log(conc_sol) - log(self.kfr)) / self.nfr\n            )  # initial guess of equilibrium liquid concentration\n            fxn = x0 * soil_moisture_content + coeff * (x0**self.nfr) - ad_de_P_pool\n            xn = x0\n            xn_1 = xn\n            j = 0\n            while (\n                abs(fxn) &gt; limit and j &lt; self.adsorption_nr_maxiter\n            ):  # iteration to calculate equilibrium concentations\n                fxn = xn * soil_moisture_content + coeff * (xn**self.nfr) - ad_de_P_pool\n                fprimxn = soil_moisture_content + self.nfr * coeff * (\n                    xn ** (self.nfr - 1)\n                )\n                dx = fxn / fprimxn\n                if abs(dx) &lt; (0.000001 * xn):\n                    # From HYPE... not sure what it means\n                    break\n                xn_1 = xn - dx\n                if xn_1 &lt;= 0:\n                    xn_1 = 1e-10\n                xn = xn_1\n                j += 1\n            ad_P_equi_conc = self.kfr * (xn_1**self.nfr)\n            # print(ad_P_equi_conc, conc_sol)\n\n        # Calculate new pool and concentration, depends on the equilibrium concentration\n        if abs(ad_P_equi_conc - conc_sol) &gt; 1e-6:\n            request = self.nutrient_pool.get_empty_nutrient()\n\n            # TODO not sure about this if statement, surely it would be triggered every\n            # time\n            adsdes = (ad_P_equi_conc - conc_sol) * (\n                1 - exp(-self.kadsdes)\n            )  # kinetic adsorption/desorption\n            request[\"P\"] = (\n                adsdes\n                * self.bulk_density\n                * self.rooting_depth\n                * (self.area * constants.M2_TO_KM2)\n            )  # [kg]\n            if request[\"P\"] &gt; 0:\n                # Adsorption\n                adsorbed = self.nutrient_pool.dissolved_inorganic_pool.extract(request)\n                if (adsorbed[\"P\"] - request[\"P\"]) &gt; constants.FLOAT_ACCURACY:\n                    print(\"Warning: freundlich flow adjusted, was larger than pool\")\n                self.nutrient_pool.adsorbed_inorganic_pool.receive(adsorbed)\n\n                # Dissolved leaving the soil water tank and becoming solid\n                out_[\"phosphate\"] = adsorbed[\"P\"]\n\n                # Update tank\n                out2_ = self.pull_pollutants(out_)\n                if not self.compare_vqip(out_, out2_):\n                    print(\"nutrient pool not tracking soil tank\")\n            else:\n                # Desorption\n                request[\"P\"] = -request[\"P\"]\n                desorbed = self.nutrient_pool.adsorbed_inorganic_pool.extract(request)\n                if (desorbed[\"P\"] - request[\"P\"]) &gt; constants.FLOAT_ACCURACY:\n                    print(\"Warning: freundlich flow adjusted, was larger than pool\")\n                self.nutrient_pool.dissolved_inorganic_pool.receive(desorbed)\n\n                # Solid phosphorus becoming inorganic P in the soil water tank\n                in_[\"phosphate\"] = desorbed[\"P\"]\n                _ = self.push_storage(in_, force=True)\n\n        return (in_, out_)\n\n    def dry_deposition_to_tank(self, vqip):\n        \"\"\"Allocate dry deposition to surface tank, updating nutrient pool accordingly.\n\n        Args:\n            vqip (dict): A VQIP amount of dry deposition to send to tank\n\n        Returns:\n            vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n                for mass balance checking)\n        \"\"\"\n        # Convert to nutrients\n        deposition = self.nutrient_pool.get_empty_nutrient()\n        deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n        deposition[\"P\"] = vqip[\"phosphate\"]\n\n        # Update nutrient pool\n        in_ = self.nutrient_pool.allocate_dry_deposition(deposition)\n        vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n        # Update tank\n        self.push_storage(vqip, force=True)\n        return vqip\n\n    def wet_deposition_to_tank(self, vqip):\n        \"\"\"Allocate wet deposition to surface tank, updating nutrient pool accordingly.\n\n        Args:\n            vqip (dict): A VQIP amount of dry deposition to send to tank\n\n        Returns:\n            vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n                for mass balance checking)\n        \"\"\"\n        # Convert to nutrients\n        deposition = self.nutrient_pool.get_empty_nutrient()\n        deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n        deposition[\"P\"] = vqip[\"phosphate\"]\n\n        # Update nutrient pool\n        in_ = self.nutrient_pool.allocate_wet_deposition(deposition)\n        vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n        # Update tank\n        self.push_storage(vqip, force=True)\n        return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.__init__","title":"<code>__init__(rooting_depth=1, ET_depletion_factor=1, crop_factor_stages=[1, 1], crop_factor_stage_dates=[0, 365], sowing_day=1, harvest_day=365, initial_soil_storage=None, **kwargs)</code>","text":"<p>Extensive surface subclass that implements the CatchWat equations (Liu, Dobson &amp; Mijic (2022) Science of the total environment), which in turn are primarily based on FAO document: https://www.fao.org/3/x0490e/x0490e0ehtm#soil%20water%20availability. This surface is a pervious surface that also has things that grow on it. This behaviour includes soil nutrient pools, crop planting/harvest calendars, erosion, crop behaviour.</p> <p>A key complexity of this surface is the nutrient pool (see wsimod/nodes/ nutrient_pool.py), which is a class that tracks the amount of phosphorus and nitrogen in different states and performs transformations that occur in the phosphorus/nitrogen cycle. It is assumed that the phosphate/nitrate/nitrite/ ammonia amounts in this Surface tank should track the dissolved inorganic pool in the nutrient pool. Meanwhile, the org-phosphorus/org-nitrogen amounts in this tank should track the dissolved organic pool in the nutrient pool. The total amount of pollutants that enter this tank may not be the same as the total amount that leave, because pollutants are transformed between inorganic/ organic and between wet/dry states - these transformations are accounted for in mass balance.</p> <p>For users to quickly enable/disable these nutrient processes, which are computationally intensive (in current case studies they account for about half of the total runtime), they are only active if 'nitrate' is one of the modelled pollutants. Note that the code will not check if nitrite/phosphate/ org-phosphorus/org-nitrogen/ammonia are also included, but they should be if nitrate is included and otherwise the code will crash with a key error.</p> <p>Parameters:</p> Name Type Description Default <code>rooting_depth</code> <code>float</code> <p>Depth of the soil tank (i.e., how deep do crop roots go). Defaults to 1.</p> <code>1</code> <code>ET_depletion_factor</code> <code>float</code> <p>Average fraction of soil that can be depleted from the root zone before moisture stress (reduction in ET) occurs. Defaults to 1.</p> <code>1</code> <code>crop_factor_stages</code> <code>list</code> <p>Crop factor is a multiplier on et0, more grown plants have higher transpiration and higher crop factors. This list shows changing crop factor at different times of year in relation to crop_factor_stage_dates. See wsimod/preprocessing/ england_data_formatting.py/format_surfaces for further details on formulating these - since the interpolation used to find crop_factors in between the given values in the list is a bit involved. Defaults to [1,1].</p> <code>[1, 1]</code> <code>crop_factor_stage_dates</code> <code>list</code> <p>Dates associated with crop_factor_stages. Defaults to [0, 365].</p> <code>[0, 365]</code> <code>sowing_day</code> <code>int</code> <p>day of year that crops are sown. Defaults to 1.</p> <code>1</code> <code>harvest_day</code> <code>int</code> <p>day of year that crops are harvest. Defaults to 365.</p> <code>365</code> <code>initial_soil_storage</code> <code>dict or float</code> <p>Initial mass of solid</p> <code>None</code> Key assumptions <ul> <li>In the soil water module, crop stages and crop coefficients control the   evapotranspiration.</li> <li>Fertiliser and manure application are the major source of soil nutrients,   which are added    into soil nutrient pools, including dissovled inorganic, dissolved    organic, fast and humus for both nitrogen and phosphorus.</li> <li>Nutrient transformation processes in soil are simulated, including fluxes   between the soil    nutrient pools, denitrification for nitrogen, adsorption/desorption for    phosphorus. These processes are affected by temperature and soil    moisture.</li> <li>Crop uptake of nutrients are simulated based on crop stages, which is   different for spring-sown    and autumn-sown crops.</li> <li>Soil erosion from the growing surface is simulated as one of the major   sources of suspended solids    in rivers, which is mainly affected by rainfall energy and crop/ground    cover. Phosphorus will also be eroded along with the soil particles, in    both adsorbed inorganic and humus form.</li> </ul> Input data and parameter requirements <ul> <li><code>data_input_dict</code> can contain a variety of pollutant deposition data.    <code>srp-fertiliser</code> describes phosphate. <code>noy-fertiliser</code> describes    nitrogen as nitrates. <code>nhx-fertiliser</code> describes nitrogen as ammonia.    <code>srp/noy/ nhx-manure</code> can also be used to specify manure application.    Units: kg/m2/timestep (data is read at a monthly timestep)</li> <li>Rooting depth.    Units: m</li> <li>Evapotranspiration depletion factor.    Units: -</li> <li>Sowing day, harvest day and crop calendars.    Units: day number in Julian calendar</li> <li>Crop factor.    Units: -</li> <li>Initial storage for solid pollutants.    Units: kg</li> </ul> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(\n    self,\n    rooting_depth=1,\n    ET_depletion_factor=1,\n    crop_factor_stages=[1, 1],\n    crop_factor_stage_dates=[0, 365],\n    sowing_day=1,\n    harvest_day=365,\n    initial_soil_storage=None,\n    **kwargs,\n):\n    \"\"\"Extensive surface subclass that implements the CatchWat equations (Liu,\n    Dobson &amp; Mijic (2022) Science of the total environment), which in turn are\n    primarily based on FAO document:\n    https://www.fao.org/3/x0490e/x0490e0ehtm#soil%20water%20availability. This\n    surface is a pervious surface that also has things that grow on it. This\n    behaviour includes soil nutrient pools, crop planting/harvest calendars,\n    erosion, crop behaviour.\n\n    A key complexity of this surface is the nutrient pool (see wsimod/nodes/\n    nutrient_pool.py), which is a class that tracks the amount of phosphorus and\n    nitrogen in different states and performs transformations that occur in the\n    phosphorus/nitrogen cycle. It is assumed that the phosphate/nitrate/nitrite/\n    ammonia amounts in this Surface tank should track the dissolved inorganic pool\n    in the nutrient pool. Meanwhile, the org-phosphorus/org-nitrogen amounts in this\n    tank should track the dissolved organic pool in the nutrient pool. The total\n    amount of pollutants that enter this tank may not be the same as the total\n    amount that leave, because pollutants are transformed between inorganic/ organic\n    and between wet/dry states - these transformations are accounted for in mass\n    balance.\n\n    For users to quickly enable/disable these nutrient processes, which are\n    computationally intensive (in current case studies they account for about half\n    of the total runtime), they are only active if 'nitrate' is one of the modelled\n    pollutants. Note that the code will not check if nitrite/phosphate/\n    org-phosphorus/org-nitrogen/ammonia are also included, but they should be if\n    nitrate is included and otherwise the code will crash with a key error.\n\n    Args:\n        rooting_depth (float, optional): Depth of the soil tank (i.e., how deep do\n            crop roots go). Defaults to 1.\n        ET_depletion_factor (float, optional): Average fraction of soil that can be\n            depleted from the root zone before moisture stress (reduction in ET)\n            occurs. Defaults to 1.\n        crop_factor_stages (list, optional): Crop factor is a multiplier on et0,\n            more grown plants have higher transpiration and higher crop factors.\n            This list shows changing crop factor at different times of year in\n            relation to crop_factor_stage_dates. See wsimod/preprocessing/\n            england_data_formatting.py/format_surfaces for further details on\n            formulating these - since the interpolation used to find crop_factors in\n            between the given values in the list is a bit involved. Defaults to\n            [1,1].\n        crop_factor_stage_dates (list, optional): Dates associated with\n            crop_factor_stages. Defaults to [0, 365].\n        sowing_day (int, optional): day of year that crops are sown. Defaults to 1.\n        harvest_day (int, optional): day of year that crops are harvest. Defaults\n            to 365.\n        initial_soil_storage (dict or float, optional): Initial mass of solid\n        pollutants\n            in the soil nutrient pools (fast and adsorbed inorganic pools)\n\n    Key assumptions:\n         - In the soil water module, crop stages and crop coefficients control the\n           evapotranspiration.\n         - Fertiliser and manure application are the major source of soil nutrients,\n           which are added\n            into soil nutrient pools, including dissovled inorganic, dissolved\n            organic, fast and humus for both nitrogen and phosphorus.\n         - Nutrient transformation processes in soil are simulated, including fluxes\n           between the soil\n            nutrient pools, denitrification for nitrogen, adsorption/desorption for\n            phosphorus. These processes are affected by temperature and soil\n            moisture.\n         - Crop uptake of nutrients are simulated based on crop stages, which is\n           different for spring-sown\n            and autumn-sown crops.\n         - Soil erosion from the growing surface is simulated as one of the major\n           sources of suspended solids\n            in rivers, which is mainly affected by rainfall energy and crop/ground\n            cover. Phosphorus will also be eroded along with the soil particles, in\n            both adsorbed inorganic and humus form.\n\n    Input data and parameter requirements:\n         - `data_input_dict` can contain a variety of pollutant deposition data.\n            `srp-fertiliser` describes phosphate. `noy-fertiliser` describes\n            nitrogen as nitrates. `nhx-fertiliser` describes nitrogen as ammonia.\n            `srp/noy/ nhx-manure` can also be used to specify manure application.\n            _Units_: kg/m2/timestep (data is read at a monthly timestep)\n         - Rooting depth.\n            _Units_: m\n         - Evapotranspiration depletion factor.\n            _Units_: -\n         - Sowing day, harvest day and crop calendars.\n            _Units_: day number in Julian calendar\n         - Crop factor.\n            _Units_: -\n         - Initial storage for solid pollutants.\n            _Units_: kg\n\n    \"\"\"\n    # Crop factors (set when creating object)\n    self.ET_depletion_factor = (\n        ET_depletion_factor  # To do with water availability, p from FAOSTAT\n    )\n    self.rooting_depth = (\n        rooting_depth  # maximum depth that plants can absorb, Zr from FAOSTAT\n    )\n    depth = rooting_depth\n\n    # Crop parameters\n    self.crop_cover_max = 0.9  # [-] 0~1\n    self.ground_cover_max = 0.3  # [-]\n    # TODO... really I should just have this as an annual profile parameter and do\n    # away with interpolation etc.\n    self.crop_factor_stages = crop_factor_stages\n    self.crop_factor_stage_dates = crop_factor_stage_dates\n    self.sowing_day = sowing_day\n    self.harvest_day = harvest_day\n\n    # Soil moisture dependence parameters\n    self.satact = 0.6  # [-] for calculating soil_moisture_dependence_factor\n    self.thetaupp = 0.12  # [-] for calculating soil_moisture_dependence_factor\n    self.thetalow = 0.08  # [-] for calculating soil_moisture_dependence_factor\n    self.thetapow = 1  # [-] for calculating soil_moisture_dependence_factorself.\n    # satact = 0.6 # [-] for calculating soil_moisture_dependence_factor\n\n    # Crop uptake parameters\n    self.uptake1 = (\n        15  # [g/m2/y] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n    )\n    self.uptake2 = (\n        1  # [-] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n    )\n    self.uptake3 = (\n        0.02  # [1/day] shape factor for crop (Dissolved) Inorganic nitrogen uptake\n    )\n    self.uptake_PNratio = 1 / 7.2  # [-] P:N during crop uptake\n\n    # Erosion parameters\n    self.erodibility = 0.0025  # [g * d / (J * mm)]\n    self.sreroexp = 1.2  # [-] surface runoff erosion exponent\n    self.cohesion = 1  # [kPa]\n    self.slope = 5  # [-] every 100\n    self.srfilt = (\n        0.7  # [-] ratio of eroded sediment left in surface runoff after filtration\n    )\n    self.macrofilt = 0.01  # [-] ratio of eroded sediment left in subsurface flow\n    # after filtration\n\n    # Denitrification parameters\n    self.limpar = 0.7  # [-] above which denitrification begins\n    self.exppar = 2.5  # [-] exponential parameter for\n    # soil_moisture_dependence_factor_exp calculation\n    self.hsatINs = 1  # [mg/l] for calculation of half-saturation concentration\n    # dependence factor\n    self.denpar = 0.015  # [-] denitrification rate coefficient\n\n    # Adsorption parameters\n    self.adosorption_nr_limit = 0.00001\n    self.adsorption_nr_maxiter = 20\n    self.kfr = 153.7  # [litter/kg] freundlich adsorption isoterm\n    self.nfr = 1 / 2.6  # [-] freundlich exponential coefficient\n    self.kadsdes = 0.03  # [1/day] adsorption/desorption coefficient\n\n    # Other soil parameters\n    self.bulk_density = 1300  # [kg/m3]\n    super().__init__(depth=depth, **kwargs)\n\n    (\n        self.harvest_sow_calendar,\n        self.ground_cover_stages,\n        self.crop_cover_stages,\n        self.autumn_sow,\n    ) = self.infer_sow_harvest_calendar()\n\n    # State variables\n    self.days_after_sow = None\n    self.crop_cover = 0\n    self.ground_cover = 0\n    self.crop_factor = 0\n    self.et0_coefficient = 1\n\n    (\n        self.total_available_water,\n        self.readily_available_water,\n    ) = self.calculate_available_water()\n\n    # Initiliase nutrient pools\n    self.nutrient_pool = NutrientPool()\n\n    self.inflows.insert(0, self.calc_crop_cover)\n    if \"nitrate\" in constants.POLLUTANTS:\n        # Populate function lists\n        self.inflows.append(self.effective_precipitation_flushing)\n        self.inflows.append(self.fertiliser)\n        self.inflows.append(self.manure)\n        # self.inflows.append(self.residue)\n\n        self.processes.append(self.calc_temperature_dependence_factor)\n        self.processes.append(self.calc_soil_moisture_dependence_factor)\n        self.processes.append(self.soil_pool_transformation)\n        self.processes.append(self.calc_crop_uptake)\n\n        # TODO possibly move these into nutrient pool\n        self.processes.append(self.erosion)\n        self.processes.append(self.denitrification)\n        self.processes.append(self.adsorption)\n\n        # Reflect initial water concentration in dissolved nutrient pools\n        self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"] = self.storage[\n            \"phosphate\"\n        ]\n        self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"] = (\n            self.storage[\"nitrate\"]\n            + self.storage[\"ammonia\"]\n            + self.storage[\"nitrite\"]\n        )\n        self.nutrient_pool.dissolved_organic_pool.storage[\"P\"] = self.storage[\n            \"org-phosphorus\"\n        ]\n        self.nutrient_pool.dissolved_organic_pool.storage[\"N\"] = self.storage[\n            \"org-nitrogen\"\n        ]\n        if initial_soil_storage:\n            self.initial_soil_storage = initial_soil_storage\n            # Reflect initial nutrient stores in solid nutrient pools\n            self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"] = (\n                initial_soil_storage[\"phosphate\"]\n            )\n            self.nutrient_pool.adsorbed_inorganic_pool.storage[\"N\"] = (\n                initial_soil_storage[\"ammonia\"]\n                + initial_soil_storage[\"nitrate\"]\n                + initial_soil_storage[\"nitrite\"]\n            )\n            self.nutrient_pool.fast_pool.storage[\"N\"] = initial_soil_storage[\n                \"org-nitrogen\"\n            ]\n            self.nutrient_pool.fast_pool.storage[\"P\"] = initial_soil_storage[\n                \"org-phosphorus\"\n            ]\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.adjust_vqip_to_liquid","title":"<code>adjust_vqip_to_liquid(vqip, deposition, in_)</code>","text":"<p>Function to interoperate between surface tank and nutrient pool. Most depositions are given in terms of ammonia/nitrate/phosphate - they are then aggregated to total N or P to enter the nutrient pools. Depending on the source of deposition these may transform (e.g., some go to dissolved and some to solids) upon entering the nutrient pool. To reflect these transformations in the soil tank, the amounts entering the soil tank are adjusted proportionately.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of pollutants originally intended to enter the soil tank</p> required <code>deposition</code> <code>dict</code> <p>A dict with nutrients (N and P) as keys, showing the total amount of nutrients entering the nutrient pool</p> required <code>in_</code> <code>dict</code> <p>A dict with nutrients as keys, showing the updated amount of nutrients that entered the nutrient pool as dissolved pollutants</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of pollutants that have been scaled to account for nutrient pool transformations</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def adjust_vqip_to_liquid(self, vqip, deposition, in_):\n    \"\"\"Function to interoperate between surface tank and nutrient pool. Most\n    depositions are given in terms of ammonia/nitrate/phosphate - they are then\n    aggregated to total N or P to enter the nutrient pools. Depending on the source\n    of deposition these may transform (e.g., some go to dissolved and some to\n    solids) upon entering the nutrient pool. To reflect these transformations in the\n    soil tank, the amounts entering the soil tank are adjusted proportionately.\n\n    Args:\n        vqip (dict): A VQIP amount of pollutants originally intended to enter the\n            soil tank\n        deposition (dict): A dict with nutrients (N and P) as keys, showing the\n            total amount of nutrients entering the nutrient pool\n        in_ (dict): A dict with nutrients as keys, showing the updated amount of\n            nutrients that entered the nutrient pool as dissolved pollutants\n\n    Returns:\n        vqip (dict): A VQIP amount of pollutants that have been scaled to account\n            for nutrient pool transformations\n    \"\"\"\n    if \"nitrate\" in constants.POLLUTANTS:\n        if deposition[\"N\"] &gt; 0:\n            vqip[\"nitrate\"] *= in_[\"N\"] / deposition[\"N\"]\n            vqip[\"ammonia\"] *= in_[\"N\"] / deposition[\"N\"]\n            vqip[\"org-nitrogen\"] *= in_[\"N\"] / deposition[\"N\"]\n        if deposition[\"P\"] &gt; 0:\n            vqip[\"phosphate\"] *= in_[\"P\"] / deposition[\"P\"]\n            vqip[\"org-phosphorus\"] *= in_[\"P\"] / deposition[\"P\"]\n\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.adsorption","title":"<code>adsorption()</code>","text":"<p>Outflow function that calculates phosphorus adsorption/desorptions and updates soil tank and nutrient pools.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def adsorption(self):\n    \"\"\"Outflow function that calculates phosphorus adsorption/desorptions and\n    updates soil tank and nutrient pools.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation TODO could this be moved to the\n    # nutrient pool?\n\n    # Initialise mass balance checking\n    in_ = self.empty_vqip()\n    out_ = self.empty_vqip()\n\n    # Get total phosphorus in pool available for adsorption/desorption\n    limit = self.adosorption_nr_limit\n    ad_de_P_pool = (\n        self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"]\n        + self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"]\n    )  # [kg]\n    ad_de_P_pool /= self.area * constants.M2_TO_KM2  # [kg/km2]\n    if ad_de_P_pool == 0:\n        return (self.empty_vqip(), self.empty_vqip())\n\n    # Calculate coefficient and concentration of adsorbed phosphorus\n    soil_moisture_content = (\n        self.get_smc() * constants.M_TO_MM\n    )  # [mm] (not sure why HYPE has this in mm but whatever)\n    conc_sol = (\n        self.nutrient_pool.adsorbed_inorganic_pool.storage[\"P\"]\n        * constants.KG_TO_MG\n        / (self.bulk_density * self.rooting_depth * self.area)\n    )  # [mg P/kg soil]\n    coeff = self.kfr * self.bulk_density * self.rooting_depth  # [mm]\n\n    # calculate equilibrium concentration\n    if conc_sol &lt;= 0:\n        # Not sure how this would happen\n        print(\"Warning: soil partP &lt;=0. Freundlich will give error, take shortcut.\")\n        xn_1 = ad_de_P_pool / (soil_moisture_content + coeff)  # [mg/l]\n        ad_P_equi_conc = self.kfr * xn_1  # [mg/ kg]\n    else:\n        # Newton-Raphson method\n        x0 = exp(\n            (log(conc_sol) - log(self.kfr)) / self.nfr\n        )  # initial guess of equilibrium liquid concentration\n        fxn = x0 * soil_moisture_content + coeff * (x0**self.nfr) - ad_de_P_pool\n        xn = x0\n        xn_1 = xn\n        j = 0\n        while (\n            abs(fxn) &gt; limit and j &lt; self.adsorption_nr_maxiter\n        ):  # iteration to calculate equilibrium concentations\n            fxn = xn * soil_moisture_content + coeff * (xn**self.nfr) - ad_de_P_pool\n            fprimxn = soil_moisture_content + self.nfr * coeff * (\n                xn ** (self.nfr - 1)\n            )\n            dx = fxn / fprimxn\n            if abs(dx) &lt; (0.000001 * xn):\n                # From HYPE... not sure what it means\n                break\n            xn_1 = xn - dx\n            if xn_1 &lt;= 0:\n                xn_1 = 1e-10\n            xn = xn_1\n            j += 1\n        ad_P_equi_conc = self.kfr * (xn_1**self.nfr)\n        # print(ad_P_equi_conc, conc_sol)\n\n    # Calculate new pool and concentration, depends on the equilibrium concentration\n    if abs(ad_P_equi_conc - conc_sol) &gt; 1e-6:\n        request = self.nutrient_pool.get_empty_nutrient()\n\n        # TODO not sure about this if statement, surely it would be triggered every\n        # time\n        adsdes = (ad_P_equi_conc - conc_sol) * (\n            1 - exp(-self.kadsdes)\n        )  # kinetic adsorption/desorption\n        request[\"P\"] = (\n            adsdes\n            * self.bulk_density\n            * self.rooting_depth\n            * (self.area * constants.M2_TO_KM2)\n        )  # [kg]\n        if request[\"P\"] &gt; 0:\n            # Adsorption\n            adsorbed = self.nutrient_pool.dissolved_inorganic_pool.extract(request)\n            if (adsorbed[\"P\"] - request[\"P\"]) &gt; constants.FLOAT_ACCURACY:\n                print(\"Warning: freundlich flow adjusted, was larger than pool\")\n            self.nutrient_pool.adsorbed_inorganic_pool.receive(adsorbed)\n\n            # Dissolved leaving the soil water tank and becoming solid\n            out_[\"phosphate\"] = adsorbed[\"P\"]\n\n            # Update tank\n            out2_ = self.pull_pollutants(out_)\n            if not self.compare_vqip(out_, out2_):\n                print(\"nutrient pool not tracking soil tank\")\n        else:\n            # Desorption\n            request[\"P\"] = -request[\"P\"]\n            desorbed = self.nutrient_pool.adsorbed_inorganic_pool.extract(request)\n            if (desorbed[\"P\"] - request[\"P\"]) &gt; constants.FLOAT_ACCURACY:\n                print(\"Warning: freundlich flow adjusted, was larger than pool\")\n            self.nutrient_pool.dissolved_inorganic_pool.receive(desorbed)\n\n            # Solid phosphorus becoming inorganic P in the soil water tank\n            in_[\"phosphate\"] = desorbed[\"P\"]\n            _ = self.push_storage(in_, force=True)\n\n    return (in_, out_)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        overwrite_params = [\n            \"ET_depletion_factor\",\n            \"crop_cover_max\",\n            \"ground_cover_max\",\n            \"crop_factor_stages\",\n            \"crop_factor_stage_dates\",\n            \"sowing_day\",\n            \"harvest_day\",\n            \"satact\",\n            \"thetaupp\",\n            \"thetalow\",\n            \"thetapow\",\n            \"uptake1\",\n            \"uptake2\",\n            \"uptake3\",\n            \"uptake_PNratio\",\n            \"erodibility\",\n            \"sreroexp\",\n            \"cohesion\",\n            \"slope\",\n            \"srfilt\",\n            \"macrofilt\",\n            \"limpar\",\n            \"exppar\",\n            \"hsatINs\",\n            \"denpar\",\n            \"adosorption_nr_limit\",\n            \"adsorption_nr_maxiter\",\n            \"kfr\",\n            \"nfr\",\n            \"kadsdes\",\n            \"bulk_density\",\n        ]\n        for param in overwrite_params:\n            setattr(self, param, overrides.pop(param, getattr(self, param)))\n\n        if \"depth\" in overrides.keys():\n            overrides.pop(\"depth\")\n            print(\n                \"ERROR: specifying depth is depreciated in overrides for \\\n\t\tGrowingSurface, please specify rooting_depth instead\"\n            )\n        self.rooting_depth = overrides.pop(\"rooting_depth\", self.rooting_depth)\n        overrides[\"depth\"] = self.rooting_depth\n        super().apply_overrides(overrides)\n\n        (\n            self.harvest_sow_calendar,\n            self.ground_cover_stages,\n            self.crop_cover_stages,\n            self.autumn_sow,\n        ) = self.infer_sow_harvest_calendar()\n        (\n            self.total_available_water,\n            self.readily_available_water,\n        ) = self.calculate_available_water()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.calc_crop_cover","title":"<code>calc_crop_cover()</code>","text":"<p>Process function that calculates how much crop cover there is, assigns whether crops are sown/harvested, and calculates et0_coefficient based on growth stage of crops.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calc_crop_cover(self):\n    \"\"\"Process function that calculates how much crop cover there is, assigns\n    whether crops are sown/harvested, and calculates et0_coefficient based on growth\n    stage of crops.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Get current day of year\n    doy = self.parent.t.dayofyear\n\n    if self.parent.t.is_leap_year:\n        # Hacky way to handle leap years\n        if doy &gt; 59:\n            doy -= 1\n\n    if self.days_after_sow is None:\n        if self.parent.t.dayofyear == self.sowing_day:\n            # sow\n            self.days_after_sow = 0\n    else:\n        if self.parent.t.dayofyear == self.harvest_day:\n            # harvest\n            self.days_after_sow = None\n            self.crop_factor = self.crop_factor_stages[0]\n            self.crop_cover = 0\n            self.ground_cover = 0\n        else:\n            # increment days since sow\n            self.days_after_sow += 1\n\n    # Calculate relevant parameters\n    self.crop_factor = self.quick_interp(\n        doy, self.crop_factor_stage_dates, self.crop_factor_stages\n    )\n    if self.days_after_sow:\n        # Move outside of this if, if you want nonzero crop/ground cover outside of\n        # season\n        self.crop_cover = self.quick_interp(\n            doy, self.harvest_sow_calendar, self.crop_cover_stages\n        )\n        self.ground_cover = self.quick_interp(\n            doy, self.harvest_sow_calendar, self.ground_cover_stages\n        )\n\n    root_zone_depletion = max(self.field_capacity_m - self.get_smc(), 0)\n    if root_zone_depletion &lt; self.readily_available_water:\n        crop_water_stress_coefficient = 1\n    else:\n        crop_water_stress_coefficient = max(\n            0,\n            (self.total_available_water - root_zone_depletion)\n            / ((1 - self.ET_depletion_factor) * self.total_available_water),\n        )\n\n    self.et0_coefficient = crop_water_stress_coefficient * self.crop_factor\n\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.calc_crop_uptake","title":"<code>calc_crop_uptake()</code>","text":"<p>Process function that calculates how much nutrient crops uptake and updates nutrient pool and surface tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calc_crop_uptake(self):\n    \"\"\"Process function that calculates how much nutrient crops uptake and updates\n    nutrient pool and surface tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation\n\n    # Initialise\n    N_common_uptake = 0\n    P_common_uptake = 0\n\n    if self.days_after_sow:\n        # If there are crops\n\n        days_after_sow = self.days_after_sow\n\n        if self.autumn_sow:\n            temp_func = max(0, min(1, (self.storage[\"temperature\"] - 5) / 20))\n            days_after_sow -= 25  # Not sure why this is (but it's in HYPE)\n        else:\n            temp_func = 1\n\n        # Calculate uptake\n        uptake_par = (self.uptake1 - self.uptake2) * exp(\n            -self.uptake3 * days_after_sow\n        )\n        if (uptake_par + self.uptake2) &gt; 0:\n            N_common_uptake = (\n                self.uptake1\n                * self.uptake2\n                * self.uptake3\n                * uptake_par\n                / ((self.uptake2 + uptake_par) ** 2)\n            )\n        N_common_uptake *= temp_func * constants.G_M2_TO_KG_M2 * self.area  # [kg]\n        P_common_uptake = N_common_uptake * self.uptake_PNratio\n        # calculate maximum available uptake\n        N_maximum_available_uptake = (\n            max(0, self.storage[\"volume\"] - self.wilting_point_m * self.area)\n            / self.storage[\"volume\"]\n            * self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n        )\n        P_maximum_available_uptake = (\n            max(0, self.storage[\"volume\"] - self.wilting_point_m * self.area)\n            / self.storage[\"volume\"]\n            * self.nutrient_pool.dissolved_inorganic_pool.storage[\"P\"]\n        )\n\n        uptake = {\n            \"P\": min(P_common_uptake, P_maximum_available_uptake),\n            \"N\": min(N_common_uptake, N_maximum_available_uptake),\n        }\n        crop_uptake = self.nutrient_pool.dissolved_inorganic_pool.extract(uptake)\n        out_ = self.empty_vqip()\n\n        # Assuming plants eat N and P as nitrate and phosphate\n        out_[\"nitrate\"] = crop_uptake[\"N\"]\n        out_[\"phosphate\"] = crop_uptake[\"P\"]\n\n        out2_ = self.pull_pollutants(out_)\n        if not self.compare_vqip(out_, out2_):\n            print(\"nutrient pool not tracking soil tank\")\n\n        return (self.empty_vqip(), out_)\n    else:\n        return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.calc_soil_moisture_dependence_factor","title":"<code>calc_soil_moisture_dependence_factor()</code>","text":"<p>Process function that calculates the soil moisture dependence factor for the nutrient pool (which impacts soil pool transformations).</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calc_soil_moisture_dependence_factor(self):\n    \"\"\"Process function that calculates the soil moisture dependence factor for the\n    nutrient pool (which impacts soil pool transformations).\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation\n    current_soil_moisture = self.get_smc()\n    if current_soil_moisture &gt;= self.field_capacity_m:\n        self.nutrient_pool.soil_moisture_dependence_factor = self.satact\n    elif current_soil_moisture &lt;= self.wilting_point_m:\n        self.nutrient_pool.soil_moisture_dependence_factor = 0\n    else:\n        fc_diff = self.field_capacity_m - current_soil_moisture\n        fc_comp = (fc_diff / (self.thetaupp * self.rooting_depth)) ** self.thetapow\n        fc_comp = (1 - self.satact) * fc_comp + self.satact\n        wp_diff = current_soil_moisture - self.wilting_point_m\n        wp_comp = (wp_diff / (self.thetalow * self.rooting_depth)) ** self.thetapow\n        self.nutrient_pool.soil_moisture_dependence_factor = min(\n            1, wp_comp, fc_comp\n        )\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.calc_temperature_dependence_factor","title":"<code>calc_temperature_dependence_factor()</code>","text":"<p>Process function that calculates the temperature dependence factor for the nutrient pool (which impacts soil pool transformations).</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calc_temperature_dependence_factor(self):\n    \"\"\"Process function that calculates the temperature dependence factor for the\n    nutrient pool (which impacts soil pool transformations).\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation\n    if self.storage[\"temperature\"] &gt; 5:\n        temperature_dependence_factor = 2 ** (\n            (self.storage[\"temperature\"] - 20) / 10\n        )\n    elif self.storage[\"temperature\"] &gt; 0:\n        temperature_dependence_factor = self.storage[\"temperature\"] / 5\n    else:\n        temperature_dependence_factor = 0\n    self.nutrient_pool.temperature_dependence_factor = temperature_dependence_factor\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.calculate_available_water","title":"<code>calculate_available_water()</code>","text":"<p>Calculate total/readily available water based on capacity/wp. Returns:     (float): total available water     (float): readily available water</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calculate_available_water(self):\n    \"\"\"Calculate total/readily available water based on capacity/wp.\n    Returns:\n        (float): total available water\n        (float): readily available water\n    \"\"\"\n    # Calculate parameters based on capacity/wp\n    total_available_water = self.field_capacity_m - self.wilting_point_m\n    if total_available_water &lt; 0:\n        print(\"warning: TAW &lt; 0...\")\n    readily_available_water = total_available_water * self.ET_depletion_factor\n\n    return total_available_water, readily_available_water\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.denitrification","title":"<code>denitrification()</code>","text":"<p>Outflow function that performs denitirication processes, updating nutrient pool and soil tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def denitrification(self):\n    \"\"\"Outflow function that performs denitirication processes, updating nutrient\n    pool and soil tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation TODO could more of this be moved\n    # to NutrientPool Calculate soil moisture dependence of denitrification\n    soil_moisture_content = self.get_smc()\n    if soil_moisture_content &gt; self.field_capacity_m:\n        denitrifying_soil_moisture_dependence = 1\n    elif soil_moisture_content / self.field_capacity_m &gt; self.limpar:\n        denitrifying_soil_moisture_dependence = (\n            ((soil_moisture_content / self.field_capacity_m) - self.limpar)\n            / (1 - self.limpar)\n        ) ** self.exppar\n    else:\n        denitrifying_soil_moisture_dependence = 0\n        return (self.empty_vqip(), self.empty_vqip())\n\n    # Get dissolved inorg nitrogen as a concentration and calculate factor\n    din_conc = (\n        self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n        / self.storage[\"volume\"]\n    )  # [kg/m3]\n    din_conc *= constants.KG_M3_TO_MG_L\n    half_saturation_concentration_dependence_factor = din_conc / (\n        din_conc + self.hsatINs\n    )\n\n    # Calculate and extract dentrified nitrogen\n    denitrified_N = (\n        self.nutrient_pool.dissolved_inorganic_pool.storage[\"N\"]\n        * half_saturation_concentration_dependence_factor\n        * denitrifying_soil_moisture_dependence\n        * self.nutrient_pool.temperature_dependence_factor\n        * self.denpar\n    )\n    denitrified_request = self.nutrient_pool.get_empty_nutrient()\n    denitrified_request[\"N\"] = denitrified_N\n    denitrified_N = self.nutrient_pool.dissolved_inorganic_pool.extract(\n        denitrified_request\n    )\n\n    # Leon reckons this should leave the model (though I think technically some\n    # small amount goes to nitrite)\n    out_ = self.empty_vqip()\n    out_[\"nitrate\"] = denitrified_N[\"N\"]\n\n    # Update tank\n    out2_ = self.pull_pollutants(out_)\n    if not self.compare_vqip(out_, out2_):\n        print(\"nutrient pool not tracking soil tank\")\n\n    return (self.empty_vqip(), out_)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.dry_deposition_to_tank","title":"<code>dry_deposition_to_tank(vqip)</code>","text":"<p>Allocate dry deposition to surface tank, updating nutrient pool accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition to send to tank</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition that entered the tank (used for mass balance checking)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def dry_deposition_to_tank(self, vqip):\n    \"\"\"Allocate dry deposition to surface tank, updating nutrient pool accordingly.\n\n    Args:\n        vqip (dict): A VQIP amount of dry deposition to send to tank\n\n    Returns:\n        vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n            for mass balance checking)\n    \"\"\"\n    # Convert to nutrients\n    deposition = self.nutrient_pool.get_empty_nutrient()\n    deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n    deposition[\"P\"] = vqip[\"phosphate\"]\n\n    # Update nutrient pool\n    in_ = self.nutrient_pool.allocate_dry_deposition(deposition)\n    vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n    # Update tank\n    self.push_storage(vqip, force=True)\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.effective_precipitation_flushing","title":"<code>effective_precipitation_flushing()</code>","text":"<p>Remove the nutrients brought out by effective precipitation, which is surface runoff, subsurface runoff, and percolation, from the nutrients pool.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs     for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def effective_precipitation_flushing(self):\n    \"\"\"Remove the nutrients brought out by effective precipitation, which is surface\n    runoff, subsurface runoff, and percolation, from the nutrients pool.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n    \"\"\"\n    # inorganic\n    out = self.nutrient_pool.get_empty_nutrient()\n    out[\"N\"] = (\n        self.subsurface_flow[\"ammonia\"]\n        + self.subsurface_flow[\"nitrite\"]\n        + self.subsurface_flow[\"nitrate\"]\n        + self.percolation[\"ammonia\"]\n        + self.percolation[\"nitrite\"]\n        + self.percolation[\"nitrate\"]\n        + self.infiltration_excess[\"ammonia\"]\n        + self.infiltration_excess[\"nitrite\"]\n        + self.infiltration_excess[\"nitrate\"]\n    )  # TODO what happens if infiltration excess (the real part) has pollutants?\n    out[\"P\"] = (\n        self.subsurface_flow[\"phosphate\"]\n        + self.percolation[\"phosphate\"]\n        + self.infiltration_excess[\"phosphate\"]\n    )\n    self.nutrient_pool.dissolved_inorganic_pool.extract(out)\n\n    # organic\n    out = self.nutrient_pool.get_empty_nutrient()\n    out[\"N\"] = (\n        self.subsurface_flow[\"org-nitrogen\"]\n        + self.percolation[\"org-nitrogen\"]\n        + self.infiltration_excess[\"org-nitrogen\"]\n    )\n    out[\"P\"] = (\n        self.subsurface_flow[\"org-phosphorus\"]\n        + self.percolation[\"org-phosphorus\"]\n        + self.infiltration_excess[\"org-phosphorus\"]\n    )\n    self.nutrient_pool.dissolved_organic_pool.extract(out)\n\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.erosion","title":"<code>erosion()</code>","text":"<p>Outflow function that erodes adsorbed/humus phosphorus and sediment and sends onwards to percolation/surface runoff/subsurface runoff.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def erosion(self):\n    \"\"\"Outflow function that erodes adsorbed/humus phosphorus and sediment and sends\n    onwards to percolation/surface runoff/subsurface runoff.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Parameters/equations from HYPE documentation (which explains why my\n    # documentation is a bit ambiguous - because theirs is too)\n\n    # Convert precipitation to MM since all the equations assume that\n    precipitation_depth = self.get_data_input(\"precipitation\") * constants.M_TO_MM\n\n    # Calculate how much rain is mobilising erosion\n    if precipitation_depth &gt; 5:\n        rainfall_energy = 8.95 + 8.44 * log10(\n            precipitation_depth\n            * (\n                0.257\n                + sin(2 * constants.PI * ((self.parent.t.dayofyear - 70) / 365))\n                * 0.09\n            )\n            * 2\n        )\n        rainfall_energy *= precipitation_depth\n        mobilised_rain = rainfall_energy * (1 - self.crop_cover) * self.erodibility\n    else:\n        mobilised_rain = 0\n\n    # Calculate if any infiltration is mobilising erosion\n    if self.infiltration_excess[\"volume\"] &gt; 0:\n        mobilised_flow = (\n            self.infiltration_excess[\"volume\"] / self.area * constants.M_TO_MM * 365\n        ) ** self.sreroexp\n        mobilised_flow *= (\n            (1 - self.ground_cover)\n            * (1 / (0.5 * self.cohesion))\n            * sin(self.slope / 100)\n            / 365\n        )\n    else:\n        mobilised_flow = 0\n\n    # Sum flows (not sure why surface runoff isn't included) TODO I'm pretty sure it\n    # should be included here\n    total_flows = (\n        self.infiltration_excess[\"volume\"]\n        + self.subsurface_flow[\"volume\"]\n        + self.percolation[\"volume\"]\n    )  # m3/dt + self.tank_recharge['volume'] (guess not needed)\n\n    # Convert to MM/M2\n    erodingflow = total_flows / self.area * constants.M_TO_MM\n\n    # Calculate eroded sediment\n    transportfactor = min(1, (erodingflow / 4) ** 1.3)\n    erodedsed = (\n        1000 * (mobilised_flow + mobilised_rain) * transportfactor\n    )  # [kg/km2]\n    # TODO not sure what conversion this HYPE 1000 is referring to\n\n    # soil erosion with adsorbed inorganic phosphorus and humus phosphorus (erodedP\n    # as P in eroded sediments and effect of enrichment)\n    if erodingflow &gt; 4:\n        enrichment = 1.5\n    elif erodingflow &gt; 0:\n        enrichment = 4 - (4 - 1.5) * erodingflow / 4\n    else:\n        return (self.empty_vqip(), self.empty_vqip())\n\n    # Get erodable phosphorus\n    erodableP = (\n        self.nutrient_pool.get_erodable_P() / self.area * constants.KG_M2_TO_KG_KM2\n    )\n    erodedP = (\n        erodedsed\n        * (\n            erodableP\n            / (\n                self.rooting_depth\n                * constants.M_TO_KM\n                * self.bulk_density\n                * constants.KG_M3_TO_KG_KM3\n            )\n        )\n        * enrichment\n    )  # [kg/km2]\n\n    # Convert to kg\n    erodedP *= self.area * constants.M2_TO_KM2  # [kg]\n    erodedsed *= self.area * constants.M2_TO_KM2  # [kg]\n\n    # Allocate to different flows\n    surface_erodedP = (\n        self.srfilt * self.infiltration_excess[\"volume\"] / total_flows * erodedP\n    )  # [kg]\n    surface_erodedsed = (\n        self.srfilt * self.infiltration_excess[\"volume\"] / total_flows * erodedsed\n    )  # [kg]\n\n    subsurface_erodedP = (\n        self.macrofilt * self.subsurface_flow[\"volume\"] / total_flows * erodedP\n    )  # [kg]\n    subsurface_erodedsed = (\n        self.macrofilt * self.subsurface_flow[\"volume\"] / total_flows * erodedsed\n    )  # [kg]\n\n    percolation_erodedP = (\n        self.macrofilt * self.percolation[\"volume\"] / total_flows * erodedP\n    )  # [kg]\n    percolation_erodedsed = (\n        self.macrofilt * self.percolation[\"volume\"] / total_flows * erodedsed\n    )  # [kg]\n\n    # Track mass balance\n    in_ = self.empty_vqip()\n\n    # Total eroded phosphorus\n    eff_erodedP = percolation_erodedP + surface_erodedP + subsurface_erodedP  # [kg]\n    if eff_erodedP &gt; 0:\n        # Update nutrient pool\n        org_removed, inorg_removed = self.nutrient_pool.erode_P(eff_erodedP)\n        total_removed = inorg_removed + org_removed\n\n        if abs(total_removed - eff_erodedP) &gt; constants.FLOAT_ACCURACY:\n            print(\"weird nutrients\")\n\n        # scale flows to split between inorganic and organic eroded P\n        self.infiltration_excess[\"org-phosphorus\"] += (\n            surface_erodedP * org_removed / eff_erodedP\n        )\n        self.subsurface_flow[\"org-phosphorus\"] += (\n            subsurface_erodedP * org_removed / eff_erodedP\n        )\n        self.percolation[\"org-phosphorus\"] += (\n            percolation_erodedP * org_removed / eff_erodedP\n        )\n\n        # TODO Leon reckons this is conceptually dodgy.. but i'm not sure where else\n        # adsorbed inorganic phosphorus should go\n        self.infiltration_excess[\"phosphate\"] += (\n            surface_erodedP * inorg_removed / eff_erodedP\n        )\n        self.subsurface_flow[\"phosphate\"] += (\n            subsurface_erodedP * inorg_removed / eff_erodedP\n        )\n        self.percolation[\"phosphate\"] += (\n            percolation_erodedP * inorg_removed / eff_erodedP\n        )\n\n        # Entering the model (no need to uptake surface tank because both adsorbed\n        # inorganic pool and humus pool are solids and so no tracked in the soil\n        # water tank)\n        in_[\"phosphate\"] = inorg_removed\n        in_[\"org-phosphorus\"] = org_removed\n    else:\n        pass\n\n    # Track sediment as solids\n    self.infiltration_excess[\"solids\"] += surface_erodedsed\n    self.subsurface_flow[\"solids\"] += subsurface_erodedsed\n    self.percolation[\"solids\"] += percolation_erodedsed\n\n    in_[\"solids\"] = surface_erodedsed + subsurface_erodedsed + percolation_erodedsed\n\n    return (in_, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.fertiliser","title":"<code>fertiliser()</code>","text":"<p>Read, scale and allocate fertiliser, updating the tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def fertiliser(self):\n    \"\"\"Read, scale and allocate fertiliser, updating the tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # TODO tidy up fertiliser/manure/residue/deposition once preprocessing is sorted\n\n    # Scale for surface\n    nhx = self.get_data_input_surface(\"nhx-fertiliser\") * self.area\n    noy = self.get_data_input_surface(\"noy-fertiliser\") * self.area\n    srp = self.get_data_input_surface(\"srp-fertiliser\") * self.area\n\n    # Update as VQIP\n    vqip = self.empty_vqip()\n    vqip[\"ammonia\"] = nhx\n    vqip[\"nitrate\"] = noy\n    vqip[\"phosphate\"] = srp\n\n    # Enter nutrient pool\n    deposition = self.nutrient_pool.get_empty_nutrient()\n    deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n    deposition[\"P\"] = vqip[\"phosphate\"]\n    in_ = self.nutrient_pool.allocate_fertiliser(deposition)\n\n    # Update tank\n    vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n    self.push_storage(vqip, force=True)\n\n    return (vqip, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.infer_sow_harvest_calendar","title":"<code>infer_sow_harvest_calendar()</code>","text":"<p>Infer basic sow/harvest calendar and indicate autumn-sown. Returns:     (list): havest/sow calendar     (list): ground cover stages     (list): crop cover stages     (boolean): indication for autumn-sown crops</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def infer_sow_harvest_calendar(self):\n    \"\"\"Infer basic sow/harvest calendar and indicate autumn-sown.\n    Returns:\n        (list): havest/sow calendar\n        (list): ground cover stages\n        (list): crop cover stages\n        (boolean): indication for autumn-sown crops\n    \"\"\"\n    # Infer basic sow/harvest calendar\n    harvest_sow_calendar = [\n        0,\n        self.sowing_day,\n        self.harvest_day,\n        self.harvest_day + 1,\n        365,\n    ]\n    ground_cover_stages = [0, 0, self.ground_cover_max, 0, 0]\n    crop_cover_stages = [0, 0, self.crop_cover_max, 0, 0]\n\n    # Use day number of 181 to indicate autumn-sown (from HYPE)\n    if self.sowing_day &gt; 181:\n        autumn_sow = True\n    else:\n        autumn_sow = False\n\n    return harvest_sow_calendar, ground_cover_stages, crop_cover_stages, autumn_sow\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.manure","title":"<code>manure()</code>","text":"<p>Read, scale and allocate manure, updating the tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def manure(self):\n    \"\"\"Read, scale and allocate manure, updating the tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Scale for surface\n    nhx = self.get_data_input_surface(\"nhx-manure\") * self.area\n    noy = self.get_data_input_surface(\"noy-manure\") * self.area\n    srp = self.get_data_input_surface(\"srp-manure\") * self.area\n\n    # Formulate as VQIP\n    vqip = self.empty_vqip()\n    vqip[\"ammonia\"] = nhx\n    vqip[\"nitrate\"] = noy\n    vqip[\"phosphate\"] = srp\n\n    # Enter nutrient pool\n    deposition = self.nutrient_pool.get_empty_nutrient()\n    deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n    deposition[\"P\"] = vqip[\"phosphate\"]\n    in_ = self.nutrient_pool.allocate_manure(deposition)\n\n    # Update tank\n    vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n    self.push_storage(vqip, force=True)\n\n    return (vqip, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.pull_storage","title":"<code>pull_storage(vqip)</code>","text":"<p>Pull water from the surface, updating the surface storage VQIP. Nutrient pool pollutants (nitrate/nitrite/ammonia/phosphate/org- phosphorus/ org-nitrogen) are removed in proportion to their amounts in the dissolved nutrient pools, if they are simulated. Other pollutants are removed in proportion to their amount in the surface tank.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>VQIP amount to be pulled, (only 'volume' key is needed)</p> required <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>A VQIP amount successfully pulled from the tank</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def pull_storage(self, vqip):\n    \"\"\"Pull water from the surface, updating the surface storage VQIP. Nutrient pool\n    pollutants (nitrate/nitrite/ammonia/phosphate/org- phosphorus/ org-nitrogen) are\n    removed in proportion to their amounts in the dissolved nutrient pools, if they\n    are simulated. Other pollutants are removed in proportion to their amount in the\n    surface tank.\n\n    Args:\n        vqip (dict): VQIP amount to be pulled, (only 'volume' key is needed)\n\n    Returns:\n        reply (dict): A VQIP amount successfully pulled from the tank\n    \"\"\"\n    if self.storage[\"volume\"] == 0:\n        return self.empty_vqip()\n\n    # Adjust based on available volume\n    reply = min(vqip[\"volume\"], self.storage[\"volume\"])\n\n    # Update reply to vqip (get concentration for non-nutrients)\n    reply = self.v_change_vqip(self.storage, reply)\n\n    if \"nitrate\" in constants.POLLUTANTS:\n        # Update nutrient pool and get concentration for nutrients\n        prop = reply[\"volume\"] / self.storage[\"volume\"]\n        nutrients = self.nutrient_pool.extract_dissolved(prop)\n        reply[\"nitrate\"] = (\n            nutrients[\"inorganic\"][\"N\"]\n            * self.storage[\"nitrate\"]\n            / (\n                self.storage[\"nitrate\"]\n                + self.storage[\"ammonia\"]\n                + self.storage[\"nitrite\"]\n            )\n        )\n        reply[\"ammonia\"] = (\n            nutrients[\"inorganic\"][\"N\"]\n            * self.storage[\"ammonia\"]\n            / (\n                self.storage[\"nitrate\"]\n                + self.storage[\"ammonia\"]\n                + self.storage[\"nitrite\"]\n            )\n        )\n        reply[\"nitrite\"] = (\n            nutrients[\"inorganic\"][\"N\"]\n            * self.storage[\"nitrite\"]\n            / (\n                self.storage[\"nitrate\"]\n                + self.storage[\"ammonia\"]\n                + self.storage[\"nitrite\"]\n            )\n        )\n        reply[\"phosphate\"] = nutrients[\"inorganic\"][\"P\"]\n        reply[\"org-phosphorus\"] = nutrients[\"organic\"][\"P\"]\n        reply[\"org-nitrogen\"] = nutrients[\"organic\"][\"N\"]\n\n    # Extract from storage\n    self.storage = self.extract_vqip(self.storage, reply)\n\n    return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.quick_interp","title":"<code>quick_interp(x, xp, yp)</code>","text":"<p>A simple version of np.interp to intepolate crop information on the fly.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>int</code> <p>Current time (i.e., day of year) xp (list): Predefined times (i.e.,</p> required <code>list of days of year) yp</code> <code>list</code> <p>Predefined values associated with xp</p> required <p>Returns:</p> Name Type Description <code>y</code> <code>float</code> <p>Interpolated value for current time</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def quick_interp(self, x, xp, yp):\n    \"\"\"A simple version of np.interp to intepolate crop information on the fly.\n\n    Args:\n        x (int): Current time (i.e., day of year) xp (list): Predefined times (i.e.,\n        list of days of year) yp (list): Predefined values associated with xp\n\n    Returns:\n        y (float): Interpolated value for current time\n    \"\"\"\n    x_ind = bisect_left(xp, x)\n    x_left = xp[x_ind - 1]\n    x_right = xp[x_ind]\n    dif = x - x_left\n    y_left = yp[x_ind - 1]\n    y_right = yp[x_ind]\n    y = y_left + (y_right - y_left) * dif / (x_right - x_left)\n    return y\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.residue","title":"<code>residue()</code>","text":"<p>Read, scale and allocate residue, updating the tank (NOT CURRENTLY USED BECAUSE NO DATA SOURCES FOR RESIDUE CAN BE IDENTIFIED).</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def residue(self):\n    \"\"\"Read, scale and allocate residue, updating the tank (NOT CURRENTLY USED\n    BECAUSE NO DATA SOURCES FOR RESIDUE CAN BE IDENTIFIED).\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    nhx = self.get_data_input_surface(\"nhx-residue\") * self.area\n    noy = self.get_data_input_surface(\"noy-residue\") * self.area\n    srp = self.get_data_input_surface(\"srp-residue\") * self.area\n\n    vqip = self.empty_vqip()\n    vqip[\"ammonia\"] = nhx * self.nutrient_pool.fraction_residue_to_fast[\"N\"]\n    vqip[\"nitrate\"] = noy * self.nutrient_pool.fraction_residue_to_fast[\"N\"]\n    vqip[\"org-nitrogen\"] = (\n        nhx + noy\n    ) * self.nutrient_pool.fraction_residue_to_humus[\"N\"]\n    vqip[\"phosphate\"] = srp * self.nutrient_pool.fraction_residue_to_fast[\"P\"]\n    vqip[\"org-phosphorus\"] = srp * self.nutrient_pool.fraction_residue_to_humus[\"P\"]\n\n    deposition = self.nutrient_pool.get_empty_nutrient()\n    deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"] + vqip[\"org-nitrogen\"]\n    deposition[\"P\"] = vqip[\"phosphate\"] + vqip[\"org-phosphorus\"]\n\n    in_ = self.nutrient_pool.allocate_residue(deposition)\n    vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n    self.push_storage(vqip, force=True)\n\n    return (vqip, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.soil_pool_transformation","title":"<code>soil_pool_transformation()</code>","text":"<p>A process function that run transformation functions in the nutrient pool and updates the pollutant concentrations in the surface tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def soil_pool_transformation(self):\n    \"\"\"A process function that run transformation functions in the nutrient pool and\n    updates the pollutant concentrations in the surface tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Initialise mass balance tracking variables\n    in_ = self.empty_vqip()\n    out_ = self.empty_vqip()\n\n    # Get proportion of nitrogen that is nitrate in the soil tank NOTE ignores\n    # nitrite - couldn't find enough information on it\n    nitrate_proportion = self.storage[\"nitrate\"] / (\n        self.storage[\"nitrate\"] + self.storage[\"ammonia\"]\n    )\n\n    # Run soil pool functions\n    (\n        increase_in_dissolved_inorganic,\n        increase_in_dissolved_organic,\n    ) = self.nutrient_pool.soil_pool_transformation()\n\n    # Update tank and mass balance TODO .. there is definitely a neater way to write\n    # this\n    if increase_in_dissolved_inorganic[\"N\"] &gt; 0:\n        # Increase in inorganic nitrogen, rescale back to nitrate and ammonia\n        in_[\"nitrate\"] = increase_in_dissolved_inorganic[\"N\"] * nitrate_proportion\n        in_[\"ammonia\"] = increase_in_dissolved_inorganic[\"N\"] * (\n            1 - nitrate_proportion\n        )\n    else:\n        # Decrease in inorganic nitrogen, rescale back to nitrate and ammonia\n        out_[\"nitrate\"] = -increase_in_dissolved_inorganic[\"N\"] * nitrate_proportion\n        out_[\"ammonia\"] = -increase_in_dissolved_inorganic[\"N\"] * (\n            1 - nitrate_proportion\n        )\n\n    if increase_in_dissolved_organic[\"N\"] &gt; 0:\n        # Increase in organic nitrogen\n        in_[\"org-nitrogen\"] = increase_in_dissolved_organic[\"N\"]\n    else:\n        # Decrease in organic nitrogen\n        out_[\"org-nitrogen\"] = -increase_in_dissolved_organic[\"N\"]\n\n    if increase_in_dissolved_inorganic[\"P\"] &gt; 0:\n        # Increase in inorganic phosphate\n        in_[\"phosphate\"] = increase_in_dissolved_inorganic[\"P\"]\n    else:\n        # Decrease in inorganic phosphate\n        out_[\"phosphate\"] = -increase_in_dissolved_inorganic[\"P\"]\n\n    if increase_in_dissolved_organic[\"P\"] &gt; 0:\n        # Increase in organic phosphorus\n        in_[\"org-phosphorus\"] = increase_in_dissolved_organic[\"P\"]\n    else:\n        # Decrease in organic phosphorus\n        out_[\"org-phosphorus\"] = -increase_in_dissolved_organic[\"P\"]\n\n    # Update tank with inputs/outputs of pollutants\n    _ = self.push_storage(in_, force=True)\n    out2_ = self.pull_pollutants(out_)\n\n    if not self.compare_vqip(out_, out2_):\n        print(\"nutrient pool not tracking soil tank\")\n\n    return (in_, out_)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.GrowingSurface.wet_deposition_to_tank","title":"<code>wet_deposition_to_tank(vqip)</code>","text":"<p>Allocate wet deposition to surface tank, updating nutrient pool accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition to send to tank</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition that entered the tank (used for mass balance checking)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def wet_deposition_to_tank(self, vqip):\n    \"\"\"Allocate wet deposition to surface tank, updating nutrient pool accordingly.\n\n    Args:\n        vqip (dict): A VQIP amount of dry deposition to send to tank\n\n    Returns:\n        vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n            for mass balance checking)\n    \"\"\"\n    # Convert to nutrients\n    deposition = self.nutrient_pool.get_empty_nutrient()\n    deposition[\"N\"] = vqip[\"nitrate\"] + vqip[\"ammonia\"]\n    deposition[\"P\"] = vqip[\"phosphate\"]\n\n    # Update nutrient pool\n    in_ = self.nutrient_pool.allocate_wet_deposition(deposition)\n    vqip = self.adjust_vqip_to_liquid(vqip, deposition, in_)\n\n    # Update tank\n    self.push_storage(vqip, force=True)\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.ImperviousSurface","title":"<code>ImperviousSurface</code>","text":"<p>               Bases: <code>Surface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class ImperviousSurface(Surface):\n    \"\"\"\"\"\"\n\n    def __init__(self, pore_depth=0, et0_to_e=1, **kwargs):\n        \"\"\"A surface to represent impervious surfaces that drain to storm sewers. Runoff\n        is generated by the surface tank overflowing, if a user wants all precipitation\n        to immediately go to runoff then they should reduce 'pore_depth', however\n        generally this is not what happens and a small (a few mm) depth should be\n        assigned to the tank. Also includes urban pollution deposition, though this will\n        only be mobilised if runoff occurs.\n\n        Note that the tank does not have a runoff coefficient because it doesn't make\n        sense from an integrated perspective. If a user wants to mimic runoff\n        coefficient-like behaviour, then they should reduce the ImperviousSurface tank\n        size, and increase other surfaces of the parent land node accordingly.\n\n        Args:\n            pore_depth (float, optional): The depth of the tank that must be exceeded\n                to generate runoff. Intended to represent the pores in ashpalt that\n                water accumulates in before flowing. Defaults to 0.\n            et0_to_e (float, optional): Multiplier applied to the parent's data\n                timeseries of et0 to determine how much evaporation takes place on the\n                ImperviousSurface. Defaults to 1.\n        \"\"\"\n        # Assign parameters\n        self.et0_to_e = et0_to_e  # Total evaporation\n        self.pore_depth = pore_depth\n\n        super().__init__(depth=pore_depth, **kwargs)\n\n        # Initialise state variables\n        self.evaporation = self.empty_vqip()\n        self.precipitation = self.empty_vqip()\n\n        # Populate function lists\n        self.inflows.append(self.precipitation_evaporation)\n\n        self.outflows.append(self.push_to_sewers)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        eto_to_e, pore_depth.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.et0_to_e = overrides.pop(\"et0_to_e\", self.et0_to_e)\n        if \"depth\" in overrides.keys():\n            overrides.pop(\"depth\")\n            print(\n                \"ERROR: specifying depth is depreciated in overrides for \\\n\t\timpervious surface, please specify pore_depth instead\"\n            )\n        self.pore_depth = overrides.pop(\"pore_depth\", self.pore_depth)\n        self.depth = self.pore_depth\n        self.capacity = self.area * self.depth\n        super().apply_overrides(overrides)\n\n    def precipitation_evaporation(self):\n        \"\"\"Inflow function that is a simple rainfall-evaporation model, updating the.\n\n        surface tank. All precipitation that is not evaporated is forced into the tank\n        (even though some of that will later be pushed to sewers) - this enables runoff\n        to mix with the accumulated pollutants in the surface pores.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Read data in length units\n        precipitation_depth = self.get_data_input(\"precipitation\")\n        evaporation_depth = self.get_data_input(\"et0\") * self.et0_to_e\n\n        if precipitation_depth &lt; evaporation_depth:\n            # No effective precipitation\n            net_precipitation = 0\n\n            # Calculate how much should be evaporated from pores\n            evaporation_from_pores = evaporation_depth - precipitation_depth\n\n            # Scale\n            evaporation_from_pores *= self.area\n\n            # Pull from tank\n            evaporation_from_pores = self.evaporate(evaporation_from_pores)\n\n            # Scale to get actual evaporation\n            total_evaporation = evaporation_from_pores + precipitation_depth * self.area\n        else:\n            # Effective precipitation\n            net_precipitation = precipitation_depth - evaporation_depth\n\n            # Scale\n            net_precipitation *= self.area\n            net_precipitation = self.v_change_vqip(self.empty_vqip(), net_precipitation)\n\n            # Assign a temperature value TODO how hot is rain? No idea... just going to\n            # use surface air temperature\n            net_precipitation[\"temperature\"] = self.get_data_input(\"temperature\")\n\n            # Update tank\n            _ = self.push_storage(net_precipitation, force=True)\n            total_evaporation = evaporation_depth * self.area\n\n        # Converrt to VQIP\n        self.evaporation = self.v_change_vqip(self.empty_vqip(), total_evaporation)\n        self.precipitation = self.v_change_vqip(\n            self.empty_vqip(), precipitation_depth * self.area\n        )\n\n        return (self.precipitation, self.evaporation)\n\n    def push_to_sewers(self):\n        \"\"\"Outflow function that distributes ponded water (i.e., surface runoff) to the\n        parent node's attached sewers.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Get runoff\n        surface_runoff = self.pull_ponded()\n\n        # Distribute TODO in cwsd_partition this is done with timearea\n        reply = self.parent.push_distributed(surface_runoff, of_type=[\"Sewer\"])\n\n        # Update tank (forcing, because if the water can't go to the sewer, where else\n        # can it go)\n        _ = self.push_storage(reply, force=True)\n        # TODO... possibly this could flow to attached river or land nodes.. or other\n        # surfaces? I expect this doesn't matter for large scale models.. but may need\n        # to be revisited for detailed sewer models\n\n        # Return empty mass balance because outflows are handled by parent\n        return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.ImperviousSurface.__init__","title":"<code>__init__(pore_depth=0, et0_to_e=1, **kwargs)</code>","text":"<p>A surface to represent impervious surfaces that drain to storm sewers. Runoff is generated by the surface tank overflowing, if a user wants all precipitation to immediately go to runoff then they should reduce 'pore_depth', however generally this is not what happens and a small (a few mm) depth should be assigned to the tank. Also includes urban pollution deposition, though this will only be mobilised if runoff occurs.</p> <p>Note that the tank does not have a runoff coefficient because it doesn't make sense from an integrated perspective. If a user wants to mimic runoff coefficient-like behaviour, then they should reduce the ImperviousSurface tank size, and increase other surfaces of the parent land node accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>pore_depth</code> <code>float</code> <p>The depth of the tank that must be exceeded to generate runoff. Intended to represent the pores in ashpalt that water accumulates in before flowing. Defaults to 0.</p> <code>0</code> <code>et0_to_e</code> <code>float</code> <p>Multiplier applied to the parent's data timeseries of et0 to determine how much evaporation takes place on the ImperviousSurface. Defaults to 1.</p> <code>1</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(self, pore_depth=0, et0_to_e=1, **kwargs):\n    \"\"\"A surface to represent impervious surfaces that drain to storm sewers. Runoff\n    is generated by the surface tank overflowing, if a user wants all precipitation\n    to immediately go to runoff then they should reduce 'pore_depth', however\n    generally this is not what happens and a small (a few mm) depth should be\n    assigned to the tank. Also includes urban pollution deposition, though this will\n    only be mobilised if runoff occurs.\n\n    Note that the tank does not have a runoff coefficient because it doesn't make\n    sense from an integrated perspective. If a user wants to mimic runoff\n    coefficient-like behaviour, then they should reduce the ImperviousSurface tank\n    size, and increase other surfaces of the parent land node accordingly.\n\n    Args:\n        pore_depth (float, optional): The depth of the tank that must be exceeded\n            to generate runoff. Intended to represent the pores in ashpalt that\n            water accumulates in before flowing. Defaults to 0.\n        et0_to_e (float, optional): Multiplier applied to the parent's data\n            timeseries of et0 to determine how much evaporation takes place on the\n            ImperviousSurface. Defaults to 1.\n    \"\"\"\n    # Assign parameters\n    self.et0_to_e = et0_to_e  # Total evaporation\n    self.pore_depth = pore_depth\n\n    super().__init__(depth=pore_depth, **kwargs)\n\n    # Initialise state variables\n    self.evaporation = self.empty_vqip()\n    self.precipitation = self.empty_vqip()\n\n    # Populate function lists\n    self.inflows.append(self.precipitation_evaporation)\n\n    self.outflows.append(self.push_to_sewers)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.ImperviousSurface.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: eto_to_e, pore_depth.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        eto_to_e, pore_depth.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.et0_to_e = overrides.pop(\"et0_to_e\", self.et0_to_e)\n        if \"depth\" in overrides.keys():\n            overrides.pop(\"depth\")\n            print(\n                \"ERROR: specifying depth is depreciated in overrides for \\\n\t\timpervious surface, please specify pore_depth instead\"\n            )\n        self.pore_depth = overrides.pop(\"pore_depth\", self.pore_depth)\n        self.depth = self.pore_depth\n        self.capacity = self.area * self.depth\n        super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.ImperviousSurface.precipitation_evaporation","title":"<code>precipitation_evaporation()</code>","text":"<p>Inflow function that is a simple rainfall-evaporation model, updating the.</p> <p>surface tank. All precipitation that is not evaporated is forced into the tank (even though some of that will later be pushed to sewers) - this enables runoff to mix with the accumulated pollutants in the surface pores.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def precipitation_evaporation(self):\n    \"\"\"Inflow function that is a simple rainfall-evaporation model, updating the.\n\n    surface tank. All precipitation that is not evaporated is forced into the tank\n    (even though some of that will later be pushed to sewers) - this enables runoff\n    to mix with the accumulated pollutants in the surface pores.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Read data in length units\n    precipitation_depth = self.get_data_input(\"precipitation\")\n    evaporation_depth = self.get_data_input(\"et0\") * self.et0_to_e\n\n    if precipitation_depth &lt; evaporation_depth:\n        # No effective precipitation\n        net_precipitation = 0\n\n        # Calculate how much should be evaporated from pores\n        evaporation_from_pores = evaporation_depth - precipitation_depth\n\n        # Scale\n        evaporation_from_pores *= self.area\n\n        # Pull from tank\n        evaporation_from_pores = self.evaporate(evaporation_from_pores)\n\n        # Scale to get actual evaporation\n        total_evaporation = evaporation_from_pores + precipitation_depth * self.area\n    else:\n        # Effective precipitation\n        net_precipitation = precipitation_depth - evaporation_depth\n\n        # Scale\n        net_precipitation *= self.area\n        net_precipitation = self.v_change_vqip(self.empty_vqip(), net_precipitation)\n\n        # Assign a temperature value TODO how hot is rain? No idea... just going to\n        # use surface air temperature\n        net_precipitation[\"temperature\"] = self.get_data_input(\"temperature\")\n\n        # Update tank\n        _ = self.push_storage(net_precipitation, force=True)\n        total_evaporation = evaporation_depth * self.area\n\n    # Converrt to VQIP\n    self.evaporation = self.v_change_vqip(self.empty_vqip(), total_evaporation)\n    self.precipitation = self.v_change_vqip(\n        self.empty_vqip(), precipitation_depth * self.area\n    )\n\n    return (self.precipitation, self.evaporation)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.ImperviousSurface.push_to_sewers","title":"<code>push_to_sewers()</code>","text":"<p>Outflow function that distributes ponded water (i.e., surface runoff) to the parent node's attached sewers.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def push_to_sewers(self):\n    \"\"\"Outflow function that distributes ponded water (i.e., surface runoff) to the\n    parent node's attached sewers.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Get runoff\n    surface_runoff = self.pull_ponded()\n\n    # Distribute TODO in cwsd_partition this is done with timearea\n    reply = self.parent.push_distributed(surface_runoff, of_type=[\"Sewer\"])\n\n    # Update tank (forcing, because if the water can't go to the sewer, where else\n    # can it go)\n    _ = self.push_storage(reply, force=True)\n    # TODO... possibly this could flow to attached river or land nodes.. or other\n    # surfaces? I expect this doesn't matter for large scale models.. but may need\n    # to be revisited for detailed sewer models\n\n    # Return empty mass balance because outflows are handled by parent\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.IrrigationSurface","title":"<code>IrrigationSurface</code>","text":"<p>               Bases: <code>GrowingSurface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class IrrigationSurface(GrowingSurface):\n    \"\"\"\"\"\"\n\n    def __init__(self, irrigation_coefficient=0.1, **kwargs):\n        \"\"\"A subclass of GrowingSurface that can calculate water demand for the crops\n        that is not met by precipitation and use the parent node to acquire water. When\n        the surface is created by the parent node, the irrigate function below is\n        assigned.\n\n        Args:\n            irrigation_coefficient (float, optional): proportion area irrigated *\n                proportion of demand met. Defaults to 0.1.\n        \"\"\"\n        # Assign param\n        self.irrigation_coefficient = irrigation_coefficient  # proportion area\n        # irrigated * proportion of demand met\n\n        super().__init__(**kwargs)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override irrigation_coefficient\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.irrigation_coefficient = overrides.pop(\n            \"irrigation_coefficient\", self.irrigation_coefficient\n        )\n        super().apply_overrides(overrides)\n\n    def irrigate(self):\n        \"\"\"Calculate water demand for crops and call parent node to acquire water,\n        updating surface tank and nutrient pools.\"\"\"\n        if self.days_after_sow:\n            # Irrigation is just difference between evaporation and precipitation amount\n            irrigation_demand = (\n                max(self.evaporation[\"volume\"] - self.precipitation[\"volume\"], 0)\n                * self.irrigation_coefficient\n            )\n            if irrigation_demand &gt; constants.FLOAT_ACCURACY:\n                root_zone_depletion = self.get_cmd()\n                if root_zone_depletion &lt;= constants.FLOAT_ACCURACY:\n                    # TODO this isn't in FAO... but seems sensible\n                    irrigation_demand = 0\n\n                # Pull water using parent node\n                supplied = self.parent.pull_distributed(\n                    {\"volume\": irrigation_demand},\n                    of_type=[\"River\", \"Node\", \"Groundwater\", \"Reservoir\"],\n                )\n\n                # update tank\n                _ = self.push_storage(supplied, force=True)\n\n                # update nutrient pools\n                organic = {\n                    \"N\": supplied[\"org-nitrogen\"],\n                    \"P\": supplied[\"org-phosphorus\"],\n                }\n                inorganic = {\n                    \"N\": supplied[\"ammonia\"] + supplied[\"nitrate\"],\n                    \"P\": supplied[\"phosphate\"],\n                }\n                self.nutrient_pool.allocate_organic_irrigation(organic)\n                self.nutrient_pool.allocate_inorganic_irrigation(inorganic)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.IrrigationSurface.__init__","title":"<code>__init__(irrigation_coefficient=0.1, **kwargs)</code>","text":"<p>A subclass of GrowingSurface that can calculate water demand for the crops that is not met by precipitation and use the parent node to acquire water. When the surface is created by the parent node, the irrigate function below is assigned.</p> <p>Parameters:</p> Name Type Description Default <code>irrigation_coefficient</code> <code>float</code> <p>proportion area irrigated * proportion of demand met. Defaults to 0.1.</p> <code>0.1</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(self, irrigation_coefficient=0.1, **kwargs):\n    \"\"\"A subclass of GrowingSurface that can calculate water demand for the crops\n    that is not met by precipitation and use the parent node to acquire water. When\n    the surface is created by the parent node, the irrigate function below is\n    assigned.\n\n    Args:\n        irrigation_coefficient (float, optional): proportion area irrigated *\n            proportion of demand met. Defaults to 0.1.\n    \"\"\"\n    # Assign param\n    self.irrigation_coefficient = irrigation_coefficient  # proportion area\n    # irrigated * proportion of demand met\n\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.IrrigationSurface.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override irrigation_coefficient</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override irrigation_coefficient\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.irrigation_coefficient = overrides.pop(\n        \"irrigation_coefficient\", self.irrigation_coefficient\n    )\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.IrrigationSurface.irrigate","title":"<code>irrigate()</code>","text":"<p>Calculate water demand for crops and call parent node to acquire water, updating surface tank and nutrient pools.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def irrigate(self):\n    \"\"\"Calculate water demand for crops and call parent node to acquire water,\n    updating surface tank and nutrient pools.\"\"\"\n    if self.days_after_sow:\n        # Irrigation is just difference between evaporation and precipitation amount\n        irrigation_demand = (\n            max(self.evaporation[\"volume\"] - self.precipitation[\"volume\"], 0)\n            * self.irrigation_coefficient\n        )\n        if irrigation_demand &gt; constants.FLOAT_ACCURACY:\n            root_zone_depletion = self.get_cmd()\n            if root_zone_depletion &lt;= constants.FLOAT_ACCURACY:\n                # TODO this isn't in FAO... but seems sensible\n                irrigation_demand = 0\n\n            # Pull water using parent node\n            supplied = self.parent.pull_distributed(\n                {\"volume\": irrigation_demand},\n                of_type=[\"River\", \"Node\", \"Groundwater\", \"Reservoir\"],\n            )\n\n            # update tank\n            _ = self.push_storage(supplied, force=True)\n\n            # update nutrient pools\n            organic = {\n                \"N\": supplied[\"org-nitrogen\"],\n                \"P\": supplied[\"org-phosphorus\"],\n            }\n            inorganic = {\n                \"N\": supplied[\"ammonia\"] + supplied[\"nitrate\"],\n                \"P\": supplied[\"phosphate\"],\n            }\n            self.nutrient_pool.allocate_organic_irrigation(organic)\n            self.nutrient_pool.allocate_inorganic_irrigation(inorganic)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land","title":"<code>Land</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class Land(Node):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name,\n        subsurface_residence_time=5,\n        percolation_residence_time=50,\n        surface_residence_time=1,\n        surfaces=[],\n        data_input_dict={},\n    ):\n        \"\"\"An extensive node class that represents land processes (agriculture, soil,\n        subsurface flow, rural runoff, urban drainage, pollution deposition). The\n        expected use is that each distinctive type of land cover (different crop types,\n        gardens, forests, impervious urban drainage, etc.) each have a Surface object,\n        which is a subclass of Tank. The land node will iterate over its surfaces each\n        timestep, which will generally (except in the case of an impervious surface)\n        send water to three common Tanks: surface flow, subsurface flow and percolation.\n        These tanks will then send flows to rivers or groundwater.\n\n        (See wsimod/nodes/land.py/Surface and subclasses for currently available\n        surfaces)\n\n        Args:\n            name (str): node name. subsurface_residence_time (float, optional):\n            Residence time for\n                subsurface flow (see nodes.py/ResidenceTank). Defaults to 5.\n            percolation_residence_time (int, optional): Residence time for\n                percolation flow (see nodes.py/ResidenceTank). Defaults to 50.\n            surface_residence_time (int, optional): Residence time for surface flow\n                (see nodes.py/ResidenceTank). Defaults to 1.\n            surfaces (list, optional): list of dicts where each dict describes the\n                parameters of each surface in the Land node. Each dict also contains an\n                entry under 'type_' which describes which subclass of surface to use.\n                Defaults to [].\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node (generally, et0, precipitation and temperature). Keys are\n                tuples where first value is the name of the variable to read from the\n                dict and the second value is the time. Defaults to {}.\n\n        Functions intended to call in orchestration:\n            run apply_irrigation (if used)\n\n        Key assumptions:\n             - Percolation, surface runoff, and subsurface runoff, can be described with\n                a residence-time method.\n             - Flows to percolation, surface runoff, and subsurface runoff are\n                generated by different hydrological response units (subclasses of\n                `land.py/Surface`), but aggregated for a given land node.\n             - Flows to percolation are distributed to `storage.py/Groundwater`\n                nodes while surface/subsurface runoff to `nodes.py/Node` or\n                `storage.py/River` nodes.\n             - Input data associated with the land node (precipitation,\n                temperature, evapotranspiartion) are the same for every surface.\n             - Water received from `sewer.py/Sewer` objects is sent to the first\n                `land.py/ImperviousSurface` in the surfaces list.\n\n        Input data and parameter requirements:\n             - Precipitation and evapotranspiration are in the `data_input_dict`\n                at the model timestep. _Units_: metres/timestep\n             - Temperature in the `data_input_dict` at the model timestep.\n                _Units_: C\n             - Residence time of surface, subsurface and percolation flows.\n                _Units_: number of timesteps\n        \"\"\"\n        # Assign parameters\n        self.subsurface_residence_time = subsurface_residence_time\n        self.percolation_residence_time = percolation_residence_time\n        self.surface_residence_time = surface_residence_time\n        self.data_input_dict = data_input_dict\n\n        super().__init__(name, data_input_dict=data_input_dict)\n\n        # This could be a deny but then you would have to know in advance whether a\n        # demand node has any gardening or not\n        self.push_check_handler[(\"Demand\", \"Garden\")] = lambda x: self.empty_vqip()\n        self.push_set_handler[(\"Demand\", \"Garden\")] = lambda x: self.empty_vqip()\n\n        # Create surfaces\n        self.irrigation_functions = [lambda: None]\n\n        surfaces_ = surfaces.copy()\n        surfaces = []\n        for surface in surfaces_:\n            # Assign parent (for data reading and to determine where to send flows to)\n            surface[\"parent\"] = self\n\n            # Get surface type\n            type_ = surface[\"type_\"]\n            del surface[\"type_\"]\n\n            # Instantiate surface and store in list of surfaces\n            surfaces.append(getattr(sys.modules[__name__], type_)(**surface))\n\n            # Assign ds (mass balance checking)\n            self.mass_balance_ds.append(surfaces[-1].ds)\n\n            # Assign any irrigation functions\n            if isinstance(surfaces[-1], IrrigationSurface):\n                # TODO, this should probably be done in the Surface initialisation\n                self.irrigation_functions.append(surfaces[-1].irrigate)\n\n            # Assign garden surface functions\n            if isinstance(surfaces[-1], GardenSurface):\n                # TODO, this should probably be done in the Surface initialisation\n                self.push_check_handler[(\"Demand\", \"Garden\")] = surfaces[\n                    -1\n                ].calculate_irrigation_demand\n                self.push_set_handler[(\"Demand\", \"Garden\")] = surfaces[\n                    -1\n                ].receive_irrigation_demand\n\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_check_deny\n        self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n\n        # Create subsurface runoff, surface runoff and percolation tanks Can also do as\n        # timearea if this seems dodge (that is how it is done in IHACRES) TODO should\n        # these be decayresidencetanks?\n        self.subsurface_runoff = ResidenceTank(\n            residence_time=self.subsurface_residence_time,\n            capacity=constants.UNBOUNDED_CAPACITY,\n        )\n        self.percolation = ResidenceTank(\n            residence_time=self.percolation_residence_time,\n            capacity=constants.UNBOUNDED_CAPACITY,\n        )\n        self.surface_runoff = ResidenceTank(\n            residence_time=self.surface_residence_time,\n            capacity=constants.UNBOUNDED_CAPACITY,\n        )\n\n        # Store surfaces\n        self.surfaces = surfaces\n\n        # Mass balance checkign vqips and functions\n        self.running_inflow_mb = self.empty_vqip()\n        self.running_outflow_mb = self.empty_vqip()\n\n        self.mass_balance_in.append(lambda: self.running_inflow_mb)\n        self.mass_balance_out.append(lambda: self.running_outflow_mb)\n        self.mass_balance_ds.append(self.surface_runoff.ds)\n        self.mass_balance_ds.append(self.subsurface_runoff.ds)\n        self.mass_balance_ds.append(self.percolation.ds)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Apply overrides to the Land.\n\n        Enables a user to override any parameter of the residence_time and update\n        the residence_tank accordingly.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.surface_residence_time = overrides.pop(\n            \"surface_residence_time\", self.surface_residence_time\n        )\n        self.subsurface_residence_time = overrides.pop(\n            \"subsurface_residence_time\", self.subsurface_residence_time\n        )\n        self.percolation_residence_time = overrides.pop(\n            \"percolation_residence_time\", self.percolation_residence_time\n        )\n        self.surface_runoff.residence_time = self.surface_residence_time\n        self.subsurface_runoff.residence_time = self.subsurface_residence_time\n        self.percolation.residence_time = self.percolation_residence_time\n\n        for surface, override in overrides.pop(\"surfaces\", {}).items():\n            self.get_surface(surface).apply_overrides(override)\n\n        super().apply_overrides(overrides)\n\n    def apply_irrigation(self):\n        \"\"\"Iterate over any irrigation functions (needs further testing..\n\n        maybe).\n        \"\"\"\n        for f in self.irrigation_functions:\n            f()\n\n    def run(self):\n        \"\"\"Call the run function in all surfaces, update surface/subsurface/ percolation\n        tanks, discharge to rivers/groundwater.\"\"\"\n        # Run all surfaces\n        for surface in self.surfaces:\n            surface.run()\n\n        # Apply residence time to percolation\n        percolation = self.percolation.pull_outflow()\n\n        # Distribute percolation\n        reply = self.push_distributed(percolation, of_type=[\"Groundwater\"])\n\n        if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            # Update percolation 'tank'\n            _ = self.percolation.push_storage(reply, force=True)\n\n        # Apply residence time to subsurface/surface runoff\n        surface_runoff = self.surface_runoff.pull_outflow()\n        subsurface_runoff = self.subsurface_runoff.pull_outflow()\n\n        # Total runoff\n        total_runoff = self.sum_vqip(surface_runoff, subsurface_runoff)\n        if total_runoff[\"volume\"] &gt; 0:\n            # Send to rivers (or nodes, which are assumed to be junctions)\n            reply = self.push_distributed(total_runoff, of_type=[\"River\", \"Node\"])\n\n            # Redistribute total_runoff not sent\n            if reply[\"volume\"] &gt; 0:\n                reply_surface = self.v_change_vqip(\n                    reply,\n                    reply[\"volume\"] * surface_runoff[\"volume\"] / total_runoff[\"volume\"],\n                )\n                reply_subsurface = self.v_change_vqip(\n                    reply,\n                    reply[\"volume\"]\n                    * subsurface_runoff[\"volume\"]\n                    / total_runoff[\"volume\"],\n                )\n\n                # Update surface/subsurface runoff 'tanks'\n                if reply_surface[\"volume\"] &gt; 0:\n                    self.surface_runoff.push_storage(reply_surface, force=True)\n                if reply_subsurface[\"volume\"] &gt; 0:\n                    self.subsurface_runoff.push_storage(reply_subsurface, force=True)\n\n    def push_set_sewer(self, vqip):\n        \"\"\"Receive water from a sewer and send it to the first ImperviousSurface in\n        surfaces.\n\n        Args:\n            vqip (dict): A VQIP amount to be sent to the impervious surface\n\n        Returns:\n            vqip (dict): A VQIP amount of water that was not received\n        \"\"\"\n        # TODO currently just push to the first impervious surface... not sure if people\n        # will be having multiple impervious surfaces. If people would be only having\n        # one then it would make sense to store as a parameter... this is probably fine\n        # for now\n        for surface in self.surfaces:\n            if isinstance(surface, ImperviousSurface):\n                vqip = self.surface.push_storage(vqip, force=True)\n                break\n        return vqip\n\n    def end_timestep(self):\n        \"\"\"Update mass balance and end timestep of all tanks (and surfaces).\"\"\"\n        self.running_inflow_mb = self.empty_vqip()\n        self.running_outflow_mb = self.empty_vqip()\n        for tanks in self.surfaces + [\n            self.surface_runoff,\n            self.subsurface_runoff,\n            self.percolation,\n        ]:\n            tanks.end_timestep()\n\n    def get_surface(self, surface_):\n        \"\"\"Return a surface from the list of surfaces by the 'surface' entry in the\n        surface. I.e., the name of the surface.\n\n        Args:\n            surface_ (str): Name of the surface\n\n        Returns:\n            surface (Surface): The first surface that matches the name\n        \"\"\"\n        for surface in self.surfaces:\n            if surface.surface == surface_:\n                return surface\n        return None\n\n    def reinit(self):\n        \"\"\"\"\"\"\n        self.end_timestep()\n        for surface in self.surfaces + [\n            self.surface_runoff,\n            self.subsurface_runoff,\n            self.percolation,\n        ]:\n            surface.reinit()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.__init__","title":"<code>__init__(name, subsurface_residence_time=5, percolation_residence_time=50, surface_residence_time=1, surfaces=[], data_input_dict={})</code>","text":"<p>An extensive node class that represents land processes (agriculture, soil, subsurface flow, rural runoff, urban drainage, pollution deposition). The expected use is that each distinctive type of land cover (different crop types, gardens, forests, impervious urban drainage, etc.) each have a Surface object, which is a subclass of Tank. The land node will iterate over its surfaces each timestep, which will generally (except in the case of an impervious surface) send water to three common Tanks: surface flow, subsurface flow and percolation. These tanks will then send flows to rivers or groundwater.</p> <p>(See wsimod/nodes/land.py/Surface and subclasses for currently available surfaces)</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>node name. subsurface_residence_time (float, optional):</p> required <code>percolation_residence_time</code> <code>int</code> <p>Residence time for percolation flow (see nodes.py/ResidenceTank). Defaults to 50.</p> <code>50</code> <code>surface_residence_time</code> <code>int</code> <p>Residence time for surface flow (see nodes.py/ResidenceTank). Defaults to 1.</p> <code>1</code> <code>surfaces</code> <code>list</code> <p>list of dicts where each dict describes the parameters of each surface in the Land node. Each dict also contains an entry under 'type_' which describes which subclass of surface to use. Defaults to [].</p> <code>[]</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (generally, et0, precipitation and temperature). Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Defaults to {}.</p> <code>{}</code> Functions intended to call in orchestration <p>run apply_irrigation (if used)</p> Key assumptions <ul> <li>Percolation, surface runoff, and subsurface runoff, can be described with    a residence-time method.</li> <li>Flows to percolation, surface runoff, and subsurface runoff are    generated by different hydrological response units (subclasses of    <code>land.py/Surface</code>), but aggregated for a given land node.</li> <li>Flows to percolation are distributed to <code>storage.py/Groundwater</code>    nodes while surface/subsurface runoff to <code>nodes.py/Node</code> or    <code>storage.py/River</code> nodes.</li> <li>Input data associated with the land node (precipitation,    temperature, evapotranspiartion) are the same for every surface.</li> <li>Water received from <code>sewer.py/Sewer</code> objects is sent to the first    <code>land.py/ImperviousSurface</code> in the surfaces list.</li> </ul> Input data and parameter requirements <ul> <li>Precipitation and evapotranspiration are in the <code>data_input_dict</code>    at the model timestep. Units: metres/timestep</li> <li>Temperature in the <code>data_input_dict</code> at the model timestep.    Units: C</li> <li>Residence time of surface, subsurface and percolation flows.    Units: number of timesteps</li> </ul> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(\n    self,\n    name,\n    subsurface_residence_time=5,\n    percolation_residence_time=50,\n    surface_residence_time=1,\n    surfaces=[],\n    data_input_dict={},\n):\n    \"\"\"An extensive node class that represents land processes (agriculture, soil,\n    subsurface flow, rural runoff, urban drainage, pollution deposition). The\n    expected use is that each distinctive type of land cover (different crop types,\n    gardens, forests, impervious urban drainage, etc.) each have a Surface object,\n    which is a subclass of Tank. The land node will iterate over its surfaces each\n    timestep, which will generally (except in the case of an impervious surface)\n    send water to three common Tanks: surface flow, subsurface flow and percolation.\n    These tanks will then send flows to rivers or groundwater.\n\n    (See wsimod/nodes/land.py/Surface and subclasses for currently available\n    surfaces)\n\n    Args:\n        name (str): node name. subsurface_residence_time (float, optional):\n        Residence time for\n            subsurface flow (see nodes.py/ResidenceTank). Defaults to 5.\n        percolation_residence_time (int, optional): Residence time for\n            percolation flow (see nodes.py/ResidenceTank). Defaults to 50.\n        surface_residence_time (int, optional): Residence time for surface flow\n            (see nodes.py/ResidenceTank). Defaults to 1.\n        surfaces (list, optional): list of dicts where each dict describes the\n            parameters of each surface in the Land node. Each dict also contains an\n            entry under 'type_' which describes which subclass of surface to use.\n            Defaults to [].\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node (generally, et0, precipitation and temperature). Keys are\n            tuples where first value is the name of the variable to read from the\n            dict and the second value is the time. Defaults to {}.\n\n    Functions intended to call in orchestration:\n        run apply_irrigation (if used)\n\n    Key assumptions:\n         - Percolation, surface runoff, and subsurface runoff, can be described with\n            a residence-time method.\n         - Flows to percolation, surface runoff, and subsurface runoff are\n            generated by different hydrological response units (subclasses of\n            `land.py/Surface`), but aggregated for a given land node.\n         - Flows to percolation are distributed to `storage.py/Groundwater`\n            nodes while surface/subsurface runoff to `nodes.py/Node` or\n            `storage.py/River` nodes.\n         - Input data associated with the land node (precipitation,\n            temperature, evapotranspiartion) are the same for every surface.\n         - Water received from `sewer.py/Sewer` objects is sent to the first\n            `land.py/ImperviousSurface` in the surfaces list.\n\n    Input data and parameter requirements:\n         - Precipitation and evapotranspiration are in the `data_input_dict`\n            at the model timestep. _Units_: metres/timestep\n         - Temperature in the `data_input_dict` at the model timestep.\n            _Units_: C\n         - Residence time of surface, subsurface and percolation flows.\n            _Units_: number of timesteps\n    \"\"\"\n    # Assign parameters\n    self.subsurface_residence_time = subsurface_residence_time\n    self.percolation_residence_time = percolation_residence_time\n    self.surface_residence_time = surface_residence_time\n    self.data_input_dict = data_input_dict\n\n    super().__init__(name, data_input_dict=data_input_dict)\n\n    # This could be a deny but then you would have to know in advance whether a\n    # demand node has any gardening or not\n    self.push_check_handler[(\"Demand\", \"Garden\")] = lambda x: self.empty_vqip()\n    self.push_set_handler[(\"Demand\", \"Garden\")] = lambda x: self.empty_vqip()\n\n    # Create surfaces\n    self.irrigation_functions = [lambda: None]\n\n    surfaces_ = surfaces.copy()\n    surfaces = []\n    for surface in surfaces_:\n        # Assign parent (for data reading and to determine where to send flows to)\n        surface[\"parent\"] = self\n\n        # Get surface type\n        type_ = surface[\"type_\"]\n        del surface[\"type_\"]\n\n        # Instantiate surface and store in list of surfaces\n        surfaces.append(getattr(sys.modules[__name__], type_)(**surface))\n\n        # Assign ds (mass balance checking)\n        self.mass_balance_ds.append(surfaces[-1].ds)\n\n        # Assign any irrigation functions\n        if isinstance(surfaces[-1], IrrigationSurface):\n            # TODO, this should probably be done in the Surface initialisation\n            self.irrigation_functions.append(surfaces[-1].irrigate)\n\n        # Assign garden surface functions\n        if isinstance(surfaces[-1], GardenSurface):\n            # TODO, this should probably be done in the Surface initialisation\n            self.push_check_handler[(\"Demand\", \"Garden\")] = surfaces[\n                -1\n            ].calculate_irrigation_demand\n            self.push_set_handler[(\"Demand\", \"Garden\")] = surfaces[\n                -1\n            ].receive_irrigation_demand\n\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_check_deny\n    self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n\n    # Create subsurface runoff, surface runoff and percolation tanks Can also do as\n    # timearea if this seems dodge (that is how it is done in IHACRES) TODO should\n    # these be decayresidencetanks?\n    self.subsurface_runoff = ResidenceTank(\n        residence_time=self.subsurface_residence_time,\n        capacity=constants.UNBOUNDED_CAPACITY,\n    )\n    self.percolation = ResidenceTank(\n        residence_time=self.percolation_residence_time,\n        capacity=constants.UNBOUNDED_CAPACITY,\n    )\n    self.surface_runoff = ResidenceTank(\n        residence_time=self.surface_residence_time,\n        capacity=constants.UNBOUNDED_CAPACITY,\n    )\n\n    # Store surfaces\n    self.surfaces = surfaces\n\n    # Mass balance checkign vqips and functions\n    self.running_inflow_mb = self.empty_vqip()\n    self.running_outflow_mb = self.empty_vqip()\n\n    self.mass_balance_in.append(lambda: self.running_inflow_mb)\n    self.mass_balance_out.append(lambda: self.running_outflow_mb)\n    self.mass_balance_ds.append(self.surface_runoff.ds)\n    self.mass_balance_ds.append(self.subsurface_runoff.ds)\n    self.mass_balance_ds.append(self.percolation.ds)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.apply_irrigation","title":"<code>apply_irrigation()</code>","text":"<p>Iterate over any irrigation functions (needs further testing..</p> <p>maybe).</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def apply_irrigation(self):\n    \"\"\"Iterate over any irrigation functions (needs further testing..\n\n    maybe).\n    \"\"\"\n    for f in self.irrigation_functions:\n        f()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Apply overrides to the Land.</p> <p>Enables a user to override any parameter of the residence_time and update the residence_tank accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Apply overrides to the Land.\n\n    Enables a user to override any parameter of the residence_time and update\n    the residence_tank accordingly.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.surface_residence_time = overrides.pop(\n        \"surface_residence_time\", self.surface_residence_time\n    )\n    self.subsurface_residence_time = overrides.pop(\n        \"subsurface_residence_time\", self.subsurface_residence_time\n    )\n    self.percolation_residence_time = overrides.pop(\n        \"percolation_residence_time\", self.percolation_residence_time\n    )\n    self.surface_runoff.residence_time = self.surface_residence_time\n    self.subsurface_runoff.residence_time = self.subsurface_residence_time\n    self.percolation.residence_time = self.percolation_residence_time\n\n    for surface, override in overrides.pop(\"surfaces\", {}).items():\n        self.get_surface(surface).apply_overrides(override)\n\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Update mass balance and end timestep of all tanks (and surfaces).</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Update mass balance and end timestep of all tanks (and surfaces).\"\"\"\n    self.running_inflow_mb = self.empty_vqip()\n    self.running_outflow_mb = self.empty_vqip()\n    for tanks in self.surfaces + [\n        self.surface_runoff,\n        self.subsurface_runoff,\n        self.percolation,\n    ]:\n        tanks.end_timestep()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.get_surface","title":"<code>get_surface(surface_)</code>","text":"<p>Return a surface from the list of surfaces by the 'surface' entry in the surface. I.e., the name of the surface.</p> <p>Parameters:</p> Name Type Description Default <code>surface_</code> <code>str</code> <p>Name of the surface</p> required <p>Returns:</p> Name Type Description <code>surface</code> <code>Surface</code> <p>The first surface that matches the name</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_surface(self, surface_):\n    \"\"\"Return a surface from the list of surfaces by the 'surface' entry in the\n    surface. I.e., the name of the surface.\n\n    Args:\n        surface_ (str): Name of the surface\n\n    Returns:\n        surface (Surface): The first surface that matches the name\n    \"\"\"\n    for surface in self.surfaces:\n        if surface.surface == surface_:\n            return surface\n    return None\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.push_set_sewer","title":"<code>push_set_sewer(vqip)</code>","text":"<p>Receive water from a sewer and send it to the first ImperviousSurface in surfaces.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be sent to the impervious surface</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of water that was not received</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def push_set_sewer(self, vqip):\n    \"\"\"Receive water from a sewer and send it to the first ImperviousSurface in\n    surfaces.\n\n    Args:\n        vqip (dict): A VQIP amount to be sent to the impervious surface\n\n    Returns:\n        vqip (dict): A VQIP amount of water that was not received\n    \"\"\"\n    # TODO currently just push to the first impervious surface... not sure if people\n    # will be having multiple impervious surfaces. If people would be only having\n    # one then it would make sense to store as a parameter... this is probably fine\n    # for now\n    for surface in self.surfaces:\n        if isinstance(surface, ImperviousSurface):\n            vqip = self.surface.push_storage(vqip, force=True)\n            break\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.reinit","title":"<code>reinit()</code>","text":"Source code in <code>wsimod/nodes/land.py</code> <pre><code>def reinit(self):\n    \"\"\"\"\"\"\n    self.end_timestep()\n    for surface in self.surfaces + [\n        self.surface_runoff,\n        self.subsurface_runoff,\n        self.percolation,\n    ]:\n        surface.reinit()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Land.run","title":"<code>run()</code>","text":"<p>Call the run function in all surfaces, update surface/subsurface/ percolation tanks, discharge to rivers/groundwater.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def run(self):\n    \"\"\"Call the run function in all surfaces, update surface/subsurface/ percolation\n    tanks, discharge to rivers/groundwater.\"\"\"\n    # Run all surfaces\n    for surface in self.surfaces:\n        surface.run()\n\n    # Apply residence time to percolation\n    percolation = self.percolation.pull_outflow()\n\n    # Distribute percolation\n    reply = self.push_distributed(percolation, of_type=[\"Groundwater\"])\n\n    if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        # Update percolation 'tank'\n        _ = self.percolation.push_storage(reply, force=True)\n\n    # Apply residence time to subsurface/surface runoff\n    surface_runoff = self.surface_runoff.pull_outflow()\n    subsurface_runoff = self.subsurface_runoff.pull_outflow()\n\n    # Total runoff\n    total_runoff = self.sum_vqip(surface_runoff, subsurface_runoff)\n    if total_runoff[\"volume\"] &gt; 0:\n        # Send to rivers (or nodes, which are assumed to be junctions)\n        reply = self.push_distributed(total_runoff, of_type=[\"River\", \"Node\"])\n\n        # Redistribute total_runoff not sent\n        if reply[\"volume\"] &gt; 0:\n            reply_surface = self.v_change_vqip(\n                reply,\n                reply[\"volume\"] * surface_runoff[\"volume\"] / total_runoff[\"volume\"],\n            )\n            reply_subsurface = self.v_change_vqip(\n                reply,\n                reply[\"volume\"]\n                * subsurface_runoff[\"volume\"]\n                / total_runoff[\"volume\"],\n            )\n\n            # Update surface/subsurface runoff 'tanks'\n            if reply_surface[\"volume\"] &gt; 0:\n                self.surface_runoff.push_storage(reply_surface, force=True)\n            if reply_subsurface[\"volume\"] &gt; 0:\n                self.subsurface_runoff.push_storage(reply_subsurface, force=True)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface","title":"<code>PerviousSurface</code>","text":"<p>               Bases: <code>Surface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class PerviousSurface(Surface):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        depth=0.75,\n        total_porosity=0.4,\n        field_capacity=0.3,\n        wilting_point=0.12,\n        infiltration_capacity=0.5,\n        surface_coefficient=0.05,\n        percolation_coefficient=0.75,\n        et0_coefficient=0.5,\n        ihacres_p=10,\n        **kwargs,\n    ):\n        \"\"\"A generic pervious surface that represents hydrology with the IHACRES model.\n\n        Args:\n            depth (float, optional): Soil tank (i.e., root) depth. Defaults to 0.75.\n            total_porosity (float, optional): The total porosity IHACRES parameter\n                (i.e., defines the total porouse volume of the soil - the maximum volume\n                of soil pores can contain when saturated). Defaults to 0.4.\n            field_capacity (float, optional): The field capacity IHACRES parameter\n                (i.e., when water content in the soil tank is above this value - flows\n                of any kind can be generated). Defaults to 0.3.\n            wilting_point (float, optional): The wilting point IHACRES parameter (i.e.,\n                when water content content in the soil tank is above this value - plants\n                can uptake water and evaporation from the soil tank can occur). Defaults\n                to 0.12.\n            infiltration_capacity (float, optional): Depth of water per day that can\n                enter the soil tank. Non infiltrated water will pond and travel as\n                surface runoff from the parent Land node. Defaults to 0.5.\n            surface_coefficient (float, optional): If flow is generated, the proportion\n                of flow that goes to surface runoff. Defaults to 0.05.\n            percolation_coefficient (float, optional): If flow is generated, then the\n                proportion of water that does not go to surface runoff that goes to\n                percolation (i.e., groundwater) - the remainder goes to subsurface\n                runoff. Defaults to 0.75.\n            et0_coefficient (float, optional): Convert between the parent nodes data\n                timeseries et0 - and potential evaptranspiration per unit area for this\n                surface. Defaults to=0.5,\n            ihacres_p (float, optional): The IHACRES p parameter. Unless it is an\n                ephemeral stream this parameter probably can stay high. Defaults to 10.\n\n        Key assumptions:\n             - In IHACRES, the maximum infiltration per time step is controlled by an\n                infiltration capacity, beyond which the precipitation will flow directly\n                as surface runoff.\n             - Evapotranspiration and effective precipitation are calculated based on\n                soil moisture content.\n             - Effective precipitation is then divided into percolation, surface runoff,\n                and subsurface runoff by multiplying the corresponding coefficient.\n             - Percolation, surface runoff, and subsurface runoff are sent into the\n                corresponding residence tanks for rounting to downstream.\n             - The mass of pollutants in soil water tank proportionately leaves the\n                soil water tank into the routing residence tanks. Evapotranspiration can\n                only bring out water, with pollutants left in the soil tank.\n\n        Input data and parameter requirements:\n             - Field capacity and wilting point.\n                _Units_: -, both should in [0-1], with field capacity &gt; wilting point\n             - Infiltration capacity.\n                _Units_: m/day\n             - Surface, percolation coefficient.\n                _Units_: -, both should in [0-1]\n             - et0 coefficient.\n                _Units_: -\n             - ihacres_p.\n                _Units_: -\n        \"\"\"\n        # Assign parameters (converting field capacity and wilting point to depth)\n        self.field_capacity = field_capacity\n        self.field_capacity_m = field_capacity * depth\n        self.wilting_point = wilting_point\n        self.wilting_point_m = wilting_point * depth\n        self.infiltration_capacity = infiltration_capacity\n        self.surface_coefficient = surface_coefficient\n        self.percolation_coefficient = percolation_coefficient\n        self.et0_coefficient = et0_coefficient\n        self.ihacres_p = ihacres_p\n        self.total_porosity = total_porosity\n\n        # Parameters to determine how to calculate the temperature of outflowing water\n        # TODO what should these params be?\n        self.soil_temp_w_prev = 0.1  # previous timestep weighting\n        self.soil_temp_w_air = 0.6  # air temperature weighting\n        self.soil_temp_w_deep = 0.1  # deep soil temperature weighting\n        self.soil_temp_deep = 10  # deep soil temperature\n\n        # IHACRES is a deficit not a tank, so doesn't really have a capacity in this\n        # way... and if it did.. I don't know if it would be the root depth\n        super().__init__(depth=depth * total_porosity, **kwargs)\n\n        # Calculate subsurface coefficient\n        self.subsurface_coefficient = 1 - self.percolation_coefficient\n\n        # Initiliase state variables\n        self.infiltration_excess = self.empty_vqip()\n        self.subsurface_flow = self.empty_vqip()\n        self.percolation = self.empty_vqip()\n        self.tank_recharge = 0\n        self.evaporation = self.empty_vqip()\n        self.precipitation = self.empty_vqip()\n\n        # Populate function lists\n        self.inflows.append(self.ihacres)  # work out runoff\n\n        # TODO interception if I hate myself enough?\n        self.processes.append(\n            self.calculate_soil_temperature\n        )  # Calculate soil temp + dependence factor\n\n        # self.processes.append(self.decay) #apply generic decay (currently handled by\n        # decaytank at end of timestep) TODO decaytank uses air temperature not soil\n        # temperature... probably need to just give it the decay function\n\n        self.outflows.append(self.route)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        field_capacity, wilting_point, total_porosity, infiltration_capacity,\n        surface_coefficient, percolation_coefficient, et0_coefficient, ihacres_p,\n        soil_temp_w_prev, soil_temp_w_air, soil_temp_w_deep, soil_temp_deep,\n        and the corresponding parameter values, including field_capacity_m,\n        wilting_point_m, depth, capacity, subsurface_coefficient.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n\n        self.depth /= self.total_porosity  # restore the physical depth (root)\n\n        overwrite_params = [\n            \"field_capacity\",\n            \"wilting_point\",\n            \"total_porosity\",\n            \"infiltration_capacity\",\n            \"surface_coefficient\",\n            \"percolation_coefficient\",\n            \"et0_coefficient\",\n            \"ihacres_p\",\n            \"soil_temp_w_prev\",\n            \"soil_temp_w_air\",\n            \"soil_temp_w_deep\",\n            \"soil_temp_deep\",\n        ]\n        for param in overwrite_params:\n            setattr(self, param, overrides.pop(param, getattr(self, param)))\n\n        self.subsurface_coefficient = 1 - self.percolation_coefficient\n\n        super().apply_overrides(overrides)\n        # After the depth has been changed ...\n        self.field_capacity_m = self.field_capacity * self.depth\n        self.wilting_point_m = self.wilting_point * self.depth\n        self.depth *= self.total_porosity  # update the simulation depth\n        self.capacity = self.depth * self.area\n\n    def get_cmd(self):\n        \"\"\"Calculate moisture deficit (i.e., the tank excess converted to depth).\n\n        Returns:\n            (float): current moisture deficit\n        \"\"\"\n        return self.get_excess()[\"volume\"] / self.area\n\n    def get_smc(self):\n        \"\"\"Calculate moisture content (i.e., the tank volume converted to depth).\n\n        Returns:\n            (float): soil moisture content\n        \"\"\"\n        # Depth of soil moisture\n        return self.storage[\"volume\"] / self.area\n\n    def get_climate(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        precipitation_depth = self.get_data_input(\"precipitation\")\n        evaporation_depth = self.get_data_input(\"et0\") * self.et0_coefficient\n        return precipitation_depth, evaporation_depth\n\n    def ihacres(self):\n        \"\"\"Inflow function that runs the IHACRES model equations, updates tanks, and\n        store flows in state variables (which are later sent to the parent land node in\n        the route function).\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # Read data (leave in depth units since that is what IHACRES equations are in)\n        precipitation_depth, evaporation_depth = self.get_climate()\n        temperature = self.get_data_input(\"temperature\")\n\n        # Apply infiltration\n        infiltrated_precipitation = min(precipitation_depth, self.infiltration_capacity)\n        infiltration_excess = max(precipitation_depth - infiltrated_precipitation, 0)\n\n        # Get current moisture deficit\n        current_moisture_deficit_depth = self.get_cmd()\n\n        # IHACRES equations (we do (depth - wilting_point_m or field capacity) to\n        # convert from a deficit to storage tank)\n        evaporation = evaporation_depth * min(\n            1,\n            exp(\n                2\n                * (\n                    1\n                    - current_moisture_deficit_depth\n                    / (self.depth - self.wilting_point_m)\n                )\n            ),\n        )\n        outflow = infiltrated_precipitation * (\n            1\n            - min(\n                1,\n                (current_moisture_deficit_depth / (self.depth - self.field_capacity_m))\n                ** self.ihacres_p,\n            )\n        )\n\n        # Can't evaporate more than available moisture (presumably the IHACRES equation\n        # prevents this ever being needed)\n        evaporation = min(evaporation, precipitation_depth + self.get_smc())\n\n        # Scale to volumes and apply proportions to work out percolation/surface\n        # runoff/subsurface runoff\n        surface = outflow * self.surface_coefficient * self.area\n        percolation = (\n            outflow\n            * (1 - self.surface_coefficient)\n            * self.percolation_coefficient\n            * self.area\n        )\n        subsurface_flow = (\n            outflow\n            * (1 - self.surface_coefficient)\n            * self.subsurface_coefficient\n            * self.area\n        )\n        tank_recharge = (infiltrated_precipitation - evaporation - outflow) * self.area\n        infiltration_excess *= self.area\n        infiltration_excess += surface\n        evaporation *= self.area\n        precipitation = precipitation_depth * self.area\n\n        # Mix in tank to calculate pollutant concentrations\n        total_water_passing_through_soil_tank = (\n            tank_recharge + subsurface_flow + percolation\n        )\n\n        if total_water_passing_through_soil_tank &gt; 0:\n            # Net effective preipitation\n            total_water_passing_through_soil_tank = self.v_change_vqip(\n                self.empty_vqip(), total_water_passing_through_soil_tank\n            )\n            # Assign a temperature before sending into tank\n            total_water_passing_through_soil_tank[\"temperature\"] = temperature\n            # Assign to tank\n            _ = self.push_storage(total_water_passing_through_soil_tank, force=True)\n            # Pull flows (which now have nonzero pollutant concentrations)\n            subsurface_flow = self.pull_storage({\"volume\": subsurface_flow})\n            percolation = self.pull_storage({\"volume\": percolation})\n        else:\n            # No net effective precipitation (instead evaporation occurs)\n            evap = self.evaporate(-total_water_passing_through_soil_tank)\n            subsurface_flow = self.empty_vqip()\n            percolation = self.empty_vqip()\n\n            if (\n                abs(\n                    evap\n                    + infiltrated_precipitation * self.area\n                    - evaporation\n                    - infiltration_excess\n                )\n                &gt; constants.FLOAT_ACCURACY\n            ):\n                print(\n                    \"inaccurate evaporation calculation of {0}\".format(\n                        abs(\n                            evap\n                            + infiltrated_precipitation * self.area\n                            - evaporation\n                            - infiltration_excess\n                        )\n                    )\n                )\n\n        # TODO saturation excess (think it should just be 'pull_ponded'  presumably in\n        # net effective precipitation? )\n\n        # Convert to VQIPs\n        infiltration_excess = self.v_change_vqip(self.empty_vqip(), infiltration_excess)\n        infiltration_excess[\"temperature\"] = temperature\n        precipitation = self.v_change_vqip(self.empty_vqip(), precipitation)\n        evaporation = self.v_change_vqip(self.empty_vqip(), evaporation)\n\n        # Track flows (these are sent onwards in the route function)\n        self.infiltration_excess = infiltration_excess\n        self.subsurface_flow = subsurface_flow\n        self.percolation = percolation\n        self.tank_recharge = tank_recharge\n        self.evaporation = evaporation\n        self.precipitation = precipitation\n\n        # Mass balance\n        in_ = precipitation\n        out_ = evaporation\n\n        return (in_, out_)\n\n    def route(self):\n        \"\"\"An outflow function that sends percolation, subsurface runoff and surface\n        runoff to their respective tanks in the parent land node.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        self.parent.surface_runoff.push_storage(self.infiltration_excess, force=True)\n        self.parent.subsurface_runoff.push_storage(self.subsurface_flow, force=True)\n        self.parent.percolation.push_storage(self.percolation, force=True)\n\n        return (self.empty_vqip(), self.empty_vqip())\n\n    def calculate_soil_temperature(self):\n        \"\"\"Process function that calculates soil temperature based on a weighted.\n\n        average. This equation is from Lindstrom, Bishop &amp; Lofvenius (2002),\n        hydrological processes - but it is not clear what the parameters should be.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        auto = self.storage[\"temperature\"] * self.soil_temp_w_prev\n        air = self.get_data_input(\"temperature\") * self.soil_temp_w_air\n        total_weight = (\n            self.soil_temp_w_air + self.soil_temp_w_deep + self.soil_temp_w_prev\n        )\n        self.storage[\"temperature\"] = (\n            auto + air + self.soil_temp_deep * self.soil_temp_w_deep\n        ) / total_weight\n\n        return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.__init__","title":"<code>__init__(depth=0.75, total_porosity=0.4, field_capacity=0.3, wilting_point=0.12, infiltration_capacity=0.5, surface_coefficient=0.05, percolation_coefficient=0.75, et0_coefficient=0.5, ihacres_p=10, **kwargs)</code>","text":"<p>A generic pervious surface that represents hydrology with the IHACRES model.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>float</code> <p>Soil tank (i.e., root) depth. Defaults to 0.75.</p> <code>0.75</code> <code>total_porosity</code> <code>float</code> <p>The total porosity IHACRES parameter (i.e., defines the total porouse volume of the soil - the maximum volume of soil pores can contain when saturated). Defaults to 0.4.</p> <code>0.4</code> <code>field_capacity</code> <code>float</code> <p>The field capacity IHACRES parameter (i.e., when water content in the soil tank is above this value - flows of any kind can be generated). Defaults to 0.3.</p> <code>0.3</code> <code>wilting_point</code> <code>float</code> <p>The wilting point IHACRES parameter (i.e., when water content content in the soil tank is above this value - plants can uptake water and evaporation from the soil tank can occur). Defaults to 0.12.</p> <code>0.12</code> <code>infiltration_capacity</code> <code>float</code> <p>Depth of water per day that can enter the soil tank. Non infiltrated water will pond and travel as surface runoff from the parent Land node. Defaults to 0.5.</p> <code>0.5</code> <code>surface_coefficient</code> <code>float</code> <p>If flow is generated, the proportion of flow that goes to surface runoff. Defaults to 0.05.</p> <code>0.05</code> <code>percolation_coefficient</code> <code>float</code> <p>If flow is generated, then the proportion of water that does not go to surface runoff that goes to percolation (i.e., groundwater) - the remainder goes to subsurface runoff. Defaults to 0.75.</p> <code>0.75</code> <code>et0_coefficient</code> <code>float</code> <p>Convert between the parent nodes data timeseries et0 - and potential evaptranspiration per unit area for this surface. Defaults to=0.5,</p> <code>0.5</code> <code>ihacres_p</code> <code>float</code> <p>The IHACRES p parameter. Unless it is an ephemeral stream this parameter probably can stay high. Defaults to 10.</p> <code>10</code> Key assumptions <ul> <li>In IHACRES, the maximum infiltration per time step is controlled by an    infiltration capacity, beyond which the precipitation will flow directly    as surface runoff.</li> <li>Evapotranspiration and effective precipitation are calculated based on    soil moisture content.</li> <li>Effective precipitation is then divided into percolation, surface runoff,    and subsurface runoff by multiplying the corresponding coefficient.</li> <li>Percolation, surface runoff, and subsurface runoff are sent into the    corresponding residence tanks for rounting to downstream.</li> <li>The mass of pollutants in soil water tank proportionately leaves the    soil water tank into the routing residence tanks. Evapotranspiration can    only bring out water, with pollutants left in the soil tank.</li> </ul> Input data and parameter requirements <ul> <li>Field capacity and wilting point.    Units: -, both should in [0-1], with field capacity &gt; wilting point</li> <li>Infiltration capacity.    Units: m/day</li> <li>Surface, percolation coefficient.    Units: -, both should in [0-1]</li> <li>et0 coefficient.    Units: -</li> <li>ihacres_p.    Units: -</li> </ul> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(\n    self,\n    depth=0.75,\n    total_porosity=0.4,\n    field_capacity=0.3,\n    wilting_point=0.12,\n    infiltration_capacity=0.5,\n    surface_coefficient=0.05,\n    percolation_coefficient=0.75,\n    et0_coefficient=0.5,\n    ihacres_p=10,\n    **kwargs,\n):\n    \"\"\"A generic pervious surface that represents hydrology with the IHACRES model.\n\n    Args:\n        depth (float, optional): Soil tank (i.e., root) depth. Defaults to 0.75.\n        total_porosity (float, optional): The total porosity IHACRES parameter\n            (i.e., defines the total porouse volume of the soil - the maximum volume\n            of soil pores can contain when saturated). Defaults to 0.4.\n        field_capacity (float, optional): The field capacity IHACRES parameter\n            (i.e., when water content in the soil tank is above this value - flows\n            of any kind can be generated). Defaults to 0.3.\n        wilting_point (float, optional): The wilting point IHACRES parameter (i.e.,\n            when water content content in the soil tank is above this value - plants\n            can uptake water and evaporation from the soil tank can occur). Defaults\n            to 0.12.\n        infiltration_capacity (float, optional): Depth of water per day that can\n            enter the soil tank. Non infiltrated water will pond and travel as\n            surface runoff from the parent Land node. Defaults to 0.5.\n        surface_coefficient (float, optional): If flow is generated, the proportion\n            of flow that goes to surface runoff. Defaults to 0.05.\n        percolation_coefficient (float, optional): If flow is generated, then the\n            proportion of water that does not go to surface runoff that goes to\n            percolation (i.e., groundwater) - the remainder goes to subsurface\n            runoff. Defaults to 0.75.\n        et0_coefficient (float, optional): Convert between the parent nodes data\n            timeseries et0 - and potential evaptranspiration per unit area for this\n            surface. Defaults to=0.5,\n        ihacres_p (float, optional): The IHACRES p parameter. Unless it is an\n            ephemeral stream this parameter probably can stay high. Defaults to 10.\n\n    Key assumptions:\n         - In IHACRES, the maximum infiltration per time step is controlled by an\n            infiltration capacity, beyond which the precipitation will flow directly\n            as surface runoff.\n         - Evapotranspiration and effective precipitation are calculated based on\n            soil moisture content.\n         - Effective precipitation is then divided into percolation, surface runoff,\n            and subsurface runoff by multiplying the corresponding coefficient.\n         - Percolation, surface runoff, and subsurface runoff are sent into the\n            corresponding residence tanks for rounting to downstream.\n         - The mass of pollutants in soil water tank proportionately leaves the\n            soil water tank into the routing residence tanks. Evapotranspiration can\n            only bring out water, with pollutants left in the soil tank.\n\n    Input data and parameter requirements:\n         - Field capacity and wilting point.\n            _Units_: -, both should in [0-1], with field capacity &gt; wilting point\n         - Infiltration capacity.\n            _Units_: m/day\n         - Surface, percolation coefficient.\n            _Units_: -, both should in [0-1]\n         - et0 coefficient.\n            _Units_: -\n         - ihacres_p.\n            _Units_: -\n    \"\"\"\n    # Assign parameters (converting field capacity and wilting point to depth)\n    self.field_capacity = field_capacity\n    self.field_capacity_m = field_capacity * depth\n    self.wilting_point = wilting_point\n    self.wilting_point_m = wilting_point * depth\n    self.infiltration_capacity = infiltration_capacity\n    self.surface_coefficient = surface_coefficient\n    self.percolation_coefficient = percolation_coefficient\n    self.et0_coefficient = et0_coefficient\n    self.ihacres_p = ihacres_p\n    self.total_porosity = total_porosity\n\n    # Parameters to determine how to calculate the temperature of outflowing water\n    # TODO what should these params be?\n    self.soil_temp_w_prev = 0.1  # previous timestep weighting\n    self.soil_temp_w_air = 0.6  # air temperature weighting\n    self.soil_temp_w_deep = 0.1  # deep soil temperature weighting\n    self.soil_temp_deep = 10  # deep soil temperature\n\n    # IHACRES is a deficit not a tank, so doesn't really have a capacity in this\n    # way... and if it did.. I don't know if it would be the root depth\n    super().__init__(depth=depth * total_porosity, **kwargs)\n\n    # Calculate subsurface coefficient\n    self.subsurface_coefficient = 1 - self.percolation_coefficient\n\n    # Initiliase state variables\n    self.infiltration_excess = self.empty_vqip()\n    self.subsurface_flow = self.empty_vqip()\n    self.percolation = self.empty_vqip()\n    self.tank_recharge = 0\n    self.evaporation = self.empty_vqip()\n    self.precipitation = self.empty_vqip()\n\n    # Populate function lists\n    self.inflows.append(self.ihacres)  # work out runoff\n\n    # TODO interception if I hate myself enough?\n    self.processes.append(\n        self.calculate_soil_temperature\n    )  # Calculate soil temp + dependence factor\n\n    # self.processes.append(self.decay) #apply generic decay (currently handled by\n    # decaytank at end of timestep) TODO decaytank uses air temperature not soil\n    # temperature... probably need to just give it the decay function\n\n    self.outflows.append(self.route)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: field_capacity, wilting_point, total_porosity, infiltration_capacity, surface_coefficient, percolation_coefficient, et0_coefficient, ihacres_p, soil_temp_w_prev, soil_temp_w_air, soil_temp_w_deep, soil_temp_deep, and the corresponding parameter values, including field_capacity_m, wilting_point_m, depth, capacity, subsurface_coefficient.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    field_capacity, wilting_point, total_porosity, infiltration_capacity,\n    surface_coefficient, percolation_coefficient, et0_coefficient, ihacres_p,\n    soil_temp_w_prev, soil_temp_w_air, soil_temp_w_deep, soil_temp_deep,\n    and the corresponding parameter values, including field_capacity_m,\n    wilting_point_m, depth, capacity, subsurface_coefficient.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n\n    self.depth /= self.total_porosity  # restore the physical depth (root)\n\n    overwrite_params = [\n        \"field_capacity\",\n        \"wilting_point\",\n        \"total_porosity\",\n        \"infiltration_capacity\",\n        \"surface_coefficient\",\n        \"percolation_coefficient\",\n        \"et0_coefficient\",\n        \"ihacres_p\",\n        \"soil_temp_w_prev\",\n        \"soil_temp_w_air\",\n        \"soil_temp_w_deep\",\n        \"soil_temp_deep\",\n    ]\n    for param in overwrite_params:\n        setattr(self, param, overrides.pop(param, getattr(self, param)))\n\n    self.subsurface_coefficient = 1 - self.percolation_coefficient\n\n    super().apply_overrides(overrides)\n    # After the depth has been changed ...\n    self.field_capacity_m = self.field_capacity * self.depth\n    self.wilting_point_m = self.wilting_point * self.depth\n    self.depth *= self.total_porosity  # update the simulation depth\n    self.capacity = self.depth * self.area\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.calculate_soil_temperature","title":"<code>calculate_soil_temperature()</code>","text":"<p>Process function that calculates soil temperature based on a weighted.</p> <p>average. This equation is from Lindstrom, Bishop &amp; Lofvenius (2002), hydrological processes - but it is not clear what the parameters should be.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def calculate_soil_temperature(self):\n    \"\"\"Process function that calculates soil temperature based on a weighted.\n\n    average. This equation is from Lindstrom, Bishop &amp; Lofvenius (2002),\n    hydrological processes - but it is not clear what the parameters should be.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    auto = self.storage[\"temperature\"] * self.soil_temp_w_prev\n    air = self.get_data_input(\"temperature\") * self.soil_temp_w_air\n    total_weight = (\n        self.soil_temp_w_air + self.soil_temp_w_deep + self.soil_temp_w_prev\n    )\n    self.storage[\"temperature\"] = (\n        auto + air + self.soil_temp_deep * self.soil_temp_w_deep\n    ) / total_weight\n\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.get_climate","title":"<code>get_climate()</code>","text":"<p>Returns:</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_climate(self):\n    \"\"\"\n\n    Returns:\n\n    \"\"\"\n    precipitation_depth = self.get_data_input(\"precipitation\")\n    evaporation_depth = self.get_data_input(\"et0\") * self.et0_coefficient\n    return precipitation_depth, evaporation_depth\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.get_cmd","title":"<code>get_cmd()</code>","text":"<p>Calculate moisture deficit (i.e., the tank excess converted to depth).</p> <p>Returns:</p> Type Description <code>float</code> <p>current moisture deficit</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_cmd(self):\n    \"\"\"Calculate moisture deficit (i.e., the tank excess converted to depth).\n\n    Returns:\n        (float): current moisture deficit\n    \"\"\"\n    return self.get_excess()[\"volume\"] / self.area\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.get_smc","title":"<code>get_smc()</code>","text":"<p>Calculate moisture content (i.e., the tank volume converted to depth).</p> <p>Returns:</p> Type Description <code>float</code> <p>soil moisture content</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_smc(self):\n    \"\"\"Calculate moisture content (i.e., the tank volume converted to depth).\n\n    Returns:\n        (float): soil moisture content\n    \"\"\"\n    # Depth of soil moisture\n    return self.storage[\"volume\"] / self.area\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.ihacres","title":"<code>ihacres()</code>","text":"<p>Inflow function that runs the IHACRES model equations, updates tanks, and store flows in state variables (which are later sent to the parent land node in the route function).</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def ihacres(self):\n    \"\"\"Inflow function that runs the IHACRES model equations, updates tanks, and\n    store flows in state variables (which are later sent to the parent land node in\n    the route function).\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # Read data (leave in depth units since that is what IHACRES equations are in)\n    precipitation_depth, evaporation_depth = self.get_climate()\n    temperature = self.get_data_input(\"temperature\")\n\n    # Apply infiltration\n    infiltrated_precipitation = min(precipitation_depth, self.infiltration_capacity)\n    infiltration_excess = max(precipitation_depth - infiltrated_precipitation, 0)\n\n    # Get current moisture deficit\n    current_moisture_deficit_depth = self.get_cmd()\n\n    # IHACRES equations (we do (depth - wilting_point_m or field capacity) to\n    # convert from a deficit to storage tank)\n    evaporation = evaporation_depth * min(\n        1,\n        exp(\n            2\n            * (\n                1\n                - current_moisture_deficit_depth\n                / (self.depth - self.wilting_point_m)\n            )\n        ),\n    )\n    outflow = infiltrated_precipitation * (\n        1\n        - min(\n            1,\n            (current_moisture_deficit_depth / (self.depth - self.field_capacity_m))\n            ** self.ihacres_p,\n        )\n    )\n\n    # Can't evaporate more than available moisture (presumably the IHACRES equation\n    # prevents this ever being needed)\n    evaporation = min(evaporation, precipitation_depth + self.get_smc())\n\n    # Scale to volumes and apply proportions to work out percolation/surface\n    # runoff/subsurface runoff\n    surface = outflow * self.surface_coefficient * self.area\n    percolation = (\n        outflow\n        * (1 - self.surface_coefficient)\n        * self.percolation_coefficient\n        * self.area\n    )\n    subsurface_flow = (\n        outflow\n        * (1 - self.surface_coefficient)\n        * self.subsurface_coefficient\n        * self.area\n    )\n    tank_recharge = (infiltrated_precipitation - evaporation - outflow) * self.area\n    infiltration_excess *= self.area\n    infiltration_excess += surface\n    evaporation *= self.area\n    precipitation = precipitation_depth * self.area\n\n    # Mix in tank to calculate pollutant concentrations\n    total_water_passing_through_soil_tank = (\n        tank_recharge + subsurface_flow + percolation\n    )\n\n    if total_water_passing_through_soil_tank &gt; 0:\n        # Net effective preipitation\n        total_water_passing_through_soil_tank = self.v_change_vqip(\n            self.empty_vqip(), total_water_passing_through_soil_tank\n        )\n        # Assign a temperature before sending into tank\n        total_water_passing_through_soil_tank[\"temperature\"] = temperature\n        # Assign to tank\n        _ = self.push_storage(total_water_passing_through_soil_tank, force=True)\n        # Pull flows (which now have nonzero pollutant concentrations)\n        subsurface_flow = self.pull_storage({\"volume\": subsurface_flow})\n        percolation = self.pull_storage({\"volume\": percolation})\n    else:\n        # No net effective precipitation (instead evaporation occurs)\n        evap = self.evaporate(-total_water_passing_through_soil_tank)\n        subsurface_flow = self.empty_vqip()\n        percolation = self.empty_vqip()\n\n        if (\n            abs(\n                evap\n                + infiltrated_precipitation * self.area\n                - evaporation\n                - infiltration_excess\n            )\n            &gt; constants.FLOAT_ACCURACY\n        ):\n            print(\n                \"inaccurate evaporation calculation of {0}\".format(\n                    abs(\n                        evap\n                        + infiltrated_precipitation * self.area\n                        - evaporation\n                        - infiltration_excess\n                    )\n                )\n            )\n\n    # TODO saturation excess (think it should just be 'pull_ponded'  presumably in\n    # net effective precipitation? )\n\n    # Convert to VQIPs\n    infiltration_excess = self.v_change_vqip(self.empty_vqip(), infiltration_excess)\n    infiltration_excess[\"temperature\"] = temperature\n    precipitation = self.v_change_vqip(self.empty_vqip(), precipitation)\n    evaporation = self.v_change_vqip(self.empty_vqip(), evaporation)\n\n    # Track flows (these are sent onwards in the route function)\n    self.infiltration_excess = infiltration_excess\n    self.subsurface_flow = subsurface_flow\n    self.percolation = percolation\n    self.tank_recharge = tank_recharge\n    self.evaporation = evaporation\n    self.precipitation = precipitation\n\n    # Mass balance\n    in_ = precipitation\n    out_ = evaporation\n\n    return (in_, out_)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.PerviousSurface.route","title":"<code>route()</code>","text":"<p>An outflow function that sends percolation, subsurface runoff and surface runoff to their respective tanks in the parent land node.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def route(self):\n    \"\"\"An outflow function that sends percolation, subsurface runoff and surface\n    runoff to their respective tanks in the parent land node.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    self.parent.surface_runoff.push_storage(self.infiltration_excess, force=True)\n    self.parent.subsurface_runoff.push_storage(self.subsurface_flow, force=True)\n    self.parent.percolation.push_storage(self.percolation, force=True)\n\n    return (self.empty_vqip(), self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface","title":"<code>Surface</code>","text":"<p>               Bases: <code>DecayTank</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class Surface(DecayTank):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        surface=\"\",\n        area=1,\n        depth=1,\n        data_input_dict={},\n        pollutant_load={},\n        **kwargs,\n    ):\n        \"\"\"A subclass of DecayTank. Each Surface is anticipated to represent a different\n        land cover type of a Land node. Besides functioning as a Tank, Surfaces have\n        three lists of functions (inflows, processes and outflows) where behaviour can\n        be added by appending new functions. We anticipate that customised surfaces\n        should be a subclass of Surface or its subclasses and add functions to these\n        lists. These lists are executed (inflows first, then processes, then outflows)\n        in the run function, which is called by the run function in Land. The lists must\n        return any model inflows or outflows as a VQIP for mass balance checking.\n\n        If a user wishes the DecayTank portion to be active, then can provide 'decays',\n        which are passed upwards (see wsimod/core/core.py/DecayObj for documentation)\n\n        Args:\n            surface (str, optional): String description of the surface type. Doesn't\n                serve a modelling purpose, just used for user reference. Defaults to ''.\n            area (float, optional): Area of surface. Defaults to 1. depth (float,\n            optional): Depth of tank (this has different physical\n                implications for different subclasses). Defaults to 1.\n            data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n                the surface (generally, deposition). Keys are tuples where first value\n                is the name of the variable to read from the dict and the second value\n                is the time. Note that this input should be specific to the surface, and\n                is not intended to be the same data input as for the land node. Also\n                note that with each surface having its own timeseries of data inputs,\n                this can take up a lot of memory, thus the default behavior is to have\n                this as monthly data where the time variable is a monthyear. Defaults to\n                {}.\n            pollutant_load (dict, optional): A dict of different pollutant amounts that\n                are deposited on the surface (units are mass per area per timestep).\n                Defaults to {}.\n\n        Key assumptions:\n            - Generic `Surface` that reads data and can apply simple forms of pollution\n              deposition.\n            - Formulated as a `Tank` object.\n            - Ammonia-&gt;Nitrite-&gt;Nitrate decay takes place if parameters describing this\n                process are provided in `decays` (see `core.py/DecayObj` for\n                transformation details).\n\n        Input data and parameter requirements:\n            - `data_input_dict` can contain a variety of pollutant deposition data.\n                `srp-dry` describes phosphate. `noy-dry` describes nitrogen as nitrates.\n                `nhx-dry` describes nitrogen as ammonia. `srp/noy/ nhx-wet` can also be\n                used to specify wet deposition. _Units_: kg/m2/timestep (data is read at\n                a monthly timestep)\n        \"\"\"\n        # Assign parameters\n        self.depth = depth\n        self.data_input_dict = data_input_dict\n        self.surface = surface\n        self.pollutant_load = pollutant_load\n        # TODO this is a decaytank but growing surfaces don't have decay parameters...\n        # is it a problem.. we don't even take decays as an explicit argument and insert\n        # them in kwargs..\n        capacity = area * depth\n        # Parameters\n        super().__init__(capacity=capacity, area=area, **kwargs)\n\n        # Populate function lists TODO.. not sure why I have deposition but no\n        # precipitation here\n        if \"nhx-dry\" in set(x[0] for x in data_input_dict.keys()):\n            self.inflows = [self.atmospheric_deposition, self.precipitation_deposition]\n        else:\n            self.inflows = []\n        if len(self.pollutant_load) &gt; 0:\n            self.inflows.append(self.simple_deposition)\n        self.processes = []\n        self.outflows = []\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        area and depth (both will update the capacity), pollutant_load (the\n        entire dict does not need to be redefined, only changed values need to\n        be included).\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.surface = overrides.pop(\"surface\", self.surface)\n        self.pollutant_load.update(overrides.pop(\"pollutant_load\", {}))\n\n        self.area = overrides.pop(\"area\", self.area)\n        self.depth = overrides.pop(\"depth\", self.depth)\n        self.capacity = self.area * self.depth\n\n        if \"capacity\" in overrides.keys():\n            overrides.pop(\"capacity\")\n            print(\n                \"Warning: specifying capacity is depreciated in overrides for surface, \\\n\t\tplease specify depth and area instead. capacity override value has been ignored\"\n            )\n\n        # overrides data_input_dict\n        from wsimod.orchestration.model import read_csv\n\n        content = overrides.pop(\"data_input_dict\", self.data_input_dict)\n        if isinstance(content, str):\n            self.data_input_dict = read_csv(content)\n        elif isinstance(content, dict):\n            self.data_input_dict = content\n        else:\n            raise ValueError(\n                f\"{content.__class__} is not a recognised format for data_input_dict\"\n            )\n\n        super().apply_overrides(overrides)\n\n    def run(self):\n        \"\"\"Call run function (called from Land node).\"\"\"\n        if \"nitrite\" in constants.POLLUTANTS:\n            # Assume that if nitrite is modelled then nitrification is also modelled You\n            # will need ammonia-&gt;nitrite-&gt;nitrate decay to accurate simulate ammonia\n            # Thus, these decays are simulated here\n\n            # NOTE decay in a decaytank happens at start of timestep (confusingly) in\n            # the end_timestep function\n            self.storage[\"nitrate\"] += self.total_decayed[\"nitrite\"]\n            self.parent.running_inflow_mb[\"nitrate\"] += self.total_decayed[\"nitrite\"]\n\n            # Decayed ammonia becomes nitrite\n            self.storage[\"nitrite\"] += self.total_decayed[\"ammonia\"]\n            self.parent.running_inflow_mb[\"nitrite\"] += self.total_decayed[\"ammonia\"]\n\n        for f in self.inflows + self.processes + self.outflows:\n            # Iterate over function lists, updating mass balance\n            in_, out_ = f()\n            self.parent.running_inflow_mb = self.sum_vqip(\n                self.parent.running_inflow_mb, in_\n            )\n            self.parent.running_outflow_mb = self.sum_vqip(\n                self.parent.running_outflow_mb, out_\n            )\n\n    def get_data_input(self, var):\n        \"\"\"Read data input from parent Land node (i.e., for precipitation/et0/temp).\n\n        Args:\n            var (str): Name of variable\n\n        Returns:\n            Data read\n        \"\"\"\n        return self.parent.get_data_input(var)\n\n    def get_data_input_surface(self, var):\n        \"\"\"Read data input from this surface's data_input_dict.\n\n        Args:\n            var (str): Name of variable\n\n        Returns:\n            Data read\n        \"\"\"\n        return self.data_input_dict[(var, self.parent.monthyear)]\n\n    def dry_deposition_to_tank(self, vqip):\n        \"\"\"Generic function for allocating dry pollution deposition to the surface.\n        Simply sends the pollution into the tank (some subclasses overwrite this\n        behaviour).\n\n        Args:\n            vqip (dict): A VQIP amount of dry deposition to send to tank\n\n        Returns:\n            vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n                for mass balance checking)\n        \"\"\"\n        # Default behaviour is to just enter the tank\n        _ = self.push_storage(vqip, force=True)\n        return vqip\n\n    def wet_deposition_to_tank(self, vqip):\n        \"\"\"Generic function for allocating wet pollution deposition to the surface.\n        Simply sends the pollution into the tank (some subclasses overwrite this\n        behaviour).\n\n        Args:\n            vqip (dict): A VQIP amount of wet deposition to send to tank\n\n        Returns:\n            vqip (dict): A VQIP amount of wet deposition that entered the tank (used\n                for mass balance checking)\n        \"\"\"\n        # Default behaviour is to just enter the tank\n        _ = self.push_storage(vqip, force=True)\n        return vqip\n\n    def simple_deposition(self):\n        \"\"\"Inflow function to cause simple pollution deposition to occur, updating the\n        surface tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        pollution = self.empty_vqip()\n\n        # Scale by area\n        for pol, item in self.pollutant_load.items():\n            if pol in constants.ADDITIVE_POLLUTANTS:\n                pollution[pol] = item * self.area\n            else:\n                pollution[pol] = item\n        pollution[\"volume\"] = 0\n\n        # Update tank\n        _ = self.push_storage(pollution, force=True)\n\n        return (pollution, self.empty_vqip())\n\n    def atmospheric_deposition(self):\n        \"\"\"Inflow function to cause dry atmospheric deposition to occur, updating the\n        surface tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # TODO double check units in preprocessing - is weight of N or weight of\n        # NHX/noy?\n\n        # Read data and scale\n        nhx = self.get_data_input_surface(\"nhx-dry\") * self.area\n        noy = self.get_data_input_surface(\"noy-dry\") * self.area\n        srp = self.get_data_input_surface(\"srp-dry\") * self.area\n\n        # Assign pollutants\n        vqip = self.empty_vqip()\n        vqip[\"ammonia\"] = nhx\n        vqip[\"nitrate\"] = noy\n        vqip[\"phosphate\"] = srp\n\n        # Update tank\n        in_ = self.dry_deposition_to_tank(vqip)\n\n        # Return mass balance\n        return (in_, self.empty_vqip())\n\n    def precipitation_deposition(self):\n        \"\"\"Inflow function to cause wet precipitation deposition to occur, updating the\n        surface tank.\n\n        Returns:\n            (tuple): A tuple containing a VQIP amount for model inputs and outputs\n                for mass balance checking.\n        \"\"\"\n        # TODO double check units - is weight of N or weight of NHX/noy?\n\n        # Read data and scale\n        nhx = self.get_data_input_surface(\"nhx-wet\") * self.area\n        noy = self.get_data_input_surface(\"noy-wet\") * self.area\n        srp = self.get_data_input_surface(\"srp-wet\") * self.area\n\n        # Assign pollutants\n        vqip = self.empty_vqip()\n        vqip[\"ammonia\"] = nhx\n        vqip[\"nitrate\"] = noy\n        vqip[\"phosphate\"] = srp\n\n        # Update tank\n        in_ = self.wet_deposition_to_tank(vqip)\n\n        # Return mass balance\n        return (in_, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.__init__","title":"<code>__init__(surface='', area=1, depth=1, data_input_dict={}, pollutant_load={}, **kwargs)</code>","text":"<p>A subclass of DecayTank. Each Surface is anticipated to represent a different land cover type of a Land node. Besides functioning as a Tank, Surfaces have three lists of functions (inflows, processes and outflows) where behaviour can be added by appending new functions. We anticipate that customised surfaces should be a subclass of Surface or its subclasses and add functions to these lists. These lists are executed (inflows first, then processes, then outflows) in the run function, which is called by the run function in Land. The lists must return any model inflows or outflows as a VQIP for mass balance checking.</p> <p>If a user wishes the DecayTank portion to be active, then can provide 'decays', which are passed upwards (see wsimod/core/core.py/DecayObj for documentation)</p> <p>Parameters:</p> Name Type Description Default <code>surface</code> <code>str</code> <p>String description of the surface type. Doesn't serve a modelling purpose, just used for user reference. Defaults to ''.</p> <code>''</code> <code>area</code> <code>float</code> <p>Area of surface. Defaults to 1. depth (float,</p> <code>1</code> <code>optional)</code> <p>Depth of tank (this has different physical implications for different subclasses). Defaults to 1.</p> required <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the surface (generally, deposition). Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Note that this input should be specific to the surface, and is not intended to be the same data input as for the land node. Also note that with each surface having its own timeseries of data inputs, this can take up a lot of memory, thus the default behavior is to have this as monthly data where the time variable is a monthyear. Defaults to {}.</p> <code>{}</code> <code>pollutant_load</code> <code>dict</code> <p>A dict of different pollutant amounts that are deposited on the surface (units are mass per area per timestep). Defaults to {}.</p> <code>{}</code> Key assumptions <ul> <li>Generic <code>Surface</code> that reads data and can apply simple forms of pollution   deposition.</li> <li>Formulated as a <code>Tank</code> object.</li> <li>Ammonia-&gt;Nitrite-&gt;Nitrate decay takes place if parameters describing this     process are provided in <code>decays</code> (see <code>core.py/DecayObj</code> for     transformation details).</li> </ul> Input data and parameter requirements <ul> <li><code>data_input_dict</code> can contain a variety of pollutant deposition data.     <code>srp-dry</code> describes phosphate. <code>noy-dry</code> describes nitrogen as nitrates.     <code>nhx-dry</code> describes nitrogen as ammonia. <code>srp/noy/ nhx-wet</code> can also be     used to specify wet deposition. Units: kg/m2/timestep (data is read at     a monthly timestep)</li> </ul> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(\n    self,\n    surface=\"\",\n    area=1,\n    depth=1,\n    data_input_dict={},\n    pollutant_load={},\n    **kwargs,\n):\n    \"\"\"A subclass of DecayTank. Each Surface is anticipated to represent a different\n    land cover type of a Land node. Besides functioning as a Tank, Surfaces have\n    three lists of functions (inflows, processes and outflows) where behaviour can\n    be added by appending new functions. We anticipate that customised surfaces\n    should be a subclass of Surface or its subclasses and add functions to these\n    lists. These lists are executed (inflows first, then processes, then outflows)\n    in the run function, which is called by the run function in Land. The lists must\n    return any model inflows or outflows as a VQIP for mass balance checking.\n\n    If a user wishes the DecayTank portion to be active, then can provide 'decays',\n    which are passed upwards (see wsimod/core/core.py/DecayObj for documentation)\n\n    Args:\n        surface (str, optional): String description of the surface type. Doesn't\n            serve a modelling purpose, just used for user reference. Defaults to ''.\n        area (float, optional): Area of surface. Defaults to 1. depth (float,\n        optional): Depth of tank (this has different physical\n            implications for different subclasses). Defaults to 1.\n        data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n            the surface (generally, deposition). Keys are tuples where first value\n            is the name of the variable to read from the dict and the second value\n            is the time. Note that this input should be specific to the surface, and\n            is not intended to be the same data input as for the land node. Also\n            note that with each surface having its own timeseries of data inputs,\n            this can take up a lot of memory, thus the default behavior is to have\n            this as monthly data where the time variable is a monthyear. Defaults to\n            {}.\n        pollutant_load (dict, optional): A dict of different pollutant amounts that\n            are deposited on the surface (units are mass per area per timestep).\n            Defaults to {}.\n\n    Key assumptions:\n        - Generic `Surface` that reads data and can apply simple forms of pollution\n          deposition.\n        - Formulated as a `Tank` object.\n        - Ammonia-&gt;Nitrite-&gt;Nitrate decay takes place if parameters describing this\n            process are provided in `decays` (see `core.py/DecayObj` for\n            transformation details).\n\n    Input data and parameter requirements:\n        - `data_input_dict` can contain a variety of pollutant deposition data.\n            `srp-dry` describes phosphate. `noy-dry` describes nitrogen as nitrates.\n            `nhx-dry` describes nitrogen as ammonia. `srp/noy/ nhx-wet` can also be\n            used to specify wet deposition. _Units_: kg/m2/timestep (data is read at\n            a monthly timestep)\n    \"\"\"\n    # Assign parameters\n    self.depth = depth\n    self.data_input_dict = data_input_dict\n    self.surface = surface\n    self.pollutant_load = pollutant_load\n    # TODO this is a decaytank but growing surfaces don't have decay parameters...\n    # is it a problem.. we don't even take decays as an explicit argument and insert\n    # them in kwargs..\n    capacity = area * depth\n    # Parameters\n    super().__init__(capacity=capacity, area=area, **kwargs)\n\n    # Populate function lists TODO.. not sure why I have deposition but no\n    # precipitation here\n    if \"nhx-dry\" in set(x[0] for x in data_input_dict.keys()):\n        self.inflows = [self.atmospheric_deposition, self.precipitation_deposition]\n    else:\n        self.inflows = []\n    if len(self.pollutant_load) &gt; 0:\n        self.inflows.append(self.simple_deposition)\n    self.processes = []\n    self.outflows = []\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: area and depth (both will update the capacity), pollutant_load (the entire dict does not need to be redefined, only changed values need to be included).</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/land.py</code> <pre><code>    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        area and depth (both will update the capacity), pollutant_load (the\n        entire dict does not need to be redefined, only changed values need to\n        be included).\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.surface = overrides.pop(\"surface\", self.surface)\n        self.pollutant_load.update(overrides.pop(\"pollutant_load\", {}))\n\n        self.area = overrides.pop(\"area\", self.area)\n        self.depth = overrides.pop(\"depth\", self.depth)\n        self.capacity = self.area * self.depth\n\n        if \"capacity\" in overrides.keys():\n            overrides.pop(\"capacity\")\n            print(\n                \"Warning: specifying capacity is depreciated in overrides for surface, \\\n\t\tplease specify depth and area instead. capacity override value has been ignored\"\n            )\n\n        # overrides data_input_dict\n        from wsimod.orchestration.model import read_csv\n\n        content = overrides.pop(\"data_input_dict\", self.data_input_dict)\n        if isinstance(content, str):\n            self.data_input_dict = read_csv(content)\n        elif isinstance(content, dict):\n            self.data_input_dict = content\n        else:\n            raise ValueError(\n                f\"{content.__class__} is not a recognised format for data_input_dict\"\n            )\n\n        super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.atmospheric_deposition","title":"<code>atmospheric_deposition()</code>","text":"<p>Inflow function to cause dry atmospheric deposition to occur, updating the surface tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def atmospheric_deposition(self):\n    \"\"\"Inflow function to cause dry atmospheric deposition to occur, updating the\n    surface tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # TODO double check units in preprocessing - is weight of N or weight of\n    # NHX/noy?\n\n    # Read data and scale\n    nhx = self.get_data_input_surface(\"nhx-dry\") * self.area\n    noy = self.get_data_input_surface(\"noy-dry\") * self.area\n    srp = self.get_data_input_surface(\"srp-dry\") * self.area\n\n    # Assign pollutants\n    vqip = self.empty_vqip()\n    vqip[\"ammonia\"] = nhx\n    vqip[\"nitrate\"] = noy\n    vqip[\"phosphate\"] = srp\n\n    # Update tank\n    in_ = self.dry_deposition_to_tank(vqip)\n\n    # Return mass balance\n    return (in_, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.dry_deposition_to_tank","title":"<code>dry_deposition_to_tank(vqip)</code>","text":"<p>Generic function for allocating dry pollution deposition to the surface. Simply sends the pollution into the tank (some subclasses overwrite this behaviour).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition to send to tank</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of dry deposition that entered the tank (used for mass balance checking)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def dry_deposition_to_tank(self, vqip):\n    \"\"\"Generic function for allocating dry pollution deposition to the surface.\n    Simply sends the pollution into the tank (some subclasses overwrite this\n    behaviour).\n\n    Args:\n        vqip (dict): A VQIP amount of dry deposition to send to tank\n\n    Returns:\n        vqip (dict): A VQIP amount of dry deposition that entered the tank (used\n            for mass balance checking)\n    \"\"\"\n    # Default behaviour is to just enter the tank\n    _ = self.push_storage(vqip, force=True)\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.get_data_input","title":"<code>get_data_input(var)</code>","text":"<p>Read data input from parent Land node (i.e., for precipitation/et0/temp).</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Name of variable</p> required <p>Returns:</p> Type Description <p>Data read</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_data_input(self, var):\n    \"\"\"Read data input from parent Land node (i.e., for precipitation/et0/temp).\n\n    Args:\n        var (str): Name of variable\n\n    Returns:\n        Data read\n    \"\"\"\n    return self.parent.get_data_input(var)\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.get_data_input_surface","title":"<code>get_data_input_surface(var)</code>","text":"<p>Read data input from this surface's data_input_dict.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Name of variable</p> required <p>Returns:</p> Type Description <p>Data read</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_data_input_surface(self, var):\n    \"\"\"Read data input from this surface's data_input_dict.\n\n    Args:\n        var (str): Name of variable\n\n    Returns:\n        Data read\n    \"\"\"\n    return self.data_input_dict[(var, self.parent.monthyear)]\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.precipitation_deposition","title":"<code>precipitation_deposition()</code>","text":"<p>Inflow function to cause wet precipitation deposition to occur, updating the surface tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def precipitation_deposition(self):\n    \"\"\"Inflow function to cause wet precipitation deposition to occur, updating the\n    surface tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    # TODO double check units - is weight of N or weight of NHX/noy?\n\n    # Read data and scale\n    nhx = self.get_data_input_surface(\"nhx-wet\") * self.area\n    noy = self.get_data_input_surface(\"noy-wet\") * self.area\n    srp = self.get_data_input_surface(\"srp-wet\") * self.area\n\n    # Assign pollutants\n    vqip = self.empty_vqip()\n    vqip[\"ammonia\"] = nhx\n    vqip[\"nitrate\"] = noy\n    vqip[\"phosphate\"] = srp\n\n    # Update tank\n    in_ = self.wet_deposition_to_tank(vqip)\n\n    # Return mass balance\n    return (in_, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.run","title":"<code>run()</code>","text":"<p>Call run function (called from Land node).</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def run(self):\n    \"\"\"Call run function (called from Land node).\"\"\"\n    if \"nitrite\" in constants.POLLUTANTS:\n        # Assume that if nitrite is modelled then nitrification is also modelled You\n        # will need ammonia-&gt;nitrite-&gt;nitrate decay to accurate simulate ammonia\n        # Thus, these decays are simulated here\n\n        # NOTE decay in a decaytank happens at start of timestep (confusingly) in\n        # the end_timestep function\n        self.storage[\"nitrate\"] += self.total_decayed[\"nitrite\"]\n        self.parent.running_inflow_mb[\"nitrate\"] += self.total_decayed[\"nitrite\"]\n\n        # Decayed ammonia becomes nitrite\n        self.storage[\"nitrite\"] += self.total_decayed[\"ammonia\"]\n        self.parent.running_inflow_mb[\"nitrite\"] += self.total_decayed[\"ammonia\"]\n\n    for f in self.inflows + self.processes + self.outflows:\n        # Iterate over function lists, updating mass balance\n        in_, out_ = f()\n        self.parent.running_inflow_mb = self.sum_vqip(\n            self.parent.running_inflow_mb, in_\n        )\n        self.parent.running_outflow_mb = self.sum_vqip(\n            self.parent.running_outflow_mb, out_\n        )\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.simple_deposition","title":"<code>simple_deposition()</code>","text":"<p>Inflow function to cause simple pollution deposition to occur, updating the surface tank.</p> <p>Returns:</p> Type Description <code>tuple</code> <p>A tuple containing a VQIP amount for model inputs and outputs for mass balance checking.</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def simple_deposition(self):\n    \"\"\"Inflow function to cause simple pollution deposition to occur, updating the\n    surface tank.\n\n    Returns:\n        (tuple): A tuple containing a VQIP amount for model inputs and outputs\n            for mass balance checking.\n    \"\"\"\n    pollution = self.empty_vqip()\n\n    # Scale by area\n    for pol, item in self.pollutant_load.items():\n        if pol in constants.ADDITIVE_POLLUTANTS:\n            pollution[pol] = item * self.area\n        else:\n            pollution[pol] = item\n    pollution[\"volume\"] = 0\n\n    # Update tank\n    _ = self.push_storage(pollution, force=True)\n\n    return (pollution, self.empty_vqip())\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.Surface.wet_deposition_to_tank","title":"<code>wet_deposition_to_tank(vqip)</code>","text":"<p>Generic function for allocating wet pollution deposition to the surface. Simply sends the pollution into the tank (some subclasses overwrite this behaviour).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of wet deposition to send to tank</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount of wet deposition that entered the tank (used for mass balance checking)</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def wet_deposition_to_tank(self, vqip):\n    \"\"\"Generic function for allocating wet pollution deposition to the surface.\n    Simply sends the pollution into the tank (some subclasses overwrite this\n    behaviour).\n\n    Args:\n        vqip (dict): A VQIP amount of wet deposition to send to tank\n\n    Returns:\n        vqip (dict): A VQIP amount of wet deposition that entered the tank (used\n            for mass balance checking)\n    \"\"\"\n    # Default behaviour is to just enter the tank\n    _ = self.push_storage(vqip, force=True)\n    return vqip\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.VariableAreaSurface","title":"<code>VariableAreaSurface</code>","text":"<p>               Bases: <code>GrowingSurface</code></p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>class VariableAreaSurface(GrowingSurface):\n    \"\"\"\"\"\"\n\n    def __init__(self, current_surface_area=0, **kwargs):\n        \"\"\"\"\"\"\n        super().__init__(**kwargs)\n        self.get_climate = self.get_climate_\n        self.current_surface_area = current_surface_area\n\n    def get_climate_(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        precipitation_depth = self.get_data_input(\"precipitation\")\n        evaporation_depth = self.get_data_input(\"et0\") * self.et0_coefficient\n\n        precipitation_depth *= self.current_surface_area / self.area\n        evaporation_depth *= self.current_surface_area / self.area\n\n        return precipitation_depth, evaporation_depth\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.VariableAreaSurface.__init__","title":"<code>__init__(current_surface_area=0, **kwargs)</code>","text":"Source code in <code>wsimod/nodes/land.py</code> <pre><code>def __init__(self, current_surface_area=0, **kwargs):\n    \"\"\"\"\"\"\n    super().__init__(**kwargs)\n    self.get_climate = self.get_climate_\n    self.current_surface_area = current_surface_area\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.land.VariableAreaSurface.get_climate_","title":"<code>get_climate_()</code>","text":"<p>Returns:</p> Source code in <code>wsimod/nodes/land.py</code> <pre><code>def get_climate_(self):\n    \"\"\"\n\n    Returns:\n\n    \"\"\"\n    precipitation_depth = self.get_data_input(\"precipitation\")\n    evaporation_depth = self.get_data_input(\"et0\") * self.et0_coefficient\n\n    precipitation_depth *= self.current_surface_area / self.area\n    evaporation_depth *= self.current_surface_area / self.area\n\n    return precipitation_depth, evaporation_depth\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool","title":"<code>NutrientPool</code>","text":"Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>class NutrientPool:\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        fraction_dry_n_to_dissolved_inorganic=0.9,\n        degrhpar={\"N\": 7 * 1e-5, \"P\": 7 * 1e-6},\n        dishpar={\"N\": 7 * 1e-5, \"P\": 7 * 1e-6},\n        minfpar={\"N\": 0.00013, \"P\": 0.000003},\n        disfpar={\"N\": 0.000003, \"P\": 0.0000001},\n        immobdpar={\"N\": 0.0056, \"P\": 0.2866},\n        fraction_manure_to_dissolved_inorganic={\"N\": 0.5, \"P\": 0.1},\n        fraction_residue_to_fast={\"N\": 0.1, \"P\": 0.1},\n    ):\n        \"\"\"A class to track nutrient pools in a soil tank, intended to be initialised\n        and called by GrowingSurfaces (see wsimod/nodes/land.py/GrowingSurface) and\n        their subclasses. Contains five pools, which have a storage that tracks the mass\n        of nutrients. Equations and parameters are based on HYPE.\n\n        Args:\n            fraction_dry_n_to_dissolved_inorganic (float, optional): fraction of dry\n            nitrogen deposition going into the soil dissolved inorganic nitrogen pool,\n            with the rest added to the fast pool. Defaults to 0.9. degrhpar (dict,\n            optional): reference humus degradation rate (fraction of humus pool to fast\n            pool). Defaults to {'N' : 7 * 1e-5, 'P' : 7 * 1e-6}. dishpar (dict,\n            optional): reference humus dissolution rate (fraction of humus pool to\n            dissolved organic pool). Defaults to {'N' : 7 * 1e-5, 'P' : 7 * 1e-6}.\n            minfpar (dict, optional): reference fast pool mineralisation rate (fraction\n            of fast pool to dissolved inorganic pool). Defaults to {'N' : 0.00013, 'P' :\n            0.000003}. disfpar (dict, optional): reference fast pool dissolution rate\n            (fraction of fast pool to dissolved organic pool). Defaults to {'N' :\n            0.000003, 'P' : 0.0000001}. immobdpar (dict, optional): reference\n            immobilisation rate (fraction of dissolved inorganic pool to fast pool).\n            Defaults to {'N' : 0.0056, 'P' : 0.2866}.\n            fraction_manure_to_dissolved_inorganic (dict, optional): fraction of\n            nutrients from applied manure to dissolved inorganic pool, with the rest\n            added to the fast pool. Defaults to {'N' : 0.5, 'P' : 0.1}.\n            fraction_residue_to_fast (dict, optional): fraction of nutrients from\n            residue to fast pool, with the rest added to the humus pool. Defaults to\n            {'N' : 0.1, 'P' : 0.1}.\n\n        Key assumptions:\n             - Four nutrient pools are conceptualised for both nitrogen and phosphorus\n                in soil, which includes humus pool, fast pool, dissolved inorganic pool,\n                and dissolved organic pool. Humus and fast pool represent immobile pool\n                of organic nutrients in the soil with slow and fast turnover,\n                respectively. Dissolved inorganic and organic pool represent nutrients\n                in dissolved phase in soil water (for phosphorus, dissolved organic pool\n                might contain particulate phase). Given that phoshphorus can be adsorbed\n                and attached to soil particles, an adsorbed inorganic pool is created\n                specifically for phosphorus.\n             - The major sources of nutrients to soil are conceptualised as\n                - atmospheric deposition:\n                    - dry deposition:\n                        - for nitrogen, inorganic fraction of dry deposition is added to\n                          the dissovled\n                           inorganic pool, while the rest is added to the fast pool;\n                        - for phosphorus, all is added to adsorbed inorganic pool.\n                    - wet deposition: all is added to the dissolved inorganic pool.\n                - fertilisers: all added to the dissolved inorganic pool.\n                - manure: the inorganic fraction is added to the dissovled inorganic\n                  pool, with\n                    the rest added to the fast pool.\n                - residue: the part with fast turnover is added to the fast pool, with\n                  the rest\n                    added to the humus pool.\n             - Nutrient fluxes between these pools are simulated to represent the\n               biochemical processes\n                that can transform the nutrients between different forms. These\n                processes include - degradation of humus pool to fast pool - dissolution\n                of humus pool to dissovled organic pool - mineralisation of fast pool to\n                dissolved inorganic pool - dissolution of fast pool to dissolved organic\n                pool - immobilisation of dissolved inroganic pool to fast pool The rate\n                of these processes are affected by the soil temperature and moisture\n                conditions.\n             - When soil erosion happens, a portion of both the adsorbed inorganic pool\n               and humus pool\n                for phosphorus will be eroded as well.\n\n        Input data and parameter requirements:\n             - fraction_dry_n_to_dissolved_inorganic,\n               fraction_manure_to_dissolved_inorganic, fraction_residue_to_fast.\n                _Units_: -, all should in [0-1]\n             - degrhpar, dishpar, minfpar, disfpar, immobdpar.\n                _Units_: -, all should in [0-1]\n        \"\"\"\n        # TODO I don't think anyone will change most of these params... they could maybe\n        # just be set here\n        self.init_empty()\n\n        # Assign parameters\n        self.temperature_dependence_factor = 0\n        self.soil_moisture_dependence_factor = 0\n\n        self.fraction_manure_to_dissolved_inorganic = (\n            fraction_manure_to_dissolved_inorganic\n        )\n        self.fraction_residue_to_fast = fraction_residue_to_fast\n        self.fraction_dry_n_to_dissolved_inorganic = (\n            fraction_dry_n_to_dissolved_inorganic\n        )\n\n        self.degrhpar = degrhpar\n        self.dishpar = dishpar\n        self.minfpar = minfpar\n        self.disfpar = disfpar\n        self.immobdpar = immobdpar\n\n        self.fraction_manure_to_fast = None\n        self.fraction_residue_to_humus = None\n        self.fraction_dry_n_to_fast = None\n        self.calculate_fraction_parameters()\n\n        # Initialise different pools\n        self.fast_pool = NutrientStore()\n        self.humus_pool = NutrientStore()\n        self.dissolved_inorganic_pool = NutrientStore()\n        self.dissolved_organic_pool = NutrientStore()\n        self.adsorbed_inorganic_pool = NutrientStore()\n        self.pools = [\n            self.fast_pool,\n            self.humus_pool,\n            self.dissolved_inorganic_pool,\n            self.dissolved_organic_pool,\n            self.adsorbed_inorganic_pool,\n        ]\n\n    def calculate_fraction_parameters(self):\n        \"\"\"Update fractions of nutrients input transformed into other forms in soil\n        based on the input parameters\n        Returns:\n            (dict): fraction of manure to fast pool\n            (dict): fraction of plant residue to humus pool\n            (float): fraction of dry nitrogen deposition to fast pool\n        \"\"\"\n        self.fraction_manure_to_fast = {\n            x: 1 - self.fraction_manure_to_dissolved_inorganic[x]\n            for x in constants.NUTRIENTS\n        }\n        self.fraction_residue_to_humus = {\n            x: 1 - self.fraction_residue_to_fast[x] for x in constants.NUTRIENTS\n        }\n        self.fraction_dry_n_to_fast = 1 - self.fraction_dry_n_to_dissolved_inorganic\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        eto_to_e, pore_depth.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.fraction_dry_n_to_dissolved_inorganic = overrides.pop(\n            \"fraction_dry_n_to_dissolved_inorganic\",\n            self.fraction_dry_n_to_dissolved_inorganic,\n        )\n        self.fraction_residue_to_fast.update(\n            overrides.pop(\"fraction_residue_to_fast\", {})\n        )\n        self.fraction_manure_to_dissolved_inorganic.update(\n            overrides.pop(\"fraction_manure_to_dissolved_inorganic\", {})\n        )\n        self.degrhpar.update(overrides.pop(\"degrhpar\", {}))\n        self.dishpar.update(overrides.pop(\"dishpar\", {}))\n        self.minfpar.update(overrides.pop(\"minfpar\", {}))\n        self.disfpar.update(overrides.pop(\"disfpar\", {}))\n        self.immobdpar.update(overrides.pop(\"immobdpar\", {}))\n\n        self.calculate_fraction_parameters()\n\n    def init_empty(self):\n        \"\"\"Initialise an empty nutrient to be copied.\"\"\"\n        self.empty_nutrient = {x: 0 for x in constants.NUTRIENTS}\n\n    def init_store(self):\n        \"\"\"Initialise an empty store to track nutrients.\"\"\"\n        self.init_empty()\n        self.storage = self.get_empty_nutrient()\n\n    def allocate_inorganic_irrigation(self, irrigation):\n        \"\"\"Assign inorganic irrigation, which is assumed to contain dissolved inorganic\n        nutrients and thus updates that pool.\n\n        Args:\n            irrigation (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via irrigation\n\n        Returns:\n            irrigation (dict): irrigation above, because no transformations take place\n                (i.e., dissolved inorganic is what is received and goes straight into\n                that pool)\n        \"\"\"\n        # Update pool\n        self.dissolved_inorganic_pool.receive(irrigation)\n        return irrigation\n\n    def allocate_organic_irrigation(self, irrigation):\n        \"\"\"Assign organic irrigation, which is assumed to contain dissolved organic\n        nutrients and thus updates that pool.\n\n        Args:\n            irrigation (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via irrigation\n\n        Returns:\n            irrigation (dict): irrigation above, because no transformations take place\n                (i.e., dissolved organic is what is received and goes straight into that\n                pool)\n        \"\"\"\n        # Update pool\n        self.dissolved_organic_pool.receive(irrigation)\n        return irrigation\n\n    def allocate_dry_deposition(self, deposition):\n        \"\"\"Assign dry deposition, which is assumed to go to both dissolved inorganic\n        pool and fast pool (nitrogen) and the adsorbed pool (phosphorus).\n\n        Args:\n            deposition (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via dry deposition\n\n        Returns:\n            (dict): A dict describing the amount of nutrients that enter the nutrient\n                pool in a dissolved form (and thus need to be tracked by the soil water\n                tank)\n        \"\"\"\n        # Update pools\n        self.fast_pool.storage[\"N\"] += deposition[\"N\"] * self.fraction_dry_n_to_fast\n        self.dissolved_inorganic_pool.storage[\"N\"] += (\n            deposition[\"N\"] * self.fraction_dry_n_to_dissolved_inorganic\n        )\n        self.adsorbed_inorganic_pool.storage[\"P\"] += deposition[\"P\"]\n        return {\n            \"N\": deposition[\"N\"] * self.fraction_dry_n_to_dissolved_inorganic,\n            \"P\": 0,\n        }\n\n    def allocate_wet_deposition(self, deposition):\n        \"\"\"Assign wet deposition, which is assumed to contain dissolved inorganic\n        nutrients and thus updates that pool.\n\n        Args:\n            deposition (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via wet deposition\n\n        Returns:\n            deposition (dict): deposition above, because no transformations take place\n                (i.e., dissolved inorganic is what is received and goes straight into\n                that pool)\n        \"\"\"\n        # Update pool\n        self.dissolved_inorganic_pool.receive(deposition)\n        return deposition\n\n    def allocate_manure(self, manure):\n        \"\"\"Assign manure, which is assumed to go to both dissolved inorganic pool and\n        fast pool.\n\n        Args:\n            manure (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via manure\n\n        Returns:\n            (dict): A dict describing the amount of nutrients that enter the nutrient\n                pool in a dissolved form (and thus need to be tracked by the soil water\n                tank)\n        \"\"\"\n        # Assign a proportion of nutrients to the dissolved inorganic pool\n        self.dissolved_inorganic_pool.receive(\n            self.multiply_nutrients(manure, self.fraction_manure_to_dissolved_inorganic)\n        )\n        # Assign a proportion of nutrients to the fast pool\n        self.fast_pool.receive(\n            self.multiply_nutrients(manure, self.fraction_manure_to_fast)\n        )\n        return self.multiply_nutrients(\n            manure, self.fraction_manure_to_dissolved_inorganic\n        )\n\n    def allocate_residue(self, residue):\n        \"\"\"Assign residue, which is assumed to go to both humus pool and fast pool.\n\n        Args:\n            residue (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via residue\n\n        Returns:\n            (dict): A dict describing the amount of nutrients that enter the nutrient\n                pool in a dissolved form (and thus need to be tracked by the soil water\n                tank) - i.e., none because fast and humus pool are both solid\n        \"\"\"\n        # Assign a proportion of nutrients to the humus pool\n        self.humus_pool.receive(\n            self.multiply_nutrients(residue, self.fraction_residue_to_humus)\n        )\n        # Assign a proportion of nutrients to the fast pool\n        self.fast_pool.receive(\n            self.multiply_nutrients(residue, self.fraction_residue_to_fast)\n        )\n        return self.empty_nutrient()\n\n    def allocate_fertiliser(self, fertiliser):\n        \"\"\"Assign fertiliser, which is assumed to contain dissolved inorganic nutrients\n        and thus updates that pool.\n\n        Args:\n            fertiliser (dict): A dict that contains the amount of nutrients entering\n                the nutrient pool via fertiliser\n\n        Returns:\n            fertiliser (dict): fertiliser above, because no transformations take place\n                (i.e., dissolved inorganic is what is received and goes straight into\n                that pool)\n        \"\"\"\n        self.dissolved_inorganic_pool.receive(fertiliser)\n        return fertiliser\n\n    def extract_dissolved(self, proportion):\n        \"\"\"Function to extract some amount of nutrients from all dissolved pools.\n\n        Args:\n            proportion (float): proportion of the dissolved nutrient pools to extract\n\n        Returns:\n            (dict): A dict of dicts, where the top level distinguishes between organic\n                and inorganic nutrients, and the bottom level describes how much\n                nutrients (i.e., N and P) have been extracted from those pools\n        \"\"\"\n        # Extract from dissolved inorganic pool\n        reply_di = self.dissolved_inorganic_pool.extract(\n            {\n                \"N\": self.dissolved_inorganic_pool.storage[\"N\"] * proportion,\n                \"P\": self.dissolved_inorganic_pool.storage[\"P\"] * proportion,\n            }\n        )\n\n        # Extract from dissolved organic pool\n        reply_do = self.dissolved_organic_pool.extract(\n            {\n                \"N\": self.dissolved_organic_pool.storage[\"N\"] * proportion,\n                \"P\": self.dissolved_organic_pool.storage[\"P\"] * proportion,\n            }\n        )\n        return {\"organic\": reply_do, \"inorganic\": reply_di}\n\n    def get_erodable_P(self):\n        \"\"\"Return total phosphorus that can be eroded (i.e., humus and adsorbed\n        inorganic pools).\n\n        Returns:\n            (float): total phosphorus\n        \"\"\"\n        return self.adsorbed_inorganic_pool.storage[\"P\"] + self.humus_pool.storage[\"P\"]\n\n    def erode_P(self, amount_P):\n        \"\"\"Update humus and adsorbed inorganic pools to erode some amount. Removed in\n        proportion to amount in both pools.\n\n        Args:\n            amount_P (float): Amount of phosphorus to be eroded\n\n        Returns:\n            (float): Amount of phosphorus eroded from the humus pool (float): Amount of\n            phosphorus eroded from the adsorbed inorganic pool\n        \"\"\"\n        # Calculate proportion of adsorbed to be eroded\n        fraction_adsorbed = self.adsorbed_inorganic_pool.storage[\"P\"] / (\n            self.adsorbed_inorganic_pool.storage[\"P\"] + self.humus_pool.storage[\"P\"]\n        )\n\n        # Update nutrients in a dict holder\n        request = self.get_empty_nutrient()\n\n        # Update inorganic pool\n        request[\"P\"] = amount_P * fraction_adsorbed\n        reply_adsorbed = self.adsorbed_inorganic_pool.extract(request)\n\n        # Update humus pool\n        request[\"P\"] = amount_P * (1 - fraction_adsorbed)\n        reply_humus = self.humus_pool.extract(request)\n\n        return reply_humus[\"P\"], reply_adsorbed[\"P\"]\n\n    def soil_pool_transformation(self):\n        \"\"\"Function to be called by a GrowingSurface that performs and tracks changes\n        resulting from soil transformation processes.\n\n        Returns:\n            (float): increase in dissolved inorganic nutrients resulting from\n                transformations (negative value indicates a decrease)\n            (float): increase in dissolved organic nutrients resulting from\n                transformations (negative value indicates a decrease)\n        \"\"\"\n        # For mass balance purposes, assume fast is inorganic and humus is organic\n\n        # Initialise tracking\n        increase_in_dissolved_inorganic = self.get_empty_nutrient()\n        increase_in_dissolved_organic = self.get_empty_nutrient()\n\n        # Turnover of humus\n        amount = self.temp_soil_process(self.degrhpar, self.humus_pool, self.fast_pool)\n        # This is solid inorganic to solid organic... no tracking needed since solid\n        # nutrients aren't tracked in mass balance of the surface soil water tank!\n\n        # Dissolution of humus\n        amount = self.temp_soil_process(\n            self.dishpar, self.humus_pool, self.dissolved_organic_pool\n        )\n        increase_in_dissolved_organic = self.sum_nutrients(\n            increase_in_dissolved_organic, amount\n        )\n\n        # Turnover of fast\n        amount = self.temp_soil_process(\n            self.minfpar, self.fast_pool, self.dissolved_inorganic_pool\n        )\n        increase_in_dissolved_inorganic = self.sum_nutrients(\n            increase_in_dissolved_inorganic, amount\n        )\n\n        # Dissolution of fast\n        amount = self.temp_soil_process(\n            self.disfpar, self.fast_pool, self.dissolved_organic_pool\n        )\n        increase_in_dissolved_organic = self.sum_nutrients(\n            increase_in_dissolved_organic, amount\n        )\n\n        # Immobilisation\n        amount = self.temp_soil_process(\n            self.immobdpar, self.dissolved_inorganic_pool, self.fast_pool\n        )\n        increase_in_dissolved_inorganic = self.subtract_nutrients(\n            increase_in_dissolved_inorganic, amount\n        )  # TODO will a negative value affect the consequent processes in growing\n        # surface?\n\n        return increase_in_dissolved_inorganic, increase_in_dissolved_organic\n\n    def temp_soil_process(self, parameter, extract_pool, receive_pool):\n        \"\"\"Temperature function to take a parameter, calculate transformation, and\n        remove nutrients from the extract pool and update the receive pool.\n\n        Args:\n            parameter (dict): A dict containing a parameter for each nutrient for the\n            given process\n                (units in per timestep)\n            extract_pool (NutrientStore): The pool to extract from receive_pool\n            (NutrientStore): The pool to receive extracted nutrients\n\n        Returns:\n            to_extract (dict): A dict containing the amount extracted of each nutrient\n            (for mass\n                balance)\n        \"\"\"\n        # Initialise nutrients\n        to_extract = self.get_empty_nutrient()\n        for nutrient in constants.NUTRIENTS:\n            # Calculate\n            to_extract[nutrient] = (\n                parameter[nutrient]\n                * self.temperature_dependence_factor\n                * self.soil_moisture_dependence_factor\n                * extract_pool.storage[nutrient]\n            )\n        # Update pools\n        to_extract = extract_pool.extract(to_extract)\n        receive_pool.receive(to_extract)\n        return to_extract\n\n    def get_empty_nutrient(self):\n        \"\"\"An efficient way to get an empty nutrient.\n\n        Returns:\n            (dict): A dict containing 0 for each nutrient\n        \"\"\"\n        return self.empty_nutrient.copy()\n\n    def multiply_nutrients(self, nutrient, factor):\n        \"\"\"Multiply nutrients by factors.\n\n        Args:\n            nutrient (dict): Dict of nutrients to multiply factor (dict): Dict of\n            factors to multiply for each nutrient\n\n        Returns:\n            (dict): Multiplied nutrients\n        \"\"\"\n        return {x: nutrient[x] * factor[x] for x in constants.NUTRIENTS}\n\n    def receive(self, nutrients):\n        \"\"\"Update nutrient store by amounts.\n\n        Args:\n            nutrients (dict): Amount of nutrients to update store by\n        \"\"\"\n        # Increase storage\n        for nutrient, amount in nutrients.items():\n            self.storage[nutrient] += amount\n\n    def sum_nutrients(self, n1, n2):\n        \"\"\"Sum two nutrients.\n\n        Args:\n            n1 (dict): Dict of nutrients n2 (dict): Dict of nutrients\n\n        Returns:\n            (dict): Summed nutrients\n        \"\"\"\n        reply = self.get_empty_nutrient()\n        for nutrient in constants.NUTRIENTS:\n            reply[nutrient] = n1[nutrient] + n2[nutrient]\n        return reply\n\n    def subtract_nutrients(self, n1, n2):\n        \"\"\"Subtract two nutrients.\n\n        Args:\n            n1 (dict): Dict of nutrients to subtract from n2 (dict): Dict of nutrients\n            to subtract\n\n        Returns:\n            (dict): subtracted nutrients\n        \"\"\"\n        reply = self.get_empty_nutrient()\n        for nutrient in constants.NUTRIENTS:\n            reply[nutrient] = n1[nutrient] - n2[nutrient]\n        return reply\n\n    def extract(self, nutrients):\n        \"\"\"Remove nutrients from a store.\n\n        Args:\n            nutrients (dict): Dict of nutrients to remove from store\n\n        Returns:\n            (dict): amount of nutrients successfully removed\n        \"\"\"\n        reply = self.get_empty_nutrient()\n        for nutrient, amount in nutrients.items():\n            reply[nutrient] = min(self.storage[nutrient], amount)\n            self.storage[nutrient] -= reply[nutrient]\n\n        return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.__init__","title":"<code>__init__(fraction_dry_n_to_dissolved_inorganic=0.9, degrhpar={'N': 7 * 1e-05, 'P': 7 * 1e-06}, dishpar={'N': 7 * 1e-05, 'P': 7 * 1e-06}, minfpar={'N': 0.00013, 'P': 3e-06}, disfpar={'N': 3e-06, 'P': 1e-07}, immobdpar={'N': 0.0056, 'P': 0.2866}, fraction_manure_to_dissolved_inorganic={'N': 0.5, 'P': 0.1}, fraction_residue_to_fast={'N': 0.1, 'P': 0.1})</code>","text":"<p>A class to track nutrient pools in a soil tank, intended to be initialised and called by GrowingSurfaces (see wsimod/nodes/land.py/GrowingSurface) and their subclasses. Contains five pools, which have a storage that tracks the mass of nutrients. Equations and parameters are based on HYPE.</p> <p>Parameters:</p> Name Type Description Default <code>fraction_dry_n_to_dissolved_inorganic</code> <code>float</code> <p>fraction of dry</p> <code>0.9</code> <code>optional)</code> <p>reference humus degradation rate (fraction of humus pool to fast</p> required <code>pool). Defaults to {'N' </code> <p>7 * 1e-5, 'P' : 7 * 1e-6}. dishpar (dict,</p> required <code>optional)</code> <p>reference humus dissolution rate (fraction of humus pool to</p> required <code>dissolved organic pool). Defaults to {'N' </code> <p>7 * 1e-5, 'P' : 7 * 1e-6}.</p> required <code>minfpar</code> <code>dict</code> <p>reference fast pool mineralisation rate (fraction</p> <code>{'N': 0.00013, 'P': 3e-06}</code> <code>of fast pool to dissolved inorganic pool). Defaults to {'N' </code> <p>0.00013, 'P' :</p> required <code>0.000003}. disfpar</code> <code>dict</code> <p>reference fast pool dissolution rate</p> required <code>(fraction of fast pool to dissolved organic pool). Defaults to {'N' </code> required <code>0.000003, 'P' </code> <p>0.0000001}. immobdpar (dict, optional): reference</p> required <code>Defaults to {'N' </code> <p>0.0056, 'P' : 0.2866}.</p> required <code>fraction_manure_to_dissolved_inorganic</code> <code>dict</code> <p>fraction of</p> <code>{'N': 0.5, 'P': 0.1}</code> <code>added to the fast pool. Defaults to {'N' </code> <p>0.5, 'P' : 0.1}.</p> required <code>fraction_residue_to_fast</code> <code>dict</code> <p>fraction of nutrients from</p> <code>{'N': 0.1, 'P': 0.1}</code> <code>{'N' </code> <p>0.1, 'P' : 0.1}.</p> required Key assumptions <ul> <li>Four nutrient pools are conceptualised for both nitrogen and phosphorus    in soil, which includes humus pool, fast pool, dissolved inorganic pool,    and dissolved organic pool. Humus and fast pool represent immobile pool    of organic nutrients in the soil with slow and fast turnover,    respectively. Dissolved inorganic and organic pool represent nutrients    in dissolved phase in soil water (for phosphorus, dissolved organic pool    might contain particulate phase). Given that phoshphorus can be adsorbed    and attached to soil particles, an adsorbed inorganic pool is created    specifically for phosphorus.</li> <li>The major sources of nutrients to soil are conceptualised as</li> <li>atmospheric deposition:<ul> <li>dry deposition:<ul> <li>for nitrogen, inorganic fraction of dry deposition is added to      the dissovled       inorganic pool, while the rest is added to the fast pool;</li> <li>for phosphorus, all is added to adsorbed inorganic pool.</li> </ul> </li> <li>wet deposition: all is added to the dissolved inorganic pool.</li> </ul> </li> <li>fertilisers: all added to the dissolved inorganic pool.</li> <li>manure: the inorganic fraction is added to the dissovled inorganic      pool, with        the rest added to the fast pool.</li> <li>residue: the part with fast turnover is added to the fast pool, with      the rest        added to the humus pool.</li> <li>Nutrient fluxes between these pools are simulated to represent the   biochemical processes    that can transform the nutrients between different forms. These    processes include - degradation of humus pool to fast pool - dissolution    of humus pool to dissovled organic pool - mineralisation of fast pool to    dissolved inorganic pool - dissolution of fast pool to dissolved organic    pool - immobilisation of dissolved inroganic pool to fast pool The rate    of these processes are affected by the soil temperature and moisture    conditions.</li> <li>When soil erosion happens, a portion of both the adsorbed inorganic pool   and humus pool    for phosphorus will be eroded as well.</li> </ul> Input data and parameter requirements <ul> <li>fraction_dry_n_to_dissolved_inorganic,   fraction_manure_to_dissolved_inorganic, fraction_residue_to_fast.    Units: -, all should in [0-1]</li> <li>degrhpar, dishpar, minfpar, disfpar, immobdpar.    Units: -, all should in [0-1]</li> </ul> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def __init__(\n    self,\n    fraction_dry_n_to_dissolved_inorganic=0.9,\n    degrhpar={\"N\": 7 * 1e-5, \"P\": 7 * 1e-6},\n    dishpar={\"N\": 7 * 1e-5, \"P\": 7 * 1e-6},\n    minfpar={\"N\": 0.00013, \"P\": 0.000003},\n    disfpar={\"N\": 0.000003, \"P\": 0.0000001},\n    immobdpar={\"N\": 0.0056, \"P\": 0.2866},\n    fraction_manure_to_dissolved_inorganic={\"N\": 0.5, \"P\": 0.1},\n    fraction_residue_to_fast={\"N\": 0.1, \"P\": 0.1},\n):\n    \"\"\"A class to track nutrient pools in a soil tank, intended to be initialised\n    and called by GrowingSurfaces (see wsimod/nodes/land.py/GrowingSurface) and\n    their subclasses. Contains five pools, which have a storage that tracks the mass\n    of nutrients. Equations and parameters are based on HYPE.\n\n    Args:\n        fraction_dry_n_to_dissolved_inorganic (float, optional): fraction of dry\n        nitrogen deposition going into the soil dissolved inorganic nitrogen pool,\n        with the rest added to the fast pool. Defaults to 0.9. degrhpar (dict,\n        optional): reference humus degradation rate (fraction of humus pool to fast\n        pool). Defaults to {'N' : 7 * 1e-5, 'P' : 7 * 1e-6}. dishpar (dict,\n        optional): reference humus dissolution rate (fraction of humus pool to\n        dissolved organic pool). Defaults to {'N' : 7 * 1e-5, 'P' : 7 * 1e-6}.\n        minfpar (dict, optional): reference fast pool mineralisation rate (fraction\n        of fast pool to dissolved inorganic pool). Defaults to {'N' : 0.00013, 'P' :\n        0.000003}. disfpar (dict, optional): reference fast pool dissolution rate\n        (fraction of fast pool to dissolved organic pool). Defaults to {'N' :\n        0.000003, 'P' : 0.0000001}. immobdpar (dict, optional): reference\n        immobilisation rate (fraction of dissolved inorganic pool to fast pool).\n        Defaults to {'N' : 0.0056, 'P' : 0.2866}.\n        fraction_manure_to_dissolved_inorganic (dict, optional): fraction of\n        nutrients from applied manure to dissolved inorganic pool, with the rest\n        added to the fast pool. Defaults to {'N' : 0.5, 'P' : 0.1}.\n        fraction_residue_to_fast (dict, optional): fraction of nutrients from\n        residue to fast pool, with the rest added to the humus pool. Defaults to\n        {'N' : 0.1, 'P' : 0.1}.\n\n    Key assumptions:\n         - Four nutrient pools are conceptualised for both nitrogen and phosphorus\n            in soil, which includes humus pool, fast pool, dissolved inorganic pool,\n            and dissolved organic pool. Humus and fast pool represent immobile pool\n            of organic nutrients in the soil with slow and fast turnover,\n            respectively. Dissolved inorganic and organic pool represent nutrients\n            in dissolved phase in soil water (for phosphorus, dissolved organic pool\n            might contain particulate phase). Given that phoshphorus can be adsorbed\n            and attached to soil particles, an adsorbed inorganic pool is created\n            specifically for phosphorus.\n         - The major sources of nutrients to soil are conceptualised as\n            - atmospheric deposition:\n                - dry deposition:\n                    - for nitrogen, inorganic fraction of dry deposition is added to\n                      the dissovled\n                       inorganic pool, while the rest is added to the fast pool;\n                    - for phosphorus, all is added to adsorbed inorganic pool.\n                - wet deposition: all is added to the dissolved inorganic pool.\n            - fertilisers: all added to the dissolved inorganic pool.\n            - manure: the inorganic fraction is added to the dissovled inorganic\n              pool, with\n                the rest added to the fast pool.\n            - residue: the part with fast turnover is added to the fast pool, with\n              the rest\n                added to the humus pool.\n         - Nutrient fluxes between these pools are simulated to represent the\n           biochemical processes\n            that can transform the nutrients between different forms. These\n            processes include - degradation of humus pool to fast pool - dissolution\n            of humus pool to dissovled organic pool - mineralisation of fast pool to\n            dissolved inorganic pool - dissolution of fast pool to dissolved organic\n            pool - immobilisation of dissolved inroganic pool to fast pool The rate\n            of these processes are affected by the soil temperature and moisture\n            conditions.\n         - When soil erosion happens, a portion of both the adsorbed inorganic pool\n           and humus pool\n            for phosphorus will be eroded as well.\n\n    Input data and parameter requirements:\n         - fraction_dry_n_to_dissolved_inorganic,\n           fraction_manure_to_dissolved_inorganic, fraction_residue_to_fast.\n            _Units_: -, all should in [0-1]\n         - degrhpar, dishpar, minfpar, disfpar, immobdpar.\n            _Units_: -, all should in [0-1]\n    \"\"\"\n    # TODO I don't think anyone will change most of these params... they could maybe\n    # just be set here\n    self.init_empty()\n\n    # Assign parameters\n    self.temperature_dependence_factor = 0\n    self.soil_moisture_dependence_factor = 0\n\n    self.fraction_manure_to_dissolved_inorganic = (\n        fraction_manure_to_dissolved_inorganic\n    )\n    self.fraction_residue_to_fast = fraction_residue_to_fast\n    self.fraction_dry_n_to_dissolved_inorganic = (\n        fraction_dry_n_to_dissolved_inorganic\n    )\n\n    self.degrhpar = degrhpar\n    self.dishpar = dishpar\n    self.minfpar = minfpar\n    self.disfpar = disfpar\n    self.immobdpar = immobdpar\n\n    self.fraction_manure_to_fast = None\n    self.fraction_residue_to_humus = None\n    self.fraction_dry_n_to_fast = None\n    self.calculate_fraction_parameters()\n\n    # Initialise different pools\n    self.fast_pool = NutrientStore()\n    self.humus_pool = NutrientStore()\n    self.dissolved_inorganic_pool = NutrientStore()\n    self.dissolved_organic_pool = NutrientStore()\n    self.adsorbed_inorganic_pool = NutrientStore()\n    self.pools = [\n        self.fast_pool,\n        self.humus_pool,\n        self.dissolved_inorganic_pool,\n        self.dissolved_organic_pool,\n        self.adsorbed_inorganic_pool,\n    ]\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_dry_deposition","title":"<code>allocate_dry_deposition(deposition)</code>","text":"<p>Assign dry deposition, which is assumed to go to both dissolved inorganic pool and fast pool (nitrogen) and the adsorbed pool (phosphorus).</p> <p>Parameters:</p> Name Type Description Default <code>deposition</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via dry deposition</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict describing the amount of nutrients that enter the nutrient pool in a dissolved form (and thus need to be tracked by the soil water tank)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_dry_deposition(self, deposition):\n    \"\"\"Assign dry deposition, which is assumed to go to both dissolved inorganic\n    pool and fast pool (nitrogen) and the adsorbed pool (phosphorus).\n\n    Args:\n        deposition (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via dry deposition\n\n    Returns:\n        (dict): A dict describing the amount of nutrients that enter the nutrient\n            pool in a dissolved form (and thus need to be tracked by the soil water\n            tank)\n    \"\"\"\n    # Update pools\n    self.fast_pool.storage[\"N\"] += deposition[\"N\"] * self.fraction_dry_n_to_fast\n    self.dissolved_inorganic_pool.storage[\"N\"] += (\n        deposition[\"N\"] * self.fraction_dry_n_to_dissolved_inorganic\n    )\n    self.adsorbed_inorganic_pool.storage[\"P\"] += deposition[\"P\"]\n    return {\n        \"N\": deposition[\"N\"] * self.fraction_dry_n_to_dissolved_inorganic,\n        \"P\": 0,\n    }\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_fertiliser","title":"<code>allocate_fertiliser(fertiliser)</code>","text":"<p>Assign fertiliser, which is assumed to contain dissolved inorganic nutrients and thus updates that pool.</p> <p>Parameters:</p> Name Type Description Default <code>fertiliser</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via fertiliser</p> required <p>Returns:</p> Name Type Description <code>fertiliser</code> <code>dict</code> <p>fertiliser above, because no transformations take place (i.e., dissolved inorganic is what is received and goes straight into that pool)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_fertiliser(self, fertiliser):\n    \"\"\"Assign fertiliser, which is assumed to contain dissolved inorganic nutrients\n    and thus updates that pool.\n\n    Args:\n        fertiliser (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via fertiliser\n\n    Returns:\n        fertiliser (dict): fertiliser above, because no transformations take place\n            (i.e., dissolved inorganic is what is received and goes straight into\n            that pool)\n    \"\"\"\n    self.dissolved_inorganic_pool.receive(fertiliser)\n    return fertiliser\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_inorganic_irrigation","title":"<code>allocate_inorganic_irrigation(irrigation)</code>","text":"<p>Assign inorganic irrigation, which is assumed to contain dissolved inorganic nutrients and thus updates that pool.</p> <p>Parameters:</p> Name Type Description Default <code>irrigation</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via irrigation</p> required <p>Returns:</p> Name Type Description <code>irrigation</code> <code>dict</code> <p>irrigation above, because no transformations take place (i.e., dissolved inorganic is what is received and goes straight into that pool)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_inorganic_irrigation(self, irrigation):\n    \"\"\"Assign inorganic irrigation, which is assumed to contain dissolved inorganic\n    nutrients and thus updates that pool.\n\n    Args:\n        irrigation (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via irrigation\n\n    Returns:\n        irrigation (dict): irrigation above, because no transformations take place\n            (i.e., dissolved inorganic is what is received and goes straight into\n            that pool)\n    \"\"\"\n    # Update pool\n    self.dissolved_inorganic_pool.receive(irrigation)\n    return irrigation\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_manure","title":"<code>allocate_manure(manure)</code>","text":"<p>Assign manure, which is assumed to go to both dissolved inorganic pool and fast pool.</p> <p>Parameters:</p> Name Type Description Default <code>manure</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via manure</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict describing the amount of nutrients that enter the nutrient pool in a dissolved form (and thus need to be tracked by the soil water tank)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_manure(self, manure):\n    \"\"\"Assign manure, which is assumed to go to both dissolved inorganic pool and\n    fast pool.\n\n    Args:\n        manure (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via manure\n\n    Returns:\n        (dict): A dict describing the amount of nutrients that enter the nutrient\n            pool in a dissolved form (and thus need to be tracked by the soil water\n            tank)\n    \"\"\"\n    # Assign a proportion of nutrients to the dissolved inorganic pool\n    self.dissolved_inorganic_pool.receive(\n        self.multiply_nutrients(manure, self.fraction_manure_to_dissolved_inorganic)\n    )\n    # Assign a proportion of nutrients to the fast pool\n    self.fast_pool.receive(\n        self.multiply_nutrients(manure, self.fraction_manure_to_fast)\n    )\n    return self.multiply_nutrients(\n        manure, self.fraction_manure_to_dissolved_inorganic\n    )\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_organic_irrigation","title":"<code>allocate_organic_irrigation(irrigation)</code>","text":"<p>Assign organic irrigation, which is assumed to contain dissolved organic nutrients and thus updates that pool.</p> <p>Parameters:</p> Name Type Description Default <code>irrigation</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via irrigation</p> required <p>Returns:</p> Name Type Description <code>irrigation</code> <code>dict</code> <p>irrigation above, because no transformations take place (i.e., dissolved organic is what is received and goes straight into that pool)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_organic_irrigation(self, irrigation):\n    \"\"\"Assign organic irrigation, which is assumed to contain dissolved organic\n    nutrients and thus updates that pool.\n\n    Args:\n        irrigation (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via irrigation\n\n    Returns:\n        irrigation (dict): irrigation above, because no transformations take place\n            (i.e., dissolved organic is what is received and goes straight into that\n            pool)\n    \"\"\"\n    # Update pool\n    self.dissolved_organic_pool.receive(irrigation)\n    return irrigation\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_residue","title":"<code>allocate_residue(residue)</code>","text":"<p>Assign residue, which is assumed to go to both humus pool and fast pool.</p> <p>Parameters:</p> Name Type Description Default <code>residue</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via residue</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict describing the amount of nutrients that enter the nutrient pool in a dissolved form (and thus need to be tracked by the soil water tank) - i.e., none because fast and humus pool are both solid</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_residue(self, residue):\n    \"\"\"Assign residue, which is assumed to go to both humus pool and fast pool.\n\n    Args:\n        residue (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via residue\n\n    Returns:\n        (dict): A dict describing the amount of nutrients that enter the nutrient\n            pool in a dissolved form (and thus need to be tracked by the soil water\n            tank) - i.e., none because fast and humus pool are both solid\n    \"\"\"\n    # Assign a proportion of nutrients to the humus pool\n    self.humus_pool.receive(\n        self.multiply_nutrients(residue, self.fraction_residue_to_humus)\n    )\n    # Assign a proportion of nutrients to the fast pool\n    self.fast_pool.receive(\n        self.multiply_nutrients(residue, self.fraction_residue_to_fast)\n    )\n    return self.empty_nutrient()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.allocate_wet_deposition","title":"<code>allocate_wet_deposition(deposition)</code>","text":"<p>Assign wet deposition, which is assumed to contain dissolved inorganic nutrients and thus updates that pool.</p> <p>Parameters:</p> Name Type Description Default <code>deposition</code> <code>dict</code> <p>A dict that contains the amount of nutrients entering the nutrient pool via wet deposition</p> required <p>Returns:</p> Name Type Description <code>deposition</code> <code>dict</code> <p>deposition above, because no transformations take place (i.e., dissolved inorganic is what is received and goes straight into that pool)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def allocate_wet_deposition(self, deposition):\n    \"\"\"Assign wet deposition, which is assumed to contain dissolved inorganic\n    nutrients and thus updates that pool.\n\n    Args:\n        deposition (dict): A dict that contains the amount of nutrients entering\n            the nutrient pool via wet deposition\n\n    Returns:\n        deposition (dict): deposition above, because no transformations take place\n            (i.e., dissolved inorganic is what is received and goes straight into\n            that pool)\n    \"\"\"\n    # Update pool\n    self.dissolved_inorganic_pool.receive(deposition)\n    return deposition\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: eto_to_e, pore_depth.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    eto_to_e, pore_depth.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.fraction_dry_n_to_dissolved_inorganic = overrides.pop(\n        \"fraction_dry_n_to_dissolved_inorganic\",\n        self.fraction_dry_n_to_dissolved_inorganic,\n    )\n    self.fraction_residue_to_fast.update(\n        overrides.pop(\"fraction_residue_to_fast\", {})\n    )\n    self.fraction_manure_to_dissolved_inorganic.update(\n        overrides.pop(\"fraction_manure_to_dissolved_inorganic\", {})\n    )\n    self.degrhpar.update(overrides.pop(\"degrhpar\", {}))\n    self.dishpar.update(overrides.pop(\"dishpar\", {}))\n    self.minfpar.update(overrides.pop(\"minfpar\", {}))\n    self.disfpar.update(overrides.pop(\"disfpar\", {}))\n    self.immobdpar.update(overrides.pop(\"immobdpar\", {}))\n\n    self.calculate_fraction_parameters()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.calculate_fraction_parameters","title":"<code>calculate_fraction_parameters()</code>","text":"<p>Update fractions of nutrients input transformed into other forms in soil based on the input parameters Returns:     (dict): fraction of manure to fast pool     (dict): fraction of plant residue to humus pool     (float): fraction of dry nitrogen deposition to fast pool</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def calculate_fraction_parameters(self):\n    \"\"\"Update fractions of nutrients input transformed into other forms in soil\n    based on the input parameters\n    Returns:\n        (dict): fraction of manure to fast pool\n        (dict): fraction of plant residue to humus pool\n        (float): fraction of dry nitrogen deposition to fast pool\n    \"\"\"\n    self.fraction_manure_to_fast = {\n        x: 1 - self.fraction_manure_to_dissolved_inorganic[x]\n        for x in constants.NUTRIENTS\n    }\n    self.fraction_residue_to_humus = {\n        x: 1 - self.fraction_residue_to_fast[x] for x in constants.NUTRIENTS\n    }\n    self.fraction_dry_n_to_fast = 1 - self.fraction_dry_n_to_dissolved_inorganic\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.erode_P","title":"<code>erode_P(amount_P)</code>","text":"<p>Update humus and adsorbed inorganic pools to erode some amount. Removed in proportion to amount in both pools.</p> <p>Parameters:</p> Name Type Description Default <code>amount_P</code> <code>float</code> <p>Amount of phosphorus to be eroded</p> required <p>Returns:</p> Type Description <code>float): Amount of phosphorus eroded from the humus pool (float</code> <p>Amount of</p> <p>phosphorus eroded from the adsorbed inorganic pool</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def erode_P(self, amount_P):\n    \"\"\"Update humus and adsorbed inorganic pools to erode some amount. Removed in\n    proportion to amount in both pools.\n\n    Args:\n        amount_P (float): Amount of phosphorus to be eroded\n\n    Returns:\n        (float): Amount of phosphorus eroded from the humus pool (float): Amount of\n        phosphorus eroded from the adsorbed inorganic pool\n    \"\"\"\n    # Calculate proportion of adsorbed to be eroded\n    fraction_adsorbed = self.adsorbed_inorganic_pool.storage[\"P\"] / (\n        self.adsorbed_inorganic_pool.storage[\"P\"] + self.humus_pool.storage[\"P\"]\n    )\n\n    # Update nutrients in a dict holder\n    request = self.get_empty_nutrient()\n\n    # Update inorganic pool\n    request[\"P\"] = amount_P * fraction_adsorbed\n    reply_adsorbed = self.adsorbed_inorganic_pool.extract(request)\n\n    # Update humus pool\n    request[\"P\"] = amount_P * (1 - fraction_adsorbed)\n    reply_humus = self.humus_pool.extract(request)\n\n    return reply_humus[\"P\"], reply_adsorbed[\"P\"]\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.extract","title":"<code>extract(nutrients)</code>","text":"<p>Remove nutrients from a store.</p> <p>Parameters:</p> Name Type Description Default <code>nutrients</code> <code>dict</code> <p>Dict of nutrients to remove from store</p> required <p>Returns:</p> Type Description <code>dict</code> <p>amount of nutrients successfully removed</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def extract(self, nutrients):\n    \"\"\"Remove nutrients from a store.\n\n    Args:\n        nutrients (dict): Dict of nutrients to remove from store\n\n    Returns:\n        (dict): amount of nutrients successfully removed\n    \"\"\"\n    reply = self.get_empty_nutrient()\n    for nutrient, amount in nutrients.items():\n        reply[nutrient] = min(self.storage[nutrient], amount)\n        self.storage[nutrient] -= reply[nutrient]\n\n    return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.extract_dissolved","title":"<code>extract_dissolved(proportion)</code>","text":"<p>Function to extract some amount of nutrients from all dissolved pools.</p> <p>Parameters:</p> Name Type Description Default <code>proportion</code> <code>float</code> <p>proportion of the dissolved nutrient pools to extract</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dict of dicts, where the top level distinguishes between organic and inorganic nutrients, and the bottom level describes how much nutrients (i.e., N and P) have been extracted from those pools</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def extract_dissolved(self, proportion):\n    \"\"\"Function to extract some amount of nutrients from all dissolved pools.\n\n    Args:\n        proportion (float): proportion of the dissolved nutrient pools to extract\n\n    Returns:\n        (dict): A dict of dicts, where the top level distinguishes between organic\n            and inorganic nutrients, and the bottom level describes how much\n            nutrients (i.e., N and P) have been extracted from those pools\n    \"\"\"\n    # Extract from dissolved inorganic pool\n    reply_di = self.dissolved_inorganic_pool.extract(\n        {\n            \"N\": self.dissolved_inorganic_pool.storage[\"N\"] * proportion,\n            \"P\": self.dissolved_inorganic_pool.storage[\"P\"] * proportion,\n        }\n    )\n\n    # Extract from dissolved organic pool\n    reply_do = self.dissolved_organic_pool.extract(\n        {\n            \"N\": self.dissolved_organic_pool.storage[\"N\"] * proportion,\n            \"P\": self.dissolved_organic_pool.storage[\"P\"] * proportion,\n        }\n    )\n    return {\"organic\": reply_do, \"inorganic\": reply_di}\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.get_empty_nutrient","title":"<code>get_empty_nutrient()</code>","text":"<p>An efficient way to get an empty nutrient.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict containing 0 for each nutrient</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def get_empty_nutrient(self):\n    \"\"\"An efficient way to get an empty nutrient.\n\n    Returns:\n        (dict): A dict containing 0 for each nutrient\n    \"\"\"\n    return self.empty_nutrient.copy()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.get_erodable_P","title":"<code>get_erodable_P()</code>","text":"<p>Return total phosphorus that can be eroded (i.e., humus and adsorbed inorganic pools).</p> <p>Returns:</p> Type Description <code>float</code> <p>total phosphorus</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def get_erodable_P(self):\n    \"\"\"Return total phosphorus that can be eroded (i.e., humus and adsorbed\n    inorganic pools).\n\n    Returns:\n        (float): total phosphorus\n    \"\"\"\n    return self.adsorbed_inorganic_pool.storage[\"P\"] + self.humus_pool.storage[\"P\"]\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.init_empty","title":"<code>init_empty()</code>","text":"<p>Initialise an empty nutrient to be copied.</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def init_empty(self):\n    \"\"\"Initialise an empty nutrient to be copied.\"\"\"\n    self.empty_nutrient = {x: 0 for x in constants.NUTRIENTS}\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.init_store","title":"<code>init_store()</code>","text":"<p>Initialise an empty store to track nutrients.</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def init_store(self):\n    \"\"\"Initialise an empty store to track nutrients.\"\"\"\n    self.init_empty()\n    self.storage = self.get_empty_nutrient()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.multiply_nutrients","title":"<code>multiply_nutrients(nutrient, factor)</code>","text":"<p>Multiply nutrients by factors.</p> <p>Parameters:</p> Name Type Description Default <code>nutrient</code> <code>dict</code> <p>Dict of nutrients to multiply factor (dict): Dict of</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Multiplied nutrients</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def multiply_nutrients(self, nutrient, factor):\n    \"\"\"Multiply nutrients by factors.\n\n    Args:\n        nutrient (dict): Dict of nutrients to multiply factor (dict): Dict of\n        factors to multiply for each nutrient\n\n    Returns:\n        (dict): Multiplied nutrients\n    \"\"\"\n    return {x: nutrient[x] * factor[x] for x in constants.NUTRIENTS}\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.receive","title":"<code>receive(nutrients)</code>","text":"<p>Update nutrient store by amounts.</p> <p>Parameters:</p> Name Type Description Default <code>nutrients</code> <code>dict</code> <p>Amount of nutrients to update store by</p> required Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def receive(self, nutrients):\n    \"\"\"Update nutrient store by amounts.\n\n    Args:\n        nutrients (dict): Amount of nutrients to update store by\n    \"\"\"\n    # Increase storage\n    for nutrient, amount in nutrients.items():\n        self.storage[nutrient] += amount\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.soil_pool_transformation","title":"<code>soil_pool_transformation()</code>","text":"<p>Function to be called by a GrowingSurface that performs and tracks changes resulting from soil transformation processes.</p> <p>Returns:</p> Type Description <code>float</code> <p>increase in dissolved inorganic nutrients resulting from transformations (negative value indicates a decrease)</p> <code>float</code> <p>increase in dissolved organic nutrients resulting from transformations (negative value indicates a decrease)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def soil_pool_transformation(self):\n    \"\"\"Function to be called by a GrowingSurface that performs and tracks changes\n    resulting from soil transformation processes.\n\n    Returns:\n        (float): increase in dissolved inorganic nutrients resulting from\n            transformations (negative value indicates a decrease)\n        (float): increase in dissolved organic nutrients resulting from\n            transformations (negative value indicates a decrease)\n    \"\"\"\n    # For mass balance purposes, assume fast is inorganic and humus is organic\n\n    # Initialise tracking\n    increase_in_dissolved_inorganic = self.get_empty_nutrient()\n    increase_in_dissolved_organic = self.get_empty_nutrient()\n\n    # Turnover of humus\n    amount = self.temp_soil_process(self.degrhpar, self.humus_pool, self.fast_pool)\n    # This is solid inorganic to solid organic... no tracking needed since solid\n    # nutrients aren't tracked in mass balance of the surface soil water tank!\n\n    # Dissolution of humus\n    amount = self.temp_soil_process(\n        self.dishpar, self.humus_pool, self.dissolved_organic_pool\n    )\n    increase_in_dissolved_organic = self.sum_nutrients(\n        increase_in_dissolved_organic, amount\n    )\n\n    # Turnover of fast\n    amount = self.temp_soil_process(\n        self.minfpar, self.fast_pool, self.dissolved_inorganic_pool\n    )\n    increase_in_dissolved_inorganic = self.sum_nutrients(\n        increase_in_dissolved_inorganic, amount\n    )\n\n    # Dissolution of fast\n    amount = self.temp_soil_process(\n        self.disfpar, self.fast_pool, self.dissolved_organic_pool\n    )\n    increase_in_dissolved_organic = self.sum_nutrients(\n        increase_in_dissolved_organic, amount\n    )\n\n    # Immobilisation\n    amount = self.temp_soil_process(\n        self.immobdpar, self.dissolved_inorganic_pool, self.fast_pool\n    )\n    increase_in_dissolved_inorganic = self.subtract_nutrients(\n        increase_in_dissolved_inorganic, amount\n    )  # TODO will a negative value affect the consequent processes in growing\n    # surface?\n\n    return increase_in_dissolved_inorganic, increase_in_dissolved_organic\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.subtract_nutrients","title":"<code>subtract_nutrients(n1, n2)</code>","text":"<p>Subtract two nutrients.</p> <p>Parameters:</p> Name Type Description Default <code>n1</code> <code>dict</code> <p>Dict of nutrients to subtract from n2 (dict): Dict of nutrients</p> required <p>Returns:</p> Type Description <code>dict</code> <p>subtracted nutrients</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def subtract_nutrients(self, n1, n2):\n    \"\"\"Subtract two nutrients.\n\n    Args:\n        n1 (dict): Dict of nutrients to subtract from n2 (dict): Dict of nutrients\n        to subtract\n\n    Returns:\n        (dict): subtracted nutrients\n    \"\"\"\n    reply = self.get_empty_nutrient()\n    for nutrient in constants.NUTRIENTS:\n        reply[nutrient] = n1[nutrient] - n2[nutrient]\n    return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.sum_nutrients","title":"<code>sum_nutrients(n1, n2)</code>","text":"<p>Sum two nutrients.</p> <p>Parameters:</p> Name Type Description Default <code>n1</code> <code>dict</code> <p>Dict of nutrients n2 (dict): Dict of nutrients</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Summed nutrients</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def sum_nutrients(self, n1, n2):\n    \"\"\"Sum two nutrients.\n\n    Args:\n        n1 (dict): Dict of nutrients n2 (dict): Dict of nutrients\n\n    Returns:\n        (dict): Summed nutrients\n    \"\"\"\n    reply = self.get_empty_nutrient()\n    for nutrient in constants.NUTRIENTS:\n        reply[nutrient] = n1[nutrient] + n2[nutrient]\n    return reply\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientPool.temp_soil_process","title":"<code>temp_soil_process(parameter, extract_pool, receive_pool)</code>","text":"<p>Temperature function to take a parameter, calculate transformation, and remove nutrients from the extract pool and update the receive pool.</p> <p>Parameters:</p> Name Type Description Default <code>parameter</code> <code>dict</code> <p>A dict containing a parameter for each nutrient for the</p> required <code>extract_pool</code> <code>NutrientStore</code> <p>The pool to extract from receive_pool</p> required <code></code> <code>NutrientStore</code> <p>The pool to receive extracted nutrients</p> required <p>Returns:</p> Name Type Description <code>to_extract</code> <code>dict</code> <p>A dict containing the amount extracted of each nutrient</p> <p>(for mass balance)</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def temp_soil_process(self, parameter, extract_pool, receive_pool):\n    \"\"\"Temperature function to take a parameter, calculate transformation, and\n    remove nutrients from the extract pool and update the receive pool.\n\n    Args:\n        parameter (dict): A dict containing a parameter for each nutrient for the\n        given process\n            (units in per timestep)\n        extract_pool (NutrientStore): The pool to extract from receive_pool\n        (NutrientStore): The pool to receive extracted nutrients\n\n    Returns:\n        to_extract (dict): A dict containing the amount extracted of each nutrient\n        (for mass\n            balance)\n    \"\"\"\n    # Initialise nutrients\n    to_extract = self.get_empty_nutrient()\n    for nutrient in constants.NUTRIENTS:\n        # Calculate\n        to_extract[nutrient] = (\n            parameter[nutrient]\n            * self.temperature_dependence_factor\n            * self.soil_moisture_dependence_factor\n            * extract_pool.storage[nutrient]\n        )\n    # Update pools\n    to_extract = extract_pool.extract(to_extract)\n    receive_pool.receive(to_extract)\n    return to_extract\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientStore","title":"<code>NutrientStore</code>","text":"<p>               Bases: <code>NutrientPool</code></p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>class NutrientStore(NutrientPool):\n    \"\"\"\"\"\"\n\n    def __init__(self):\n        \"\"\"Nutrient store, to be instantiated by a NutrientPool.\"\"\"\n        super().init_store()\n</code></pre>"},{"location":"reference-land/#wsimod.nodes.nutrient_pool.NutrientStore.__init__","title":"<code>__init__()</code>","text":"<p>Nutrient store, to be instantiated by a NutrientPool.</p> Source code in <code>wsimod/nodes/nutrient_pool.py</code> <pre><code>def __init__(self):\n    \"\"\"Nutrient store, to be instantiated by a NutrientPool.\"\"\"\n    super().init_store()\n</code></pre>"},{"location":"reference-model/","title":"API Reference - Model","text":"<p>This section of the documentation provides a reference for the API of the orchestration.model module</p> <p>Created on Mon Jul  4 16:01:48 2022.</p> <p>@author: bdobson</p>"},{"location":"reference-model/#wsimod.orchestration.model.Model","title":"<code>Model</code>","text":"<p>               Bases: <code>WSIObj</code></p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>class Model(WSIObj):\n    \"\"\"\"\"\"\n\n    def __init__(self):\n        \"\"\"Object to contain nodes and arcs that provides a default orchestration.\n\n        Returns:\n            Model: An empty model object\n        \"\"\"\n        super().__init__()\n        self.arcs = {}\n        # self.arcs_type = {} #not sure that this would be necessary\n        self.nodes = {}\n        self.nodes_type = {}\n        self.extensions = []\n        self.river_discharge_order = []\n\n        # Default orchestration\n        self.orchestration = [\n            {\"FWTW\": \"treat_water\"},\n            {\"Demand\": \"create_demand\"},\n            {\"Land\": \"run\"},\n            {\"Groundwater\": \"infiltrate\"},\n            {\"Sewer\": \"make_discharge\"},\n            {\"Foul\": \"make_discharge\"},\n            {\"WWTW\": \"calculate_discharge\"},\n            {\"Groundwater\": \"distribute\"},\n            {\"River\": \"calculate_discharge\"},\n            {\"Reservoir\": \"make_abstractions\"},\n            {\"Land\": \"apply_irrigation\"},\n            {\"WWTW\": \"make_discharge\"},\n            {\"Catchment\": \"route\"},\n        ]\n\n    def get_init_args(self, cls):\n        \"\"\"Get the arguments of the __init__ method for a class and its superclasses.\"\"\"\n        init_args = []\n        for c in cls.__mro__:\n            # Get the arguments of the __init__ method\n            args = inspect.getfullargspec(c.__init__).args[1:]\n            init_args.extend(args)\n        return init_args\n\n    def load(self, address, config_name=\"config.yml\", overrides={}):\n        \"\"\"\n\n        Args:\n            address:\n            config_name:\n            overrides:\n        \"\"\"\n        from ..extensions import apply_patches\n\n        with open(os.path.join(address, config_name), \"r\") as file:\n            data: dict = yaml.safe_load(file)\n\n        for key, item in overrides.items():\n            data[key] = item\n\n        constants.POLLUTANTS = data.get(\"pollutants\", constants.POLLUTANTS)\n        constants.ADDITIVE_POLLUTANTS = data.get(\n            \"additive_pollutants\", constants.ADDITIVE_POLLUTANTS\n        )\n        constants.NON_ADDITIVE_POLLUTANTS = data.get(\n            \"non_additive_pollutants\", constants.NON_ADDITIVE_POLLUTANTS\n        )\n        constants.FLOAT_ACCURACY = float(\n            data.get(\"float_accuracy\", constants.FLOAT_ACCURACY)\n        )\n        self.__dict__.update(Model().__dict__)\n\n        \"\"\"\n        FLAG:\n            E.G. ADDITION FOR NEW ORCHESTRATION\n        \"\"\"\n        load_extension_files(data.get(\"extensions\", []))\n        self.extensions = data.get(\"extensions\", [])\n\n        if \"orchestration\" in data.keys():\n            # Update orchestration\n            self.orchestration = data[\"orchestration\"]\n\n        if \"nodes\" not in data.keys():\n            raise ValueError(\"No nodes found in the config\")\n\n        nodes = data[\"nodes\"]\n\n        # Check if using unified data file\n        unified_data_file = data.get(\"unified_data_file\")\n        if unified_data_file and PARQUET_AVAILABLE:\n            self._load_unified_data(address, unified_data_file, nodes, data)\n        elif unified_data_file and not PARQUET_AVAILABLE:\n            raise ValueError(\"Parquet support is required for unified data loading\")\n        else:\n            self._load_individual_files(address, nodes, data)\n        arcs = data.get(\"arcs\", {})\n        self.add_nodes(list(nodes.values()))\n        self.add_arcs(list(arcs.values()))\n\n        self.add_overrides(data.get(\"overrides\", {}))\n\n        apply_patches(self)\n\n    def _load_unified_data(self, address, unified_data_file, nodes, data):\n        \"\"\"Load model data from a unified parquet file.\n\n        Args:\n            address (str): Path to directory containing the unified data file\n            unified_data_file (str): Name of the unified parquet file\n            nodes (dict): Dictionary of node configurations\n            data (dict): Full configuration dictionary\n        \"\"\"\n        # Load unified data\n        unified_data_path = os.path.join(address, unified_data_file)\n        self.unified_data = pd.read_parquet(unified_data_path)\n\n        # Create a single comprehensive data dictionary for all nodes\n        # This is much faster than individual lookups\n        surface_data = self.unified_data.dropna(subset=[\"surface\"]).copy()\n        surface_data[\"time\"] = pd.to_datetime(surface_data[\"time\"]).dt.to_period(\"M\")\n        surface_dict = (\n            surface_data.groupby([\"node\", \"surface\"])\n            .apply(lambda x: x.set_index([\"variable\", \"time\"]).value.to_dict())\n            .to_dict()\n        )\n\n        node_data = self.unified_data.loc[self.unified_data.surface.isna()].copy()\n        node_data[\"time\"] = pd.to_datetime(node_data[\"time\"])\n        node_dict = (\n            node_data.groupby(\"node\")\n            .apply(lambda x: x.set_index([\"variable\", \"time\"]).value.to_dict())\n            .to_dict()\n        )\n\n        # Assign the same comprehensive data dict to all nodes that need it\n        for name, node in nodes.items():\n            if \"data_input_dict\" in node.keys() and node[\"data_input_dict\"]:\n                node[\"data_input_dict\"] = node_dict[name]\n            if \"surfaces\" in node.keys():\n                for key, surface in node[\"surfaces\"].items():\n                    if (\n                        \"data_input_dict\" in surface.keys()\n                        and surface[\"data_input_dict\"]\n                    ):\n                        node[\"surfaces\"][key][\"data_input_dict\"] = surface_dict[\n                            (name, key)\n                        ]\n                node[\"surfaces\"] = list(node[\"surfaces\"].values())\n        if \"dates\" in data.keys():\n            self.dates = pd.to_datetime(data[\"dates\"])\n\n    def _load_individual_files(self, address, nodes, data):\n        \"\"\"Load model data from individual CSV files (original behavior).\n\n        Args:\n            address (str): Path to directory containing the data files\n            nodes (dict): Dictionary of node configurations\n            data (dict): Full configuration dictionary\n        \"\"\"\n        # Use individual files (original behavior)\n        for name, node in nodes.items():\n            if \"filename\" in node.keys():\n                node[\"data_input_dict\"] = read_csv(\n                    os.path.join(address, node[\"filename\"])\n                )\n                del node[\"filename\"]\n            if \"surfaces\" in node.keys():\n                for key, surface in node[\"surfaces\"].items():\n                    if \"filename\" in surface.keys():\n                        node[\"surfaces\"][key][\"data_input_dict\"] = read_csv(\n                            os.path.join(address, surface[\"filename\"])\n                        )\n                        del surface[\"filename\"]\n                node[\"surfaces\"] = list(node[\"surfaces\"].values())\n        if \"dates\" in data.keys():\n            self.dates = [to_datetime(x) for x in data[\"dates\"]]\n\n    def save(self, address, config_name=\"config.yml\", compress=False):\n        \"\"\"Save the model object to a yaml file and input data to csv.gz format in the\n        directory specified.\n\n        Args:\n            address (str): Path to a directory\n            config_name (str, optional): Name of yaml model file.\n                Defaults to 'model.yml'\n        \"\"\"\n        if not os.path.exists(address):\n            os.mkdir(address)\n\n        if compress:\n            file_type = \"csv.gz\"\n        else:\n            file_type = \"csv\"\n\n        # Use the extracted config save method\n        self._save_model_config(\n            address, config_name, file_type=file_type, compress=compress\n        )\n\n    def _save_model_config(\n        self,\n        address,\n        config_name=\"config.yml\",\n        unified_data_file=None,\n        file_type=\"csv\",\n        compress=False,\n    ):\n        \"\"\"Save model configuration to a YAML file.\n\n        Args:\n            address (str): Path to save directory\n            config_name (str): Name of the config file\n            unified_data_file (str, optional): Name of unified data file if using\n                unified data\n            file_type (str): File type for individual data files (\"csv\" or \"csv.gz\")\n            compress (bool): Whether to compress individual files\n        \"\"\"\n        nodes = {}\n        for node in self.nodes.values():\n            init_args = self.get_init_args(node.__class__)\n            special_args = set([\"surfaces\", \"parent\", \"data_input_dict\"])\n\n            node_props = {\n                x: getattr(node, x)\n                for x in set(init_args).difference(special_args)\n                if hasattr(node, x)\n            }\n            node_props[\"type_\"] = node.__class__.__name__\n            node_props[\"node_type_override\"] = (\n                repr(node.__class__).split(\".\")[-1].replace(\"'&gt;\", \"\")\n            )\n\n            if \"surfaces\" in init_args:\n                surfaces = {}\n                for surface in node.surfaces:\n                    surface_args = self.get_init_args(surface.__class__)\n                    surface_props = {\n                        x: getattr(surface, x)\n                        for x in set(surface_args).difference(special_args)\n                        if hasattr(surface, x)\n                    }\n                    surface_props[\"type_\"] = surface.__class__.__name__\n\n                    # Exceptions...\n                    # TODO I need a better way to do this\n                    del surface_props[\"capacity\"]\n                    if set([\"rooting_depth\", \"pore_depth\"]).intersection(surface_args):\n                        del surface_props[\"depth\"]\n\n                    # Handle data input dict based on save mode\n                    if \"data_input_dict\" in surface_args:\n                        if unified_data_file and surface.data_input_dict:\n                            # Mark that data should be loaded from unified file\n                            surface_props[\"data_input_dict\"] = True\n                        elif surface.data_input_dict:\n                            # Save individual file\n                            filename = (\n                                \"{0}-{1}-inputs.{2}\".format(\n                                    node.name, surface.surface, file_type\n                                )\n                                .replace(\"(\", \"_\")\n                                .replace(\")\", \"_\")\n                                .replace(\"/\", \"_\")\n                                .replace(\" \", \"_\")\n                            )\n                            write_csv(\n                                surface.data_input_dict,\n                                {\"node\": node.name, \"surface\": surface.surface},\n                                os.path.join(address, filename),\n                                compress=compress,\n                            )\n                            surface_props[\"filename\"] = filename\n\n                    surfaces[surface_props[\"surface\"]] = surface_props\n                node_props[\"surfaces\"] = surfaces\n\n            # Handle node-level data input dict based on save mode\n            if \"data_input_dict\" in init_args:\n                if unified_data_file and node.data_input_dict:\n                    # Mark that data should be loaded from unified file\n                    node_props[\"data_input_dict\"] = True\n                elif node.data_input_dict:\n                    # Save individual file\n                    filename = \"{0}-inputs.{1}\".format(node.name, file_type)\n                    write_csv(\n                        node.data_input_dict,\n                        {\"node\": node.name},\n                        os.path.join(address, filename),\n                        compress=compress,\n                    )\n                    node_props[\"filename\"] = filename\n\n            nodes[node.name] = node_props\n\n        arcs = {}\n        for arc in self.arcs.values():\n            init_args = self.get_init_args(arc.__class__)\n            special_args = set([\"in_port\", \"out_port\"])\n            arc_props = {\n                x: getattr(arc, x) for x in set(init_args).difference(special_args)\n            }\n            arc_props[\"type_\"] = arc.__class__.__name__\n            arc_props[\"in_port\"] = arc.in_port.name\n            arc_props[\"out_port\"] = arc.out_port.name\n            arcs[arc.name] = arc_props\n\n        data = {\n            \"nodes\": nodes,\n            \"arcs\": arcs,\n            \"orchestration\": self.orchestration,\n            \"pollutants\": constants.POLLUTANTS,\n            \"additive_pollutants\": constants.ADDITIVE_POLLUTANTS,\n            \"non_additive_pollutants\": constants.NON_ADDITIVE_POLLUTANTS,\n            \"float_accuracy\": constants.FLOAT_ACCURACY,\n            \"extensions\": self.extensions,\n            \"river_discharge_order\": self.river_discharge_order,\n        }\n\n        if unified_data_file:\n            data[\"unified_data_file\"] = unified_data_file\n\n        if hasattr(self, \"dates\"):\n            data[\"dates\"] = [str(x) for x in self.dates]\n\n        def coerce_value(value):\n            \"\"\"\n\n            Args:\n                value:\n\n            Returns:\n\n            \"\"\"\n            conversion_options = {\n                \"__float__\": float,\n                \"__iter__\": list,\n                \"__int__\": int,\n                \"__str__\": str,\n                \"__bool__\": bool,\n            }\n            converted = False\n            for property, func in conversion_options.items():\n                if hasattr(value, property):\n                    try:\n                        yaml.safe_dump(func(value))\n                        value = func(value)\n                        converted = True\n                        break\n                    except Exception:\n                        raise ValueError(f\"Cannot dump: {value} of type {type(value)}\")\n            if not converted:\n                raise ValueError(f\"Cannot dump: {value} of type {type(value)}\")\n\n            return value\n\n        def check_and_coerce_dict(data_dict):\n            \"\"\"\n\n            Args:\n                data_dict:\n            \"\"\"\n            for key, value in data_dict.items():\n                if isinstance(value, dict):\n                    check_and_coerce_dict(value)\n                else:\n                    try:\n                        yaml.safe_dump(value)\n                    except yaml.representer.RepresenterError:\n                        if hasattr(value, \"__iter__\"):\n                            for idx, val in enumerate(value):\n                                if isinstance(val, dict):\n                                    check_and_coerce_dict(val)\n                                else:\n                                    value[idx] = coerce_value(val)\n                        data_dict[key] = coerce_value(value)\n\n        check_and_coerce_dict(data)\n\n        write_yaml(address, config_name, data)\n\n    def save_unified_data(\n        self,\n        address,\n        parquet_filename=\"unified_data.parquet\",\n        config_name=\"config.yml\",\n        compress=False,\n    ):\n        \"\"\"Save model data to a unified parquet file.\n\n        Args:\n            address (str): Path to save directory\n            parquet_filename (str): Name of the parquet file\n            config_name (str): Name of the config file\n            compress (bool): Whether to compress (not used for parquet)\n        \"\"\"\n        if not PARQUET_AVAILABLE:\n            raise ImportError(\n                \"parquet support (pyarrow or fastparquet) is required \"\n                \"for unified data saving\"\n            )\n\n        if not os.path.exists(address):\n            os.mkdir(address)\n\n        # Collect all data from nodes and surfaces\n        nodes_data = {}\n        surfaces_data = {}\n\n        for node in self.nodes.values():\n            if hasattr(node, \"data_input_dict\") and node.data_input_dict:\n                nodes_data[node.name] = node.data_input_dict\n\n            if hasattr(node, \"surfaces\"):\n                for surface in node.surfaces:\n                    if hasattr(surface, \"data_input_dict\") and surface.data_input_dict:\n                        surfaces_data[(node.name, surface.surface)] = (\n                            surface.data_input_dict\n                        )\n\n        # Create unified DataFrame\n        unified_df = create_unified_dataframe(nodes_data, surfaces_data)\n\n        # Save unified parquet file\n        parquet_path = os.path.join(address, parquet_filename)\n        unified_df.to_parquet(parquet_path, index=False)\n\n        # Save config file using the extracted method\n        self._save_model_config(\n            address, config_name, unified_data_file=parquet_filename\n        )\n\n    def load_pickle(self, fid):\n        \"\"\"Load model object to a pickle file, including the model states.\n\n        Args:\n            fid (str): File address to load the pickled model from\n\n        Returns:\n            model (obj): loaded model\n\n        Example:\n            &gt;&gt;&gt; # Load and run your model\n            &gt;&gt;&gt; my_model.load(model_dir,config_name = 'config.yml')\n            &gt;&gt;&gt; _ = my_model.run()\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Save it including its different states\n            &gt;&gt;&gt; my_model.save_pickle('model_at_end_of_run.pkl')\n            &gt;&gt;&gt;\n            &gt;&gt;&gt; # Load it at another time to resume the model from the end\n            &gt;&gt;&gt; # of the previous run\n            &gt;&gt;&gt; new_model = Model()\n            &gt;&gt;&gt; new_model = new_model.load_pickle('model_at_end_of_run.pkl')\n        \"\"\"\n        file = open(fid, \"rb\")\n        return pickle.load(file)\n\n    def save_pickle(self, fid):\n        \"\"\"Save model object to a pickle file, including saving the model states.\n\n        Args:\n            fid (str): File address to save the pickled model to\n\n        Returns:\n            message (str): Exit message of pickle dump\n        \"\"\"\n        file = open(fid, \"wb\")\n        pickle.dump(self, file)\n        return file.close()\n\n    def add_nodes(self, nodelist):\n        \"\"\"Add nodes to the model object from a list of dicts, where each dict contains\n        all of the parameters for a node. Intended to be called before add_arcs.\n\n        Args:\n            nodelist (list): List of dicts, where a dict is a node\n        \"\"\"\n\n        for data in nodelist:\n            name = data[\"name\"]\n            type_ = data[\"type_\"]\n            if \"node_type_override\" in data.keys():\n                node_type = data[\"node_type_override\"]\n                del data[\"node_type_override\"]\n            else:\n                node_type = type_\n            if \"foul\" in name:\n                # Absolute hack to enable foul sewers to be treated separate from storm\n                type_ = \"Foul\"\n            if \"geometry\" in data.keys():\n                del data[\"geometry\"]\n            del data[\"type_\"]\n\n            if node_type not in NODES_REGISTRY.keys():\n                raise ValueError(f\"Node type {node_type} not recognised\")\n\n            if type_ not in self.nodes_type.keys():\n                self.nodes_type[type_] = {}\n\n            self.nodes_type[type_][name] = NODES_REGISTRY[node_type](**dict(data))\n            self.nodes[name] = self.nodes_type[type_][name]\n            self.nodelist = [x for x in self.nodes.values()]\n\n    def add_instantiated_nodes(self, nodelist):\n        \"\"\"Add nodes to the model object from a list of objects, where each object is an\n        already instantiated node object. Intended to be called before add_arcs.\n\n        Args:\n            nodelist (list): list of objects that are nodes\n        \"\"\"\n        self.nodelist = nodelist\n        self.nodes = {x.name: x for x in nodelist}\n        for x in nodelist:\n            type_ = x.__class__.__name__\n            if type_ not in self.nodes_type.keys():\n                self.nodes_type[type_] = {}\n            self.nodes_type[type_][x.name] = x\n\n    def add_arcs(self, arclist):\n        \"\"\"Add nodes to the model object from a list of dicts, where each dict contains\n        all of the parameters for an arc.\n\n        Args:\n            arclist (list): list of dicts, where a dict is an arc\n        \"\"\"\n        river_arcs = {}\n        for arc in arclist:\n            name = arc[\"name\"]\n            type_ = arc[\"type_\"]\n            del arc[\"type_\"]\n            arc[\"in_port\"] = self.nodes[arc[\"in_port\"]]\n            arc[\"out_port\"] = self.nodes[arc[\"out_port\"]]\n            self.arcs[name] = getattr(arcs_mod, type_)(**dict(arc))\n\n            if arc[\"in_port\"].__class__.__name__ in [\n                \"River\",\n                \"Node\",\n                \"Waste\",\n                \"Reservoir\",\n            ]:\n                if arc[\"out_port\"].__class__.__name__ in [\n                    \"River\",\n                    \"Node\",\n                    \"Waste\",\n                    \"Reservoir\",\n                ]:\n                    river_arcs[name] = self.arcs[name]\n\n        self.river_discharge_order = []\n        if not any(river_arcs):\n            return\n        upstreamness = (\n            {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n            if \"Waste\" in self.nodes_type\n            else {}\n        )\n        upstreamness = self.assign_upstream(river_arcs, upstreamness)\n\n        if \"River\" in self.nodes_type:\n            for node in sorted(\n                upstreamness.items(), key=lambda item: item[1], reverse=True\n            ):\n                if node[0] in self.nodes_type[\"River\"]:\n                    self.river_discharge_order.append(node[0])\n\n    def add_instantiated_arcs(self, arclist):\n        \"\"\"Add arcs to the model object from a list of objects, where each object is an\n        already instantiated arc object.\n\n        Args:\n            arclist (list): list of objects that are arcs.\n        \"\"\"\n        self.arclist = arclist\n        self.arcs = {x.name: x for x in arclist}\n        river_arcs = {}\n        for arc in arclist:\n            if arc.in_port.__class__.__name__ in [\n                \"River\",\n                \"Node\",\n                \"Waste\",\n                \"Reservoir\",\n            ]:\n                if arc.out_port.__class__.__name__ in [\n                    \"River\",\n                    \"Node\",\n                    \"Waste\",\n                    \"Reservoir\",\n                ]:\n                    river_arcs[arc.name] = arc\n        if not any(river_arcs):\n            return\n        upstreamness = (\n            {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n            if \"Waste\" in self.nodes_type\n            else {}\n        )\n        upstreamness = {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n\n        upstreamness = self.assign_upstream(river_arcs, upstreamness)\n\n        self.river_discharge_order = []\n        if \"River\" in self.nodes_type:\n            for node in sorted(\n                upstreamness.items(), key=lambda item: item[1], reverse=True\n            ):\n                if node[0] in self.nodes_type[\"River\"]:\n                    self.river_discharge_order.append(node[0])\n\n    def assign_upstream(self, arcs, upstreamness):\n        \"\"\"Recursive function to trace upstream up arcs to determine which are the most\n        upstream.\n\n        Args:\n            arcs (list): list of dicts where dicts are arcs\n            upstreamness (dict): dictionary contain nodes in\n                arcs as keys and a number representing upstreamness\n                (higher numbers = more upstream)\n\n        Returns:\n            upstreamness (dict): final version of upstreamness\n        \"\"\"\n        upstreamness_ = upstreamness.copy()\n        in_nodes = [\n            x.in_port.name\n            for x in arcs.values()\n            if x.out_port.name in upstreamness.keys()\n        ]\n        ind = max(list(upstreamness_.values())) + 1\n        in_nodes = list(set(in_nodes).difference(upstreamness.keys()))\n        for node in in_nodes:\n            upstreamness[node] = ind\n        if upstreamness == upstreamness_:\n            return upstreamness\n        else:\n            upstreamness = self.assign_upstream(arcs, upstreamness)\n            return upstreamness\n\n    def add_overrides(self, config: dict):\n        \"\"\"Apply overrides to nodes and arcs in the model object.\n\n        Args:\n            config (dict): dictionary of overrides to apply to the model object.\n        \"\"\"\n        for node in config.get(\"nodes\", {}).values():\n            type_ = node.pop(\"type_\")\n            name = node.pop(\"name\")\n\n            if type_ not in self.nodes_type.keys():\n                raise ValueError(f\"Node type {type_} not recognised\")\n\n            if name not in self.nodes_type[type_].keys():\n                raise ValueError(f\"Node {name} not recognised\")\n\n            self.nodes_type[type_][name].apply_overrides(node)\n\n        for arc in config.get(\"arcs\", {}).values():\n            name = arc.pop(\"name\")\n            type_ = arc.pop(\"type_\")\n\n            if name not in self.arcs.keys():\n                raise ValueError(f\"Arc {name} not recognised\")\n\n            self.arcs[name].apply_overrides(arc)\n\n    def debug_node_mb(self):\n        \"\"\"Simple function that iterates over nodes calling their mass balance\n        function.\"\"\"\n        for node in self.nodelist:\n            _ = node.node_mass_balance()\n\n    def default_settings(self):\n        \"\"\"Incomplete function that enables easy specification of results storage.\n\n        Returns:\n            (dict): default settings\n        \"\"\"\n        return {\n            \"arcs\": {\"flows\": True, \"pollutants\": True},\n            \"tanks\": {\"storages\": True, \"pollutants\": True},\n            \"mass_balance\": False,\n        }\n\n    def change_runoff_coefficient(self, relative_change, nodes=None):\n        \"\"\"Clunky way to change the runoff coefficient of a land node.\n\n        Args:\n            relative_change (float): amount that the impervious area in the land\n                node is multiplied by (grass area is changed in compensation)\n            nodes (list, optional): list of land nodes to change the parameters of.\n                Defaults to None, which applies the change to all land nodes.\n        \"\"\"\n        # Multiplies impervious area by relative change and adjusts grassland\n        # accordingly\n        if nodes is None:\n            nodes = self.nodes_type[\"Land\"].values()\n\n        if isinstance(relative_change, float):\n            relative_change = {x: relative_change for x in nodes}\n\n        for node in nodes:\n            surface_dict = {x.surface: x for x in node.surfaces}\n            if \"Impervious\" in surface_dict.keys():\n                impervious_area = surface_dict[\"Impervious\"].area\n                grass_area = surface_dict[\"Grass\"].area\n\n                new_impervious_area = impervious_area * relative_change[node]\n                new_grass_area = grass_area + (impervious_area - new_impervious_area)\n                if new_grass_area &lt; 0:\n                    print(\"not enough grass\")\n                    break\n                surface_dict[\"Impervious\"].area = new_impervious_area\n                surface_dict[\"Impervious\"].capacity *= relative_change[node]\n\n                surface_dict[\"Grass\"].area = new_grass_area\n                surface_dict[\"Grass\"].capacity *= new_grass_area / grass_area\n                for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                    surface_dict[\"Grass\"].storage[pol] *= new_grass_area / grass_area\n                for pool in surface_dict[\"Grass\"].nutrient_pool.pools:\n                    for nutrient in pool.storage.keys():\n                        pool.storage[nutrient] *= new_grass_area / grass_area\n\n    def run(\n        self,\n        dates=None,\n        settings=None,\n        record_arcs=None,\n        record_tanks=None,\n        record_surfaces=None,\n        verbose=True,\n        record_all=True,\n        objectives=[],\n    ):\n        \"\"\"Run the model object with the default orchestration.\n\n        Args:\n            dates (list, optional): Dates to simulate. Defaults to None, which\n                simulates all dates that the model has data for.\n            settings (dict, optional): Dict to specify what results are stored,\n                not currently used. Defaults to None.\n            record_arcs (list, optional): List of arcs to store result for.\n                Defaults to None.\n            record_tanks (list, optional): List of nodes with water stores to\n                store results for. Defaults to None.\n            record_surfaces (list, optional): List of tuples of\n                (land node, surface) to store results for. Defaults to None.\n            verbose (bool, optional): Prints updates on simulation if true.\n                Defaults to True.\n            record_all (bool, optional): Specifies to store all results.\n                Defaults to True.\n            objectives (list, optional): A list of dicts with objectives to\n                calculate (see examples). Defaults to [].\n\n        Returns:\n            flows: simulated flows in a list of dicts\n            tanks: simulated tanks storages in a list of dicts\n            objective_results: list of values based on objectives list\n            surfaces: simulated surface storages of land nodes in a list of dicts\n\n        Examples:\n            # Run a model without storing any results but calculating objectives\n            import statistics as stats\n            objectives = [{'element_type' : 'flows',\n                           'name' : 'my_river',\n                           'function' : @ (x, _) stats.mean([y['phosphate'] for y in x])\n                           },\n                          {'element_type' : 'tanks',\n                           'name' : 'my_reservoir',\n                           'function' : @ (x, model) sum([y['storage'] &lt; (model.nodes\n                           ['my_reservoir'].tank.capacity / 2) for y in x])\n                           }]\n            _, _, results, _ = my_model.run(record_all = False, objectives = objectives)\n        \"\"\"\n        if record_arcs is None:\n            record_arcs = []\n            if record_all:\n                record_arcs = list(self.arcs.keys())\n        if record_tanks is None:\n            record_tanks = []\n\n        if record_surfaces is None:\n            record_surfaces = []\n\n        if settings is None:\n            settings = self.default_settings()\n\n        def blockPrint():\n            \"\"\"\n\n            Returns:\n\n            \"\"\"\n            stdout = sys.stdout\n            sys.stdout = open(os.devnull, \"w\")\n            return stdout\n\n        def enablePrint(stdout):\n            \"\"\"\n\n            Args:\n                stdout:\n            \"\"\"\n            sys.stdout = stdout\n\n        if not verbose:\n            stdout = blockPrint()\n        if dates is None:\n            dates = self.dates\n\n        for objective in objectives:\n            if objective[\"element_type\"] == \"tanks\":\n                record_tanks.append(objective[\"name\"])\n            elif objective[\"element_type\"] == \"flows\":\n                record_arcs.append(objective[\"name\"])\n            elif objective[\"element_type\"] == \"surfaces\":\n                record_surfaces.append((objective[\"name\"], objective[\"surface\"]))\n            else:\n                print(\"element_type not recorded\")\n\n        flows = []\n        tanks = []\n        surfaces = []\n        for date in tqdm(dates, disable=(not verbose)):\n            # for date in dates:\n            for node in self.nodelist:\n                node.t = date\n                node.monthyear = date.to_period(\"M\")\n\n            # Iterate over orchestration\n            for timestep_item in self.orchestration:\n                for node_type, function in timestep_item.items():\n                    for node in self.nodes_type.get(node_type, {}).values():\n                        getattr(node, function)()\n\n            # river\n            for node_name in self.river_discharge_order:\n                self.nodes[node_name].distribute()\n\n            # mass balance checking\n            # nodes/system\n            sys_in = self.empty_vqip()\n            sys_out = self.empty_vqip()\n            sys_ds = self.empty_vqip()\n\n            # arcs\n            for arc in self.arcs.values():\n                in_, ds_, out_ = arc.arc_mass_balance()\n                for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                    sys_in[v] += in_[v]\n                    sys_out[v] += out_[v]\n                    sys_ds[v] += ds_[v]\n            for node in self.nodelist:\n                # print(node.name)\n                in_, ds_, out_ = node.node_mass_balance()\n\n                # temp = {'name' : node.name,\n                #         'time' : date}\n                # for lab, dict_ in zip(['in','ds','out'], [in_, ds_, out_]):\n                #     for key, value in dict_.items():\n                #         temp[(lab, key)] = value\n                # node_mb.append(temp)\n\n                for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                    sys_in[v] += in_[v]\n                    sys_out[v] += out_[v]\n                    sys_ds[v] += ds_[v]\n\n            for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                # Find the largest value of in_, out_, ds_\n                largest = max(sys_in[v], sys_in[v], sys_in[v])\n\n                if largest &gt; constants.FLOAT_ACCURACY:\n                    # Convert perform comparison in a magnitude to match the largest\n                    # value\n                    magnitude = 10 ** int(log10(largest))\n                    in_10 = sys_in[v] / magnitude\n                    out_10 = sys_in[v] / magnitude\n                    ds_10 = sys_in[v] / magnitude\n                else:\n                    in_10 = sys_in[v]\n                    ds_10 = sys_in[v]\n                    out_10 = sys_in[v]\n\n                if (in_10 - ds_10 - out_10) &gt; constants.FLOAT_ACCURACY:\n                    print(\n                        \"system mass balance error for \"\n                        + v\n                        + \" of \"\n                        + str(sys_in[v] - sys_ds[v] - sys_out[v])\n                    )\n\n            # Store results\n            for arc in record_arcs:\n                arc = self.arcs[arc]\n                flows.append(\n                    {\"arc\": arc.name, \"flow\": arc.vqip_out[\"volume\"], \"time\": date}\n                )\n                for pol in constants.POLLUTANTS:\n                    flows[-1][pol] = arc.vqip_out[pol]\n\n            for node in record_tanks:\n                node = self.nodes[node]\n                tanks.append(\n                    {\n                        \"node\": node.name,\n                        \"storage\": node.tank.storage[\"volume\"],\n                        \"time\": date,\n                    }\n                )\n\n            for node, surface in record_surfaces:\n                node = self.nodes[node]\n                name = node.name\n                surface = node.get_surface(surface)\n                if not isinstance(surface, ImperviousSurface):\n                    surfaces.append(\n                        {\n                            \"node\": name,\n                            \"surface\": surface.surface,\n                            \"percolation\": surface.percolation[\"volume\"],\n                            \"subsurface_r\": surface.subsurface_flow[\"volume\"],\n                            \"surface_r\": surface.infiltration_excess[\"volume\"],\n                            \"storage\": surface.storage[\"volume\"],\n                            \"evaporation\": surface.evaporation[\"volume\"],\n                            \"precipitation\": surface.precipitation[\"volume\"],\n                            \"tank_recharge\": surface.tank_recharge,\n                            \"capacity\": surface.capacity,\n                            \"time\": date,\n                            \"et0_coef\": surface.et0_coefficient,\n                            # 'crop_factor' : surface.crop_factor\n                        }\n                    )\n                    for pol in constants.POLLUTANTS:\n                        surfaces[-1][pol] = surface.storage[pol]\n                else:\n                    surfaces.append(\n                        {\n                            \"node\": name,\n                            \"surface\": surface.surface,\n                            \"storage\": surface.storage[\"volume\"],\n                            \"evaporation\": surface.evaporation[\"volume\"],\n                            \"precipitation\": surface.precipitation[\"volume\"],\n                            \"capacity\": surface.capacity,\n                            \"time\": date,\n                        }\n                    )\n                    for pol in constants.POLLUTANTS:\n                        surfaces[-1][pol] = surface.storage[pol]\n            if record_all:\n                for node in self.nodes.values():\n                    for prop_ in dir(node):\n                        prop = node.__getattribute__(prop_)\n                        if prop.__class__ in [QueueTank, Tank, ResidenceTank]:\n                            tanks.append(\n                                {\n                                    \"node\": node.name,\n                                    \"time\": date,\n                                    \"storage\": prop.storage[\"volume\"],\n                                    \"prop\": prop_,\n                                }\n                            )\n                            for pol in constants.POLLUTANTS:\n                                tanks[-1][pol] = prop.storage[pol]\n\n                for name, node in self.nodes_type.get(\"Land\", {}).items():\n                    for surface in node.surfaces:\n                        if not isinstance(surface, ImperviousSurface):\n                            surfaces.append(\n                                {\n                                    \"node\": name,\n                                    \"surface\": surface.surface,\n                                    \"percolation\": surface.percolation[\"volume\"],\n                                    \"subsurface_r\": surface.subsurface_flow[\"volume\"],\n                                    \"surface_r\": surface.infiltration_excess[\"volume\"],\n                                    \"storage\": surface.storage[\"volume\"],\n                                    \"evaporation\": surface.evaporation[\"volume\"],\n                                    \"precipitation\": surface.precipitation[\"volume\"],\n                                    \"tank_recharge\": surface.tank_recharge,\n                                    \"capacity\": surface.capacity,\n                                    \"time\": date,\n                                    \"et0_coef\": surface.et0_coefficient,\n                                    # 'crop_factor' : surface.crop_factor\n                                }\n                            )\n                            for pol in constants.POLLUTANTS:\n                                surfaces[-1][pol] = surface.storage[pol]\n                        else:\n                            surfaces.append(\n                                {\n                                    \"node\": name,\n                                    \"surface\": surface.surface,\n                                    \"storage\": surface.storage[\"volume\"],\n                                    \"evaporation\": surface.evaporation[\"volume\"],\n                                    \"precipitation\": surface.precipitation[\"volume\"],\n                                    \"capacity\": surface.capacity,\n                                    \"time\": date,\n                                }\n                            )\n                            for pol in constants.POLLUTANTS:\n                                surfaces[-1][pol] = surface.storage[pol]\n\n            for node in self.nodes.values():\n                node.end_timestep()\n\n            for arc in self.arcs.values():\n                arc.end_timestep()\n        objective_results = []\n        for objective in objectives:\n            if objective[\"element_type\"] == \"tanks\":\n                val = objective[\"function\"](\n                    [x for x in tanks if x[\"node\"] == objective[\"name\"]], self\n                )\n            elif objective[\"element_type\"] == \"flows\":\n                val = objective[\"function\"](\n                    [x for x in flows if x[\"arc\"] == objective[\"name\"]], self\n                )\n            elif objective[\"element_type\"] == \"surfaces\":\n                val = objective[\"function\"](\n                    [\n                        x\n                        for x in surfaces\n                        if (x[\"node\"] == objective[\"name\"])\n                        &amp; (x[\"surface\"] == objective[\"surface\"])\n                    ],\n                    self,\n                )\n            objective_results.append(val)\n        if not verbose:\n            enablePrint(stdout)\n        return flows, tanks, objective_results, surfaces\n\n    def reinit(self):\n        \"\"\"Reinitialise by ending all node/arc timesteps and calling reinit function in\n        all nodes (generally zero-ing their storage values).\"\"\"\n        for node in self.nodes.values():\n            node.end_timestep()\n            for prop in dir(node):\n                prop = node.__getattribute__(prop)\n                for prop_ in dir(prop):\n                    if prop_ == \"reinit\":\n                        prop_ = node.__getattribute__(prop_)\n                        prop_()\n\n        for arc in self.arcs.values():\n            arc.end_timestep()\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.__init__","title":"<code>__init__()</code>","text":"<p>Object to contain nodes and arcs that provides a default orchestration.</p> <p>Returns:</p> Name Type Description <code>Model</code> <p>An empty model object</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def __init__(self):\n    \"\"\"Object to contain nodes and arcs that provides a default orchestration.\n\n    Returns:\n        Model: An empty model object\n    \"\"\"\n    super().__init__()\n    self.arcs = {}\n    # self.arcs_type = {} #not sure that this would be necessary\n    self.nodes = {}\n    self.nodes_type = {}\n    self.extensions = []\n    self.river_discharge_order = []\n\n    # Default orchestration\n    self.orchestration = [\n        {\"FWTW\": \"treat_water\"},\n        {\"Demand\": \"create_demand\"},\n        {\"Land\": \"run\"},\n        {\"Groundwater\": \"infiltrate\"},\n        {\"Sewer\": \"make_discharge\"},\n        {\"Foul\": \"make_discharge\"},\n        {\"WWTW\": \"calculate_discharge\"},\n        {\"Groundwater\": \"distribute\"},\n        {\"River\": \"calculate_discharge\"},\n        {\"Reservoir\": \"make_abstractions\"},\n        {\"Land\": \"apply_irrigation\"},\n        {\"WWTW\": \"make_discharge\"},\n        {\"Catchment\": \"route\"},\n    ]\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.add_arcs","title":"<code>add_arcs(arclist)</code>","text":"<p>Add nodes to the model object from a list of dicts, where each dict contains all of the parameters for an arc.</p> <p>Parameters:</p> Name Type Description Default <code>arclist</code> <code>list</code> <p>list of dicts, where a dict is an arc</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def add_arcs(self, arclist):\n    \"\"\"Add nodes to the model object from a list of dicts, where each dict contains\n    all of the parameters for an arc.\n\n    Args:\n        arclist (list): list of dicts, where a dict is an arc\n    \"\"\"\n    river_arcs = {}\n    for arc in arclist:\n        name = arc[\"name\"]\n        type_ = arc[\"type_\"]\n        del arc[\"type_\"]\n        arc[\"in_port\"] = self.nodes[arc[\"in_port\"]]\n        arc[\"out_port\"] = self.nodes[arc[\"out_port\"]]\n        self.arcs[name] = getattr(arcs_mod, type_)(**dict(arc))\n\n        if arc[\"in_port\"].__class__.__name__ in [\n            \"River\",\n            \"Node\",\n            \"Waste\",\n            \"Reservoir\",\n        ]:\n            if arc[\"out_port\"].__class__.__name__ in [\n                \"River\",\n                \"Node\",\n                \"Waste\",\n                \"Reservoir\",\n            ]:\n                river_arcs[name] = self.arcs[name]\n\n    self.river_discharge_order = []\n    if not any(river_arcs):\n        return\n    upstreamness = (\n        {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n        if \"Waste\" in self.nodes_type\n        else {}\n    )\n    upstreamness = self.assign_upstream(river_arcs, upstreamness)\n\n    if \"River\" in self.nodes_type:\n        for node in sorted(\n            upstreamness.items(), key=lambda item: item[1], reverse=True\n        ):\n            if node[0] in self.nodes_type[\"River\"]:\n                self.river_discharge_order.append(node[0])\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.add_instantiated_arcs","title":"<code>add_instantiated_arcs(arclist)</code>","text":"<p>Add arcs to the model object from a list of objects, where each object is an already instantiated arc object.</p> <p>Parameters:</p> Name Type Description Default <code>arclist</code> <code>list</code> <p>list of objects that are arcs.</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def add_instantiated_arcs(self, arclist):\n    \"\"\"Add arcs to the model object from a list of objects, where each object is an\n    already instantiated arc object.\n\n    Args:\n        arclist (list): list of objects that are arcs.\n    \"\"\"\n    self.arclist = arclist\n    self.arcs = {x.name: x for x in arclist}\n    river_arcs = {}\n    for arc in arclist:\n        if arc.in_port.__class__.__name__ in [\n            \"River\",\n            \"Node\",\n            \"Waste\",\n            \"Reservoir\",\n        ]:\n            if arc.out_port.__class__.__name__ in [\n                \"River\",\n                \"Node\",\n                \"Waste\",\n                \"Reservoir\",\n            ]:\n                river_arcs[arc.name] = arc\n    if not any(river_arcs):\n        return\n    upstreamness = (\n        {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n        if \"Waste\" in self.nodes_type\n        else {}\n    )\n    upstreamness = {x: 0 for x in self.nodes_type[\"Waste\"].keys()}\n\n    upstreamness = self.assign_upstream(river_arcs, upstreamness)\n\n    self.river_discharge_order = []\n    if \"River\" in self.nodes_type:\n        for node in sorted(\n            upstreamness.items(), key=lambda item: item[1], reverse=True\n        ):\n            if node[0] in self.nodes_type[\"River\"]:\n                self.river_discharge_order.append(node[0])\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.add_instantiated_nodes","title":"<code>add_instantiated_nodes(nodelist)</code>","text":"<p>Add nodes to the model object from a list of objects, where each object is an already instantiated node object. Intended to be called before add_arcs.</p> <p>Parameters:</p> Name Type Description Default <code>nodelist</code> <code>list</code> <p>list of objects that are nodes</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def add_instantiated_nodes(self, nodelist):\n    \"\"\"Add nodes to the model object from a list of objects, where each object is an\n    already instantiated node object. Intended to be called before add_arcs.\n\n    Args:\n        nodelist (list): list of objects that are nodes\n    \"\"\"\n    self.nodelist = nodelist\n    self.nodes = {x.name: x for x in nodelist}\n    for x in nodelist:\n        type_ = x.__class__.__name__\n        if type_ not in self.nodes_type.keys():\n            self.nodes_type[type_] = {}\n        self.nodes_type[type_][x.name] = x\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.add_nodes","title":"<code>add_nodes(nodelist)</code>","text":"<p>Add nodes to the model object from a list of dicts, where each dict contains all of the parameters for a node. Intended to be called before add_arcs.</p> <p>Parameters:</p> Name Type Description Default <code>nodelist</code> <code>list</code> <p>List of dicts, where a dict is a node</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def add_nodes(self, nodelist):\n    \"\"\"Add nodes to the model object from a list of dicts, where each dict contains\n    all of the parameters for a node. Intended to be called before add_arcs.\n\n    Args:\n        nodelist (list): List of dicts, where a dict is a node\n    \"\"\"\n\n    for data in nodelist:\n        name = data[\"name\"]\n        type_ = data[\"type_\"]\n        if \"node_type_override\" in data.keys():\n            node_type = data[\"node_type_override\"]\n            del data[\"node_type_override\"]\n        else:\n            node_type = type_\n        if \"foul\" in name:\n            # Absolute hack to enable foul sewers to be treated separate from storm\n            type_ = \"Foul\"\n        if \"geometry\" in data.keys():\n            del data[\"geometry\"]\n        del data[\"type_\"]\n\n        if node_type not in NODES_REGISTRY.keys():\n            raise ValueError(f\"Node type {node_type} not recognised\")\n\n        if type_ not in self.nodes_type.keys():\n            self.nodes_type[type_] = {}\n\n        self.nodes_type[type_][name] = NODES_REGISTRY[node_type](**dict(data))\n        self.nodes[name] = self.nodes_type[type_][name]\n        self.nodelist = [x for x in self.nodes.values()]\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.add_overrides","title":"<code>add_overrides(config)</code>","text":"<p>Apply overrides to nodes and arcs in the model object.</p> <p>Parameters:</p> Name Type Description Default <code>config</code> <code>dict</code> <p>dictionary of overrides to apply to the model object.</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def add_overrides(self, config: dict):\n    \"\"\"Apply overrides to nodes and arcs in the model object.\n\n    Args:\n        config (dict): dictionary of overrides to apply to the model object.\n    \"\"\"\n    for node in config.get(\"nodes\", {}).values():\n        type_ = node.pop(\"type_\")\n        name = node.pop(\"name\")\n\n        if type_ not in self.nodes_type.keys():\n            raise ValueError(f\"Node type {type_} not recognised\")\n\n        if name not in self.nodes_type[type_].keys():\n            raise ValueError(f\"Node {name} not recognised\")\n\n        self.nodes_type[type_][name].apply_overrides(node)\n\n    for arc in config.get(\"arcs\", {}).values():\n        name = arc.pop(\"name\")\n        type_ = arc.pop(\"type_\")\n\n        if name not in self.arcs.keys():\n            raise ValueError(f\"Arc {name} not recognised\")\n\n        self.arcs[name].apply_overrides(arc)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.assign_upstream","title":"<code>assign_upstream(arcs, upstreamness)</code>","text":"<p>Recursive function to trace upstream up arcs to determine which are the most upstream.</p> <p>Parameters:</p> Name Type Description Default <code>arcs</code> <code>list</code> <p>list of dicts where dicts are arcs</p> required <code>upstreamness</code> <code>dict</code> <p>dictionary contain nodes in arcs as keys and a number representing upstreamness (higher numbers = more upstream)</p> required <p>Returns:</p> Name Type Description <code>upstreamness</code> <code>dict</code> <p>final version of upstreamness</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def assign_upstream(self, arcs, upstreamness):\n    \"\"\"Recursive function to trace upstream up arcs to determine which are the most\n    upstream.\n\n    Args:\n        arcs (list): list of dicts where dicts are arcs\n        upstreamness (dict): dictionary contain nodes in\n            arcs as keys and a number representing upstreamness\n            (higher numbers = more upstream)\n\n    Returns:\n        upstreamness (dict): final version of upstreamness\n    \"\"\"\n    upstreamness_ = upstreamness.copy()\n    in_nodes = [\n        x.in_port.name\n        for x in arcs.values()\n        if x.out_port.name in upstreamness.keys()\n    ]\n    ind = max(list(upstreamness_.values())) + 1\n    in_nodes = list(set(in_nodes).difference(upstreamness.keys()))\n    for node in in_nodes:\n        upstreamness[node] = ind\n    if upstreamness == upstreamness_:\n        return upstreamness\n    else:\n        upstreamness = self.assign_upstream(arcs, upstreamness)\n        return upstreamness\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.change_runoff_coefficient","title":"<code>change_runoff_coefficient(relative_change, nodes=None)</code>","text":"<p>Clunky way to change the runoff coefficient of a land node.</p> <p>Parameters:</p> Name Type Description Default <code>relative_change</code> <code>float</code> <p>amount that the impervious area in the land node is multiplied by (grass area is changed in compensation)</p> required <code>nodes</code> <code>list</code> <p>list of land nodes to change the parameters of. Defaults to None, which applies the change to all land nodes.</p> <code>None</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def change_runoff_coefficient(self, relative_change, nodes=None):\n    \"\"\"Clunky way to change the runoff coefficient of a land node.\n\n    Args:\n        relative_change (float): amount that the impervious area in the land\n            node is multiplied by (grass area is changed in compensation)\n        nodes (list, optional): list of land nodes to change the parameters of.\n            Defaults to None, which applies the change to all land nodes.\n    \"\"\"\n    # Multiplies impervious area by relative change and adjusts grassland\n    # accordingly\n    if nodes is None:\n        nodes = self.nodes_type[\"Land\"].values()\n\n    if isinstance(relative_change, float):\n        relative_change = {x: relative_change for x in nodes}\n\n    for node in nodes:\n        surface_dict = {x.surface: x for x in node.surfaces}\n        if \"Impervious\" in surface_dict.keys():\n            impervious_area = surface_dict[\"Impervious\"].area\n            grass_area = surface_dict[\"Grass\"].area\n\n            new_impervious_area = impervious_area * relative_change[node]\n            new_grass_area = grass_area + (impervious_area - new_impervious_area)\n            if new_grass_area &lt; 0:\n                print(\"not enough grass\")\n                break\n            surface_dict[\"Impervious\"].area = new_impervious_area\n            surface_dict[\"Impervious\"].capacity *= relative_change[node]\n\n            surface_dict[\"Grass\"].area = new_grass_area\n            surface_dict[\"Grass\"].capacity *= new_grass_area / grass_area\n            for pol in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                surface_dict[\"Grass\"].storage[pol] *= new_grass_area / grass_area\n            for pool in surface_dict[\"Grass\"].nutrient_pool.pools:\n                for nutrient in pool.storage.keys():\n                    pool.storage[nutrient] *= new_grass_area / grass_area\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.debug_node_mb","title":"<code>debug_node_mb()</code>","text":"<p>Simple function that iterates over nodes calling their mass balance function.</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def debug_node_mb(self):\n    \"\"\"Simple function that iterates over nodes calling their mass balance\n    function.\"\"\"\n    for node in self.nodelist:\n        _ = node.node_mass_balance()\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.default_settings","title":"<code>default_settings()</code>","text":"<p>Incomplete function that enables easy specification of results storage.</p> <p>Returns:</p> Type Description <code>dict</code> <p>default settings</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def default_settings(self):\n    \"\"\"Incomplete function that enables easy specification of results storage.\n\n    Returns:\n        (dict): default settings\n    \"\"\"\n    return {\n        \"arcs\": {\"flows\": True, \"pollutants\": True},\n        \"tanks\": {\"storages\": True, \"pollutants\": True},\n        \"mass_balance\": False,\n    }\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.get_init_args","title":"<code>get_init_args(cls)</code>","text":"<p>Get the arguments of the init method for a class and its superclasses.</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def get_init_args(self, cls):\n    \"\"\"Get the arguments of the __init__ method for a class and its superclasses.\"\"\"\n    init_args = []\n    for c in cls.__mro__:\n        # Get the arguments of the __init__ method\n        args = inspect.getfullargspec(c.__init__).args[1:]\n        init_args.extend(args)\n    return init_args\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.load","title":"<code>load(address, config_name='config.yml', overrides={})</code>","text":"<p>Parameters:</p> Name Type Description Default <code>address</code> required <code>config_name</code> <code>'config.yml'</code> <code>overrides</code> <code>{}</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def load(self, address, config_name=\"config.yml\", overrides={}):\n    \"\"\"\n\n    Args:\n        address:\n        config_name:\n        overrides:\n    \"\"\"\n    from ..extensions import apply_patches\n\n    with open(os.path.join(address, config_name), \"r\") as file:\n        data: dict = yaml.safe_load(file)\n\n    for key, item in overrides.items():\n        data[key] = item\n\n    constants.POLLUTANTS = data.get(\"pollutants\", constants.POLLUTANTS)\n    constants.ADDITIVE_POLLUTANTS = data.get(\n        \"additive_pollutants\", constants.ADDITIVE_POLLUTANTS\n    )\n    constants.NON_ADDITIVE_POLLUTANTS = data.get(\n        \"non_additive_pollutants\", constants.NON_ADDITIVE_POLLUTANTS\n    )\n    constants.FLOAT_ACCURACY = float(\n        data.get(\"float_accuracy\", constants.FLOAT_ACCURACY)\n    )\n    self.__dict__.update(Model().__dict__)\n\n    \"\"\"\n    FLAG:\n        E.G. ADDITION FOR NEW ORCHESTRATION\n    \"\"\"\n    load_extension_files(data.get(\"extensions\", []))\n    self.extensions = data.get(\"extensions\", [])\n\n    if \"orchestration\" in data.keys():\n        # Update orchestration\n        self.orchestration = data[\"orchestration\"]\n\n    if \"nodes\" not in data.keys():\n        raise ValueError(\"No nodes found in the config\")\n\n    nodes = data[\"nodes\"]\n\n    # Check if using unified data file\n    unified_data_file = data.get(\"unified_data_file\")\n    if unified_data_file and PARQUET_AVAILABLE:\n        self._load_unified_data(address, unified_data_file, nodes, data)\n    elif unified_data_file and not PARQUET_AVAILABLE:\n        raise ValueError(\"Parquet support is required for unified data loading\")\n    else:\n        self._load_individual_files(address, nodes, data)\n    arcs = data.get(\"arcs\", {})\n    self.add_nodes(list(nodes.values()))\n    self.add_arcs(list(arcs.values()))\n\n    self.add_overrides(data.get(\"overrides\", {}))\n\n    apply_patches(self)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.load_pickle","title":"<code>load_pickle(fid)</code>","text":"<p>Load model object to a pickle file, including the model states.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>str</code> <p>File address to load the pickled model from</p> required <p>Returns:</p> Name Type Description <code>model</code> <code>obj</code> <p>loaded model</p> Example Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def load_pickle(self, fid):\n    \"\"\"Load model object to a pickle file, including the model states.\n\n    Args:\n        fid (str): File address to load the pickled model from\n\n    Returns:\n        model (obj): loaded model\n\n    Example:\n        &gt;&gt;&gt; # Load and run your model\n        &gt;&gt;&gt; my_model.load(model_dir,config_name = 'config.yml')\n        &gt;&gt;&gt; _ = my_model.run()\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Save it including its different states\n        &gt;&gt;&gt; my_model.save_pickle('model_at_end_of_run.pkl')\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; # Load it at another time to resume the model from the end\n        &gt;&gt;&gt; # of the previous run\n        &gt;&gt;&gt; new_model = Model()\n        &gt;&gt;&gt; new_model = new_model.load_pickle('model_at_end_of_run.pkl')\n    \"\"\"\n    file = open(fid, \"rb\")\n    return pickle.load(file)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.load_pickle--load-and-run-your-model","title":"Load and run your model","text":"<p>my_model.load(model_dir,config_name = 'config.yml') _ = my_model.run()</p>"},{"location":"reference-model/#wsimod.orchestration.model.Model.load_pickle--save-it-including-its-different-states","title":"Save it including its different states","text":"<p>my_model.save_pickle('model_at_end_of_run.pkl')</p>"},{"location":"reference-model/#wsimod.orchestration.model.Model.load_pickle--load-it-at-another-time-to-resume-the-model-from-the-end","title":"Load it at another time to resume the model from the end","text":""},{"location":"reference-model/#wsimod.orchestration.model.Model.load_pickle--of-the-previous-run","title":"of the previous run","text":"<p>new_model = Model() new_model = new_model.load_pickle('model_at_end_of_run.pkl')</p>"},{"location":"reference-model/#wsimod.orchestration.model.Model.reinit","title":"<code>reinit()</code>","text":"<p>Reinitialise by ending all node/arc timesteps and calling reinit function in all nodes (generally zero-ing their storage values).</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def reinit(self):\n    \"\"\"Reinitialise by ending all node/arc timesteps and calling reinit function in\n    all nodes (generally zero-ing their storage values).\"\"\"\n    for node in self.nodes.values():\n        node.end_timestep()\n        for prop in dir(node):\n            prop = node.__getattribute__(prop)\n            for prop_ in dir(prop):\n                if prop_ == \"reinit\":\n                    prop_ = node.__getattribute__(prop_)\n                    prop_()\n\n    for arc in self.arcs.values():\n        arc.end_timestep()\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.run","title":"<code>run(dates=None, settings=None, record_arcs=None, record_tanks=None, record_surfaces=None, verbose=True, record_all=True, objectives=[])</code>","text":"<p>Run the model object with the default orchestration.</p> <p>Parameters:</p> Name Type Description Default <code>dates</code> <code>list</code> <p>Dates to simulate. Defaults to None, which simulates all dates that the model has data for.</p> <code>None</code> <code>settings</code> <code>dict</code> <p>Dict to specify what results are stored, not currently used. Defaults to None.</p> <code>None</code> <code>record_arcs</code> <code>list</code> <p>List of arcs to store result for. Defaults to None.</p> <code>None</code> <code>record_tanks</code> <code>list</code> <p>List of nodes with water stores to store results for. Defaults to None.</p> <code>None</code> <code>record_surfaces</code> <code>list</code> <p>List of tuples of (land node, surface) to store results for. Defaults to None.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Prints updates on simulation if true. Defaults to True.</p> <code>True</code> <code>record_all</code> <code>bool</code> <p>Specifies to store all results. Defaults to True.</p> <code>True</code> <code>objectives</code> <code>list</code> <p>A list of dicts with objectives to calculate (see examples). Defaults to [].</p> <code>[]</code> <p>Returns:</p> Name Type Description <code>flows</code> <p>simulated flows in a list of dicts</p> <code>tanks</code> <p>simulated tanks storages in a list of dicts</p> <code>objective_results</code> <p>list of values based on objectives list</p> <code>surfaces</code> <p>simulated surface storages of land nodes in a list of dicts</p> <p>Examples:</p>"},{"location":"reference-model/#wsimod.orchestration.model.Model.run--run-a-model-without-storing-any-results-but-calculating-objectives","title":"Run a model without storing any results but calculating objectives","text":"<p>import statistics as stats objectives = [{'element_type' : 'flows',                'name' : 'my_river',                'function' : @ (x, ) stats.mean([y['phosphate'] for y in x])                },               {'element_type' : 'tanks',                'name' : 'my_reservoir',                'function' : @ (x, model) sum([y['storage'] &lt; (model.nodes                ['my_reservoir'].tank.capacity / 2) for y in x])                }] , _, results, _ = my_model.run(record_all = False, objectives = objectives)</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def run(\n    self,\n    dates=None,\n    settings=None,\n    record_arcs=None,\n    record_tanks=None,\n    record_surfaces=None,\n    verbose=True,\n    record_all=True,\n    objectives=[],\n):\n    \"\"\"Run the model object with the default orchestration.\n\n    Args:\n        dates (list, optional): Dates to simulate. Defaults to None, which\n            simulates all dates that the model has data for.\n        settings (dict, optional): Dict to specify what results are stored,\n            not currently used. Defaults to None.\n        record_arcs (list, optional): List of arcs to store result for.\n            Defaults to None.\n        record_tanks (list, optional): List of nodes with water stores to\n            store results for. Defaults to None.\n        record_surfaces (list, optional): List of tuples of\n            (land node, surface) to store results for. Defaults to None.\n        verbose (bool, optional): Prints updates on simulation if true.\n            Defaults to True.\n        record_all (bool, optional): Specifies to store all results.\n            Defaults to True.\n        objectives (list, optional): A list of dicts with objectives to\n            calculate (see examples). Defaults to [].\n\n    Returns:\n        flows: simulated flows in a list of dicts\n        tanks: simulated tanks storages in a list of dicts\n        objective_results: list of values based on objectives list\n        surfaces: simulated surface storages of land nodes in a list of dicts\n\n    Examples:\n        # Run a model without storing any results but calculating objectives\n        import statistics as stats\n        objectives = [{'element_type' : 'flows',\n                       'name' : 'my_river',\n                       'function' : @ (x, _) stats.mean([y['phosphate'] for y in x])\n                       },\n                      {'element_type' : 'tanks',\n                       'name' : 'my_reservoir',\n                       'function' : @ (x, model) sum([y['storage'] &lt; (model.nodes\n                       ['my_reservoir'].tank.capacity / 2) for y in x])\n                       }]\n        _, _, results, _ = my_model.run(record_all = False, objectives = objectives)\n    \"\"\"\n    if record_arcs is None:\n        record_arcs = []\n        if record_all:\n            record_arcs = list(self.arcs.keys())\n    if record_tanks is None:\n        record_tanks = []\n\n    if record_surfaces is None:\n        record_surfaces = []\n\n    if settings is None:\n        settings = self.default_settings()\n\n    def blockPrint():\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        stdout = sys.stdout\n        sys.stdout = open(os.devnull, \"w\")\n        return stdout\n\n    def enablePrint(stdout):\n        \"\"\"\n\n        Args:\n            stdout:\n        \"\"\"\n        sys.stdout = stdout\n\n    if not verbose:\n        stdout = blockPrint()\n    if dates is None:\n        dates = self.dates\n\n    for objective in objectives:\n        if objective[\"element_type\"] == \"tanks\":\n            record_tanks.append(objective[\"name\"])\n        elif objective[\"element_type\"] == \"flows\":\n            record_arcs.append(objective[\"name\"])\n        elif objective[\"element_type\"] == \"surfaces\":\n            record_surfaces.append((objective[\"name\"], objective[\"surface\"]))\n        else:\n            print(\"element_type not recorded\")\n\n    flows = []\n    tanks = []\n    surfaces = []\n    for date in tqdm(dates, disable=(not verbose)):\n        # for date in dates:\n        for node in self.nodelist:\n            node.t = date\n            node.monthyear = date.to_period(\"M\")\n\n        # Iterate over orchestration\n        for timestep_item in self.orchestration:\n            for node_type, function in timestep_item.items():\n                for node in self.nodes_type.get(node_type, {}).values():\n                    getattr(node, function)()\n\n        # river\n        for node_name in self.river_discharge_order:\n            self.nodes[node_name].distribute()\n\n        # mass balance checking\n        # nodes/system\n        sys_in = self.empty_vqip()\n        sys_out = self.empty_vqip()\n        sys_ds = self.empty_vqip()\n\n        # arcs\n        for arc in self.arcs.values():\n            in_, ds_, out_ = arc.arc_mass_balance()\n            for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                sys_in[v] += in_[v]\n                sys_out[v] += out_[v]\n                sys_ds[v] += ds_[v]\n        for node in self.nodelist:\n            # print(node.name)\n            in_, ds_, out_ = node.node_mass_balance()\n\n            # temp = {'name' : node.name,\n            #         'time' : date}\n            # for lab, dict_ in zip(['in','ds','out'], [in_, ds_, out_]):\n            #     for key, value in dict_.items():\n            #         temp[(lab, key)] = value\n            # node_mb.append(temp)\n\n            for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n                sys_in[v] += in_[v]\n                sys_out[v] += out_[v]\n                sys_ds[v] += ds_[v]\n\n        for v in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n            # Find the largest value of in_, out_, ds_\n            largest = max(sys_in[v], sys_in[v], sys_in[v])\n\n            if largest &gt; constants.FLOAT_ACCURACY:\n                # Convert perform comparison in a magnitude to match the largest\n                # value\n                magnitude = 10 ** int(log10(largest))\n                in_10 = sys_in[v] / magnitude\n                out_10 = sys_in[v] / magnitude\n                ds_10 = sys_in[v] / magnitude\n            else:\n                in_10 = sys_in[v]\n                ds_10 = sys_in[v]\n                out_10 = sys_in[v]\n\n            if (in_10 - ds_10 - out_10) &gt; constants.FLOAT_ACCURACY:\n                print(\n                    \"system mass balance error for \"\n                    + v\n                    + \" of \"\n                    + str(sys_in[v] - sys_ds[v] - sys_out[v])\n                )\n\n        # Store results\n        for arc in record_arcs:\n            arc = self.arcs[arc]\n            flows.append(\n                {\"arc\": arc.name, \"flow\": arc.vqip_out[\"volume\"], \"time\": date}\n            )\n            for pol in constants.POLLUTANTS:\n                flows[-1][pol] = arc.vqip_out[pol]\n\n        for node in record_tanks:\n            node = self.nodes[node]\n            tanks.append(\n                {\n                    \"node\": node.name,\n                    \"storage\": node.tank.storage[\"volume\"],\n                    \"time\": date,\n                }\n            )\n\n        for node, surface in record_surfaces:\n            node = self.nodes[node]\n            name = node.name\n            surface = node.get_surface(surface)\n            if not isinstance(surface, ImperviousSurface):\n                surfaces.append(\n                    {\n                        \"node\": name,\n                        \"surface\": surface.surface,\n                        \"percolation\": surface.percolation[\"volume\"],\n                        \"subsurface_r\": surface.subsurface_flow[\"volume\"],\n                        \"surface_r\": surface.infiltration_excess[\"volume\"],\n                        \"storage\": surface.storage[\"volume\"],\n                        \"evaporation\": surface.evaporation[\"volume\"],\n                        \"precipitation\": surface.precipitation[\"volume\"],\n                        \"tank_recharge\": surface.tank_recharge,\n                        \"capacity\": surface.capacity,\n                        \"time\": date,\n                        \"et0_coef\": surface.et0_coefficient,\n                        # 'crop_factor' : surface.crop_factor\n                    }\n                )\n                for pol in constants.POLLUTANTS:\n                    surfaces[-1][pol] = surface.storage[pol]\n            else:\n                surfaces.append(\n                    {\n                        \"node\": name,\n                        \"surface\": surface.surface,\n                        \"storage\": surface.storage[\"volume\"],\n                        \"evaporation\": surface.evaporation[\"volume\"],\n                        \"precipitation\": surface.precipitation[\"volume\"],\n                        \"capacity\": surface.capacity,\n                        \"time\": date,\n                    }\n                )\n                for pol in constants.POLLUTANTS:\n                    surfaces[-1][pol] = surface.storage[pol]\n        if record_all:\n            for node in self.nodes.values():\n                for prop_ in dir(node):\n                    prop = node.__getattribute__(prop_)\n                    if prop.__class__ in [QueueTank, Tank, ResidenceTank]:\n                        tanks.append(\n                            {\n                                \"node\": node.name,\n                                \"time\": date,\n                                \"storage\": prop.storage[\"volume\"],\n                                \"prop\": prop_,\n                            }\n                        )\n                        for pol in constants.POLLUTANTS:\n                            tanks[-1][pol] = prop.storage[pol]\n\n            for name, node in self.nodes_type.get(\"Land\", {}).items():\n                for surface in node.surfaces:\n                    if not isinstance(surface, ImperviousSurface):\n                        surfaces.append(\n                            {\n                                \"node\": name,\n                                \"surface\": surface.surface,\n                                \"percolation\": surface.percolation[\"volume\"],\n                                \"subsurface_r\": surface.subsurface_flow[\"volume\"],\n                                \"surface_r\": surface.infiltration_excess[\"volume\"],\n                                \"storage\": surface.storage[\"volume\"],\n                                \"evaporation\": surface.evaporation[\"volume\"],\n                                \"precipitation\": surface.precipitation[\"volume\"],\n                                \"tank_recharge\": surface.tank_recharge,\n                                \"capacity\": surface.capacity,\n                                \"time\": date,\n                                \"et0_coef\": surface.et0_coefficient,\n                                # 'crop_factor' : surface.crop_factor\n                            }\n                        )\n                        for pol in constants.POLLUTANTS:\n                            surfaces[-1][pol] = surface.storage[pol]\n                    else:\n                        surfaces.append(\n                            {\n                                \"node\": name,\n                                \"surface\": surface.surface,\n                                \"storage\": surface.storage[\"volume\"],\n                                \"evaporation\": surface.evaporation[\"volume\"],\n                                \"precipitation\": surface.precipitation[\"volume\"],\n                                \"capacity\": surface.capacity,\n                                \"time\": date,\n                            }\n                        )\n                        for pol in constants.POLLUTANTS:\n                            surfaces[-1][pol] = surface.storage[pol]\n\n        for node in self.nodes.values():\n            node.end_timestep()\n\n        for arc in self.arcs.values():\n            arc.end_timestep()\n    objective_results = []\n    for objective in objectives:\n        if objective[\"element_type\"] == \"tanks\":\n            val = objective[\"function\"](\n                [x for x in tanks if x[\"node\"] == objective[\"name\"]], self\n            )\n        elif objective[\"element_type\"] == \"flows\":\n            val = objective[\"function\"](\n                [x for x in flows if x[\"arc\"] == objective[\"name\"]], self\n            )\n        elif objective[\"element_type\"] == \"surfaces\":\n            val = objective[\"function\"](\n                [\n                    x\n                    for x in surfaces\n                    if (x[\"node\"] == objective[\"name\"])\n                    &amp; (x[\"surface\"] == objective[\"surface\"])\n                ],\n                self,\n            )\n        objective_results.append(val)\n    if not verbose:\n        enablePrint(stdout)\n    return flows, tanks, objective_results, surfaces\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.save","title":"<code>save(address, config_name='config.yml', compress=False)</code>","text":"<p>Save the model object to a yaml file and input data to csv.gz format in the directory specified.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Path to a directory</p> required <code>config_name</code> <code>str</code> <p>Name of yaml model file. Defaults to 'model.yml'</p> <code>'config.yml'</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def save(self, address, config_name=\"config.yml\", compress=False):\n    \"\"\"Save the model object to a yaml file and input data to csv.gz format in the\n    directory specified.\n\n    Args:\n        address (str): Path to a directory\n        config_name (str, optional): Name of yaml model file.\n            Defaults to 'model.yml'\n    \"\"\"\n    if not os.path.exists(address):\n        os.mkdir(address)\n\n    if compress:\n        file_type = \"csv.gz\"\n    else:\n        file_type = \"csv\"\n\n    # Use the extracted config save method\n    self._save_model_config(\n        address, config_name, file_type=file_type, compress=compress\n    )\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.save_pickle","title":"<code>save_pickle(fid)</code>","text":"<p>Save model object to a pickle file, including saving the model states.</p> <p>Parameters:</p> Name Type Description Default <code>fid</code> <code>str</code> <p>File address to save the pickled model to</p> required <p>Returns:</p> Name Type Description <code>message</code> <code>str</code> <p>Exit message of pickle dump</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def save_pickle(self, fid):\n    \"\"\"Save model object to a pickle file, including saving the model states.\n\n    Args:\n        fid (str): File address to save the pickled model to\n\n    Returns:\n        message (str): Exit message of pickle dump\n    \"\"\"\n    file = open(fid, \"wb\")\n    pickle.dump(self, file)\n    return file.close()\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.Model.save_unified_data","title":"<code>save_unified_data(address, parquet_filename='unified_data.parquet', config_name='config.yml', compress=False)</code>","text":"<p>Save model data to a unified parquet file.</p> <p>Parameters:</p> Name Type Description Default <code>address</code> <code>str</code> <p>Path to save directory</p> required <code>parquet_filename</code> <code>str</code> <p>Name of the parquet file</p> <code>'unified_data.parquet'</code> <code>config_name</code> <code>str</code> <p>Name of the config file</p> <code>'config.yml'</code> <code>compress</code> <code>bool</code> <p>Whether to compress (not used for parquet)</p> <code>False</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def save_unified_data(\n    self,\n    address,\n    parquet_filename=\"unified_data.parquet\",\n    config_name=\"config.yml\",\n    compress=False,\n):\n    \"\"\"Save model data to a unified parquet file.\n\n    Args:\n        address (str): Path to save directory\n        parquet_filename (str): Name of the parquet file\n        config_name (str): Name of the config file\n        compress (bool): Whether to compress (not used for parquet)\n    \"\"\"\n    if not PARQUET_AVAILABLE:\n        raise ImportError(\n            \"parquet support (pyarrow or fastparquet) is required \"\n            \"for unified data saving\"\n        )\n\n    if not os.path.exists(address):\n        os.mkdir(address)\n\n    # Collect all data from nodes and surfaces\n    nodes_data = {}\n    surfaces_data = {}\n\n    for node in self.nodes.values():\n        if hasattr(node, \"data_input_dict\") and node.data_input_dict:\n            nodes_data[node.name] = node.data_input_dict\n\n        if hasattr(node, \"surfaces\"):\n            for surface in node.surfaces:\n                if hasattr(surface, \"data_input_dict\") and surface.data_input_dict:\n                    surfaces_data[(node.name, surface.surface)] = (\n                        surface.data_input_dict\n                    )\n\n    # Create unified DataFrame\n    unified_df = create_unified_dataframe(nodes_data, surfaces_data)\n\n    # Save unified parquet file\n    parquet_path = os.path.join(address, parquet_filename)\n    unified_df.to_parquet(parquet_path, index=False)\n\n    # Save config file using the extracted method\n    self._save_model_config(\n        address, config_name, unified_data_file=parquet_filename\n    )\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime","title":"<code>to_datetime</code>","text":"Source code in <code>wsimod/orchestration/model.py</code> <pre><code>class to_datetime:\n    \"\"\"\"\"\"\n\n    # TODO document and make better\n    def __init__(self, date_string):\n        \"\"\"Simple datetime wrapper that has key properties used in WSIMOD components.\n\n        Args:\n            date_string (str): A string containing the date, expected in\n                format %Y-%m-%d or %Y-%m.\n        \"\"\"\n        self._date = self._parse_date(date_string)\n        self._original_format = self._detect_original_format(date_string)\n\n    def __str__(self):\n        # Return format based on original input format\n        if self._original_format == \"YYYY-MM\":\n            return self._date.strftime(\"%Y-%m\")\n        return self._date.strftime(\"%Y-%m-%d\")\n\n    def __repr__(self):\n        # Return format based on original input format\n        if self._original_format == \"YYYY-MM\":\n            return self._date.strftime(\"%Y-%m\")\n        return self._date.strftime(\"%Y-%m-%d\")\n\n    @property\n    def dayofyear(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        return self._date.timetuple().tm_yday\n\n    @property\n    def day(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        return self._date.day\n\n    @property\n    def year(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        return self._date.year\n\n    @property\n    def month(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        return self._date.month\n\n    def to_period(self, args=\"M\"):\n        \"\"\"\n\n        Args:\n            args:\n\n        Returns:\n\n        \"\"\"\n        return to_datetime(f\"{self._date.year}-{str(self._date.month).zfill(2)}\")\n\n    def is_leap_year(self):\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        year = self._date.year\n        return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n\n    def _detect_original_format(self, date_string):\n        \"\"\"Detect the original format of the date string.\n\n        Args:\n            date_string (str): The original date string\n\n        Returns:\n            str: \"YYYY-MM\" or \"YYYY-MM-DD\" based on original format\n        \"\"\"\n        # Check if it matches YYYY-MM format\n        # (exactly 7 characters, no dashes after month)\n        if len(date_string) == 7 and date_string.count(\"-\") == 1:\n            return \"YYYY-MM\"\n        else:\n            return \"YYYY-MM-DD\"\n\n    def _parse_date(self, date_string, date_format=\"%Y-%m-%d %H:%M:%S\"):\n        try:\n            return datetime.strptime(date_string, date_format)\n        except ValueError:\n            try:\n                return datetime.strptime(date_string, \"%Y-%m-%d\")\n            except ValueError:\n                try:\n                    # Try 'YYYY-MM' format - set day to 1\n                    return datetime.strptime(date_string, \"%Y-%m\")\n                except ValueError:\n                    try:\n                        # Try 'YYYY-MM-DD HH:MM:SS' format\n                        return datetime.strptime(date_string, \"%Y-%m-%d %H:%M:%S\")\n                    except ValueError:\n                        # If all parsing attempts fail, raise a clear error\n                        raise ValueError(\n                            (\n                                \"Unable to parse date string '\"\n                                f\"{date_string}\"\n                                \"'. Expected formats: 'YYYY-MM-DD', 'YYYY-MM',\"\n                                \" or 'YYYY-MM-DD HH:MM:SS'\"\n                            )\n                        )\n\n    def __eq__(self, other):\n        if isinstance(other, to_datetime):\n            return self._date == other._date\n        return False\n\n    def __hash__(self):\n        return hash(self._date)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.day","title":"<code>day</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.dayofyear","title":"<code>dayofyear</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.month","title":"<code>month</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.year","title":"<code>year</code>  <code>property</code>","text":"<p>Returns:</p>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.__init__","title":"<code>__init__(date_string)</code>","text":"<p>Simple datetime wrapper that has key properties used in WSIMOD components.</p> <p>Parameters:</p> Name Type Description Default <code>date_string</code> <code>str</code> <p>A string containing the date, expected in format %Y-%m-%d or %Y-%m.</p> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def __init__(self, date_string):\n    \"\"\"Simple datetime wrapper that has key properties used in WSIMOD components.\n\n    Args:\n        date_string (str): A string containing the date, expected in\n            format %Y-%m-%d or %Y-%m.\n    \"\"\"\n    self._date = self._parse_date(date_string)\n    self._original_format = self._detect_original_format(date_string)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.is_leap_year","title":"<code>is_leap_year()</code>","text":"<p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def is_leap_year(self):\n    \"\"\"\n\n    Returns:\n\n    \"\"\"\n    year = self._date.year\n    return year % 4 == 0 and (year % 100 != 0 or year % 400 == 0)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.to_datetime.to_period","title":"<code>to_period(args='M')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>args</code> <code>'M'</code> <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def to_period(self, args=\"M\"):\n    \"\"\"\n\n    Args:\n        args:\n\n    Returns:\n\n    \"\"\"\n    return to_datetime(f\"{self._date.year}-{str(self._date.month).zfill(2)}\")\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.check_and_convert_string","title":"<code>check_and_convert_string(value)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>value</code> required <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def check_and_convert_string(value):\n    \"\"\"\n\n    Args:\n        value:\n\n    Returns:\n\n    \"\"\"\n    try:\n        return int(value)\n    except Exception:\n        try:\n            return float(value)\n        except Exception:\n            if value == \"None\":\n                return None\n            else:\n                return value\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.convert_keys","title":"<code>convert_keys(d)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> required <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def convert_keys(d):\n    \"\"\"\n\n    Args:\n        d:\n\n    Returns:\n\n    \"\"\"\n    # base case: if d is not a dict, return d\n    if not isinstance(d, dict):\n        return d\n    # recursive case: create a new dict with int keys and converted values\n    new_d = {}\n    for k, v in d.items():\n        new_d[check_and_convert_string(k)] = convert_keys(v)\n    return new_d\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.create_unified_dataframe","title":"<code>create_unified_dataframe(nodes_data, surfaces_data=None)</code>","text":"<p>Create a unified DataFrame from multiple nodes' data_input_dict.</p> <p>Parameters:</p> Name Type Description Default <code>nodes_data</code> <code>dict</code> <p>Dictionary mapping node names to their data_input_dict</p> required <code>surfaces_data</code> <code>dict</code> <p>Dictionary mapping (node_name, surface_name) to data_input_dict</p> <code>None</code> <p>Returns:</p> Type Description <p>pd.DataFrame: Unified DataFrame with columns: node, surface, variable, time, value</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def create_unified_dataframe(nodes_data, surfaces_data=None):\n    \"\"\"Create a unified DataFrame from multiple nodes' data_input_dict.\n\n    Args:\n        nodes_data (dict): Dictionary mapping node names to their data_input_dict\n        surfaces_data (dict, optional): Dictionary mapping (node_name,\n            surface_name) to data_input_dict\n\n    Returns:\n        pd.DataFrame: Unified DataFrame with columns: node, surface, variable,\n            time, value\n    \"\"\"\n    if not PARQUET_AVAILABLE:\n        raise ImportError(\n            \"parquet support (pyarrow or fastparquet) is required \"\n            \"for unified DataFrame support\"\n        )\n\n    rows = []\n\n    # Process nodes data\n    for node_name, data_dict in nodes_data.items():\n        for (variable, time), value in data_dict.items():\n            rows.append(\n                {\n                    \"node\": node_name,\n                    \"surface\": None,\n                    \"variable\": variable,\n                    \"time\": str(time),\n                    \"value\": value,\n                }\n            )\n\n    # Process surfaces data\n    if surfaces_data:\n        for (node_name, surface_name), data_dict in surfaces_data.items():\n            for (variable, time), value in data_dict.items():\n                rows.append(\n                    {\n                        \"node\": node_name,\n                        \"surface\": surface_name,\n                        \"variable\": variable,\n                        \"time\": str(time),\n                        \"value\": value,\n                    }\n                )\n\n    return pd.DataFrame(rows)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.csv2yaml","title":"<code>csv2yaml(address, config_name='config_csv.yml', csv_folder_name='csv')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>address</code> required <code>config_name</code> <code>'config_csv.yml'</code> <code>csv_folder_name</code> <code>'csv'</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def csv2yaml(address, config_name=\"config_csv.yml\", csv_folder_name=\"csv\"):\n    \"\"\"\n\n    Args:\n        address:\n        config_name:\n        csv_folder_name:\n    \"\"\"\n    csv_path = os.path.join(address, csv_folder_name)\n    csv_list = [\n        os.path.join(csv_path, f)\n        for f in os.listdir(csv_path)\n        if os.path.isfile(os.path.join(csv_path, f))\n    ]\n    objs_type = {\"nodes\": {}, \"arcs\": {}}\n    for fid in csv_list:\n        with open(fid, \"rt\") as f:\n            if \"Dates\" in fid:\n                reader = csv.reader(f, delimiter=\",\")\n                dates = []\n                for row in reader:\n                    dates.append(row[0])\n                objs_type[\"dates\"] = dates[1:]\n            else:\n                reader = csv.DictReader(f, delimiter=\",\")\n                data = {}\n                for row in reader:\n                    formatted_row = {}\n                    for key, value in row.items():\n                        if value:\n                            if (\"[\" in value) &amp; (\"]\" in value):\n                                # Convert lists\n                                value = value.strip(\"[]\")  # Remove the brackets\n                                value = value.replace(\"'\", \"\")  # Remove the string bits\n                                value = value.split(\", \")  # Split by comma\n                                value = [check_and_convert_string(x) for x in value]\n                            else:\n                                # Convert ints, floats and strings\n                                value = check_and_convert_string(value)\n\n                            # Convert key and store converted values\n                            formatted_row[key] = value\n                    if \"Sim_params\" not in fid:\n                        label = formatted_row[\"label\"]\n                        del formatted_row[\"label\"]\n\n                    formatted_row = unflatten_dict(formatted_row)\n                    formatted_row = convert_keys(formatted_row)\n\n                    # Convert nested dicts dicts\n                    data[row[\"name\"]] = formatted_row\n                if \"Sim_params\" in fid:\n                    objs_type = {\n                        **objs_type,\n                        **{x: y[\"value\"] for x, y in data.items()},\n                    }\n                else:\n                    objs_type[label] = {**objs_type[label], **data}\n    write_yaml(address, config_name, objs_type)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.flatten_dict","title":"<code>flatten_dict(d, parent_key='', sep='-')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> required <code>parent_key</code> <code>''</code> <code>sep</code> <code>'-'</code> <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def flatten_dict(d, parent_key=\"\", sep=\"-\"):\n    \"\"\"\n\n    Args:\n        d:\n        parent_key:\n        sep:\n\n    Returns:\n\n    \"\"\"\n    # Initialize an empty dictionary\n    flat_dict = {}\n    # Loop through each key-value pair in the input dictionary\n    for k, v in d.items():\n        # Construct a new key by appending the parent key and separator\n        new_key = str(parent_key) + sep + str(k) if parent_key else k\n        # If the value is another dictionary, call the function recursively\n        if isinstance(v, dict):\n            flat_dict.update(flatten_dict(v, new_key, sep))\n        # Otherwise, add the key-value pair to the flat dictionary\n        else:\n            flat_dict[new_key] = v\n    # Return the flattened dictionary\n    return flat_dict\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.load_extension_files","title":"<code>load_extension_files(files)</code>","text":"<p>Load extension files from a list of files.</p> <p>Parameters:</p> Name Type Description Default <code>files</code> <code>list[str]</code> <p>List of file paths to load</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If file is not a .py file</p> <code>FileNotFoundError</code> <p>If file does not exist</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def load_extension_files(files: list[str]) -&gt; None:\n    \"\"\"Load extension files from a list of files.\n\n    Args:\n        files (list[str]): List of file paths to load\n\n    Raises:\n        ValueError: If file is not a .py file\n        FileNotFoundError: If file does not exist\n    \"\"\"\n    import importlib\n    from pathlib import Path\n\n    for file in files:\n        if not file.endswith(\".py\"):\n            raise ValueError(f\"Only .py files are supported. Invalid file: {file}\")\n        if not Path(file).exists():\n            raise FileNotFoundError(f\"File {file} does not exist\")\n\n        spec = importlib.util.spec_from_file_location(\"module.name\", file)\n        module = importlib.util.module_from_spec(spec)\n        spec.loader.exec_module(module)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.open_func","title":"<code>open_func(file_path, mode)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> required <code>mode</code> required <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def open_func(file_path, mode):\n    \"\"\"\n\n    Args:\n        file_path:\n        mode:\n\n    Returns:\n\n    \"\"\"\n    if mode == \"rt\" and file_path.endswith(\".gz\"):\n        return gzip.open(file_path, mode)\n    else:\n        return open(file_path, mode)\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.read_csv","title":"<code>read_csv(file_path, delimiter=',')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>file_path</code> required <code>delimiter</code> <code>','</code> <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def read_csv(file_path, delimiter=\",\"):\n    \"\"\"\n\n    Args:\n        file_path:\n        delimiter:\n\n    Returns:\n\n    \"\"\"\n    with open_func(file_path, \"rt\") as f:\n        reader = csv.DictReader(f, delimiter=delimiter)\n        data = {}\n        for row in reader:\n            key = (row[\"variable\"], to_datetime(row[\"time\"]))\n            value = float(row[\"value\"])\n            data[key] = value\n        return data\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.unflatten_dict","title":"<code>unflatten_dict(d, sep=':')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>d</code> required <code>sep</code> <code>':'</code> <p>Returns:</p> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def unflatten_dict(d, sep=\":\"):\n    \"\"\"\n\n    Args:\n        d:\n        sep:\n\n    Returns:\n\n    \"\"\"\n    result = {}\n    for k, v in d.items():\n        keys = k.split(sep)\n        current = result\n        for key in keys[:-1]:\n            current = current.setdefault(key, {})\n        current[keys[-1]] = v\n    return result\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.write_csv","title":"<code>write_csv(data, fixed_data={}, filename='', compress=False)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>data</code> required <code>fixed_data</code> <code>{}</code> <code>filename</code> <code>''</code> <code>compress</code> <code>False</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def write_csv(data, fixed_data={}, filename=\"\", compress=False):\n    \"\"\"\n\n    Args:\n        data:\n        fixed_data:\n        filename:\n        compress:\n    \"\"\"\n    if compress:\n        open_func = gzip.open\n        mode = \"wt\"\n    else:\n        open_func = open\n        mode = \"w\"\n    with open_func(filename, mode, newline=\"\") as csvfile:\n        writer = csv.writer(csvfile)\n        writer.writerow(list(fixed_data.keys()) + [\"variable\", \"time\", \"value\"])\n        fixed_data_values = list(fixed_data.values())\n        for key, value in data.items():\n            writer.writerow(fixed_data_values + list(key) + [str(value)])\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.write_yaml","title":"<code>write_yaml(address, config_name, data)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>address</code> required <code>config_name</code> required <code>data</code> required Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def write_yaml(address, config_name, data):\n    \"\"\"\n\n    Args:\n        address:\n        config_name:\n        data:\n    \"\"\"\n    with open(os.path.join(address, config_name), \"w\") as file:\n        yaml.dump(\n            data,\n            file,\n            default_flow_style=False,\n            sort_keys=False,\n            Dumper=yaml.SafeDumper,\n        )\n</code></pre>"},{"location":"reference-model/#wsimod.orchestration.model.yaml2csv","title":"<code>yaml2csv(address, config_name='config.yml', csv_folder_name='csv')</code>","text":"<p>Parameters:</p> Name Type Description Default <code>address</code> required <code>config_name</code> <code>'config.yml'</code> <code>csv_folder_name</code> <code>'csv'</code> Source code in <code>wsimod/orchestration/model.py</code> <pre><code>def yaml2csv(address, config_name=\"config.yml\", csv_folder_name=\"csv\"):\n    \"\"\"\n\n    Args:\n        address:\n        config_name:\n        csv_folder_name:\n    \"\"\"\n    with open(os.path.join(address, config_name), \"r\") as file:\n        data = yaml.safe_load(file)\n\n    # Format to easy format to write to database\n    objs_type = {}\n    for objects, object_label in zip([data[\"nodes\"], data[\"arcs\"]], [\"nodes\", \"arcs\"]):\n        for key, value in objects.items():\n            if isinstance(value, dict):\n                # Identify node type\n                if \"node_type_override\" in value.keys():\n                    type_ = value[\"node_type_override\"]\n                elif \"type_\" in value.keys():\n                    type_ = value[\"type_\"]\n                else:\n                    type_ = False\n\n                if type_:\n                    # Flatten dictionaries\n                    new_dict = {}\n                    if type_ not in objs_type.keys():\n                        objs_type[type_] = {}\n\n                    for key_, value_ in value.items():\n                        if isinstance(value_, dict):\n                            new_dict[key_] = flatten_dict(value_, key_, \":\")\n\n                    for key_, value_ in new_dict.items():\n                        del value[key_]\n                        value = {**value, **value_}\n                    value[\"label\"] = object_label\n                    objs_type[type_][key] = value\n\n    del data[\"nodes\"]\n    del data[\"arcs\"]\n    if \"dates\" in data.keys():\n        objs_type[\"Dates\"] = data[\"dates\"]\n        del data[\"dates\"]\n\n    objs_type[\"Sim_params\"] = {x: {\"name\": x, \"value\": y} for x, y in data.items()}\n\n    csv_dir = os.path.join(address, csv_folder_name)\n\n    if not os.path.exists(csv_dir):\n        os.mkdir(csv_dir)\n\n    for key, value in objs_type.items():\n        if key == \"Sim_params\":\n            fields = [\"name\", \"value\"]\n        elif key == \"Dates\":\n            fields = [\"date\"]\n        else:\n            fields = {}\n            for value_ in value.values():\n                fields = {**fields, **value_}\n\n            del fields[\"name\"]\n            fields = [\"name\"] + list(fields.keys())\n\n        with open(\n            os.path.join(csv_dir, \"{0}.csv\".format(key)), \"w\", newline=\"\"\n        ) as csvfile:\n            writer = csv.writer(csvfile)\n            writer.writerow(fields)\n            if key == \"Dates\":\n                for date in value:\n                    writer.writerow([date])\n            else:\n                for key_, value_ in value.items():\n                    writer.writerow(\n                        [str(value_[x]) if x in value_.keys() else None for x in fields]\n                    )\n</code></pre>"},{"location":"reference-nodes/","title":"API Reference - Nodes","text":"<p>This section of the documentation provides a reference for the API of the nodes.nodes module.</p> <p>Created on Wed Apr  7 08:43:32 2021.</p> <p>@author: Barney</p> <p>Converted to totals on Thur Apr 21 2022</p>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node","title":"<code>Node</code>","text":"<p>               Bases: <code>WSIObj</code></p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>class Node(WSIObj):\n    \"\"\"\"\"\"\n\n    def __init_subclass__(cls, **kwargs):\n        \"\"\"Adds all subclasses to the nodes registry.\"\"\"\n        super().__init_subclass__(**kwargs)\n        if cls.__name__ in NODES_REGISTRY:\n            logging.warning(f\"Overwriting {cls.__name__} in NODES_REGISTRY with {cls}\")\n\n        NODES_REGISTRY[cls.__name__] = cls\n\n    def __init__(self, name, data_input_dict=None):\n        \"\"\"Base class for CWSD nodes. Constructs all the necessary attributes for the\n        node object.\n\n        Args:\n            name (str): Name of node\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node. Keys are tuples where first value is the name of the\n                variable to read from the dict and the second value is the time.\n                Defaults to None.\n\n        Examples:\n            &gt;&gt;&gt; my_node = nodes.Node(name = 'london_river_junction')\n\n        Key assumptions:\n            - No physical processes represented, can be used as a junction.\n\n        Input data and parameter requirements:\n            - All nodes require a `name`\n        \"\"\"\n        node_types = list(NODES_REGISTRY.keys())\n\n        # Default essential parameters\n        # Dictionary of arcs\n        self.in_arcs = {}\n        self.out_arcs = {}\n        self.in_arcs_type = {x: {} for x in node_types}\n        self.out_arcs_type = {x: {} for x in node_types}\n\n        # Set parameters\n        self.name = name\n        self.t = None\n        self.data_input_dict = data_input_dict\n\n        # Initiailise default handlers\n        self.pull_set_handler = {\"default\": self.pull_distributed}\n        self.push_set_handler = {\n            \"default\": lambda x: self.push_distributed(\n                x, of_type=[\"Node\", \"River\", \"Waste\", \"Reservoir\"]\n            )\n        }\n        self.pull_check_handler = {\"default\": self.pull_check_basic}\n        self.push_check_handler = {\n            \"default\": lambda x: self.push_check_basic(\n                x, of_type=[\"Node\", \"River\", \"Waste\", \"Reservoir\"]\n            )\n        }\n        super().__init__()\n\n        # Mass balance checking\n        self.mass_balance_in = [self.total_in]\n        self.mass_balance_out = [self.total_out]\n        self.mass_balance_ds = [lambda: self.empty_vqip()]\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}) -&gt; None:\n        \"\"\"Apply overrides to the node.\n\n        The Node does not have any overwriteable parameters. So if any\n        overrides are passed up to the node, this means that there are unused\n        parameters from the Node subclass, which is flagged.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        # overrides data_input_dict\n        from wsimod.orchestration.model import read_csv\n\n        content = overrides.pop(\"filename\", None)\n        if isinstance(content, str):\n            self.data_input_dict = read_csv(content)\n        elif not content:\n            pass\n        else:\n            raise RuntimeError(\"Not recognised format for data_input_dict\")\n\n        if len(overrides) &gt; 0:\n            print(f\"No override behaviour defined for: {overrides.keys()}\")\n\n    def total_in(self):\n        \"\"\"Sum flow and pollutant amounts entering a node via in_arcs.\n\n        Returns:\n            in_ (dict): Summed VQIP of in_arcs\n\n        Examples:\n            &gt;&gt;&gt; node_inflow = my_node.total_in()\n        \"\"\"\n        in_ = self.empty_vqip()\n        for arc in self.in_arcs.values():\n            in_ = self.sum_vqip(in_, arc.vqip_out)\n\n        return in_\n\n    def total_out(self):\n        \"\"\"Sum flow and pollutant amounts leaving a node via out_arcs.\n\n        Returns:\n            out_ (dict): Summed VQIP of out_arcs\n\n        Examples:\n            &gt;&gt;&gt; node_outflow = my_node.total_out()\n        \"\"\"\n        out_ = self.empty_vqip()\n        for arc in self.out_arcs.values():\n            out_ = self.sum_vqip(out_, arc.vqip_in)\n\n        return out_\n\n    def node_mass_balance(self):\n        \"\"\"Wrapper for core.py/WSIObj/mass_balance. Tracks change in mass balance.\n\n        Returns:\n            in_ (dict): A VQIP of the total from mass_balance_in functions\n            ds_ (dict): A VQIP of the total from mass_balance_ds functions\n            out_ (dict): A VQIP of the total from mass_balance_out functions\n\n        Examples:\n            &gt;&gt;&gt; node_in, node_out, node_ds = my_node.node_mass_balance()\n        \"\"\"\n        in_, ds_, out_ = self.mass_balance()\n        return in_, ds_, out_\n\n    def pull_set(self, vqip, tag=\"default\"):\n        \"\"\"Receives pull set requests from arcs and passes request to query handler.\n\n        Args:\n            vqip (dict): the VQIP pull request (by default, only the 'volume' key is\n                needed).\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): VQIP received from query_handler\n\n        Examples:\n            &gt;&gt;&gt; water_received = my_node.pull_set({'volume' : 10})\n        \"\"\"\n        return self.query_handler(self.pull_set_handler, vqip, tag)\n\n    def push_set(self, vqip, tag=\"default\"):\n        \"\"\"Receives push set requests from arcs and passes request to query handler.\n\n        Args:\n            vqip (_type_): the VQIP push request\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): VQIP not received from query_handler\n\n        Examples:\n            water_not_pushed = my_node.push_set(wastewater_vqip)\n        \"\"\"\n        return self.query_handler(self.push_set_handler, vqip, tag)\n\n    def pull_check(self, vqip=None, tag=\"default\"):\n        \"\"\"Receives pull check requests from arcs and passes request to query handler.\n\n        Args:\n            vqip (dict, optional): the VQIP pull check (by default, only the\n                'volume' key is used). Defaults to None, which returns all available\n                water to pull.\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): VQIP available from query_handler\n\n        Examples:\n            &gt;&gt;&gt; water_available = my_node.pull_check({'volume' : 10})\n            &gt;&gt;&gt; total_water_available = my_node.pull_check()\n        \"\"\"\n        return self.query_handler(self.pull_check_handler, vqip, tag)\n\n    def push_check(self, vqip=None, tag=\"default\"):\n        \"\"\"Receives push check requests from arcs and passes request to query handler.\n\n        Args:\n            vqip (dict, optional): the VQIP push check. Defaults to None, which\n                returns all available capacity to push\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'\n\n        Returns:\n            (dict): VQIP available to push from query_handler\n\n        Examples:\n            &gt;&gt;&gt; total_available_push_capacity = my_node.push_check()\n            &gt;&gt;&gt; available_push_capacity = my_node.push_check(wastewater_vqip)\n        \"\"\"\n        return self.query_handler(self.push_check_handler, vqip, tag)\n\n    def get_direction_arcs(self, direction, of_type=None):\n        \"\"\"Identify arcs to/from all attached nodes in a given direction.\n\n        Args:\n            direction (str): can be either 'pull' or 'push' to send checks to\n                receiving or contributing nodes\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n\n        Returns:\n            f (str): Either 'send_pull_check' or 'send_push_check' depending on\n                direction\n            arcs (list): List of arc objects\n\n        Raises:\n            Message if no direction is specified\n\n        Examples:\n            &gt;&gt;&gt; arcs_to_push_to = my_node.get_direction_arcs('push')\n            &gt;&gt;&gt; arcs_to_pull_from = my_node.get_direction_arcs('pull')\n            &gt;&gt;&gt; arcs_from_reservoirs = my_node.get_direction_arcs('pull', of_type =\n                'Reservoir')\n        \"\"\"\n        if of_type is None:\n            # Return all arcs\n            if direction == \"pull\":\n                arcs = list(self.in_arcs.values())\n                f = \"send_pull_check\"\n            elif direction == \"push\":\n                arcs = list(self.out_arcs.values())\n                f = \"send_push_check\"\n            else:\n                print(\"No direction\")\n\n        else:\n            if isinstance(of_type, str):\n                of_type = [of_type]\n\n            # Assign arcs/function based on parameters\n            arcs = []\n            if direction == \"pull\":\n                for type_ in of_type:\n                    arcs += list(self.in_arcs_type[type_].values())\n                f = \"send_pull_check\"\n            elif direction == \"push\":\n                for type_ in of_type:\n                    arcs += list(self.out_arcs_type[type_].values())\n                f = \"send_push_check\"\n            else:\n                print(\"No direction\")\n\n        return f, arcs\n\n    def get_connected(self, direction=\"pull\", of_type=None, tag=\"default\"):\n        \"\"\"Send push/pull checks to all attached arcs in a given direction.\n\n        Args:\n            direction (str, optional): The type of check to send to all attached\n                nodes. Can be 'push' or 'pull'. The default is 'pull'.\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            connected (dict) :\n                Dictionary containing keys:\n                'avail': (float) - total available volume for push/pull\n                'priority': (float) - total (availability * preference)\n                                    of attached arcs\n                'allocation': (dict) - contains all attached arcs in specified\n                                direction and respective (availability * preference)\n\n        Examples:\n            &gt;&gt;&gt; vqip_available_to_pull = my_node.get_direction_arcs()\n            &gt;&gt;&gt; vqip_available_to_push = my_node.get_direction_arcs('push')\n            &gt;&gt;&gt; avail_reservoir_vqip = my_node.get_direction_arcs('pull',\n                                                          of_type = 'Reservoir')\n            &gt;&gt;&gt; avail_sewer_push_to_sewers = my_node.get_direction_arcs('push',\n                                                                of_type = 'Sewer',\n                                                                tag = 'Sewer')\n        \"\"\"\n        # Initialise connected dict\n        connected = {\"avail\": 0, \"priority\": 0, \"allocation\": {}, \"capacity\": {}}\n\n        # Get arcs\n        f, arcs = self.get_direction_arcs(direction, of_type)\n\n        # Iterate over arcs, updating connected dict\n        for arc in arcs:\n            avail = getattr(arc, f)(tag=tag)[\"volume\"]\n            if avail &lt; constants.FLOAT_ACCURACY:\n                avail = 0  # Improves convergence\n            connected[\"avail\"] += avail\n            preference = arc.preference\n            connected[\"priority\"] += avail * preference\n            connected[\"allocation\"][arc.name] = avail * preference\n            connected[\"capacity\"][arc.name] = avail\n\n        return connected\n\n    def query_handler(self, handler, ip, tag):\n        \"\"\"Sends all push/pull requests/checks using the handler (i.e., ensures the\n        correct function is used that lines up with 'tag').\n\n        Args:\n            handler (dict): contains all push/pull requests for various tags\n            ip (vqip): the vqip request\n            tag (str): describes what type of push/pull request should be called\n\n        Returns:\n            (dict): the VQIP reply from push/pull request\n\n        Raises:\n            Message if no functions are defined for tag and if request/check\n            function fails\n        \"\"\"\n        try:\n            return handler[tag](ip)\n        except Exception:\n            if tag not in handler.keys():\n                print(\"No functions defined for \" + tag)\n                return handler[tag](ip)\n            else:\n                print(\"Some other error\")\n                return handler[tag](ip)\n\n    def pull_distributed(self, vqip, of_type=None, tag=\"default\"):\n        \"\"\"Send pull requests to all (or specified by type) nodes connecting to self.\n        Iterate until request is met or maximum iterations are hit. Streamlines if only\n        one in_arc exists.\n\n        Args:\n            vqip (dict): Total amount to pull (by default, only the\n                'volume' key is used)\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            pulled (dict): VQIP of combined pulled water\n        \"\"\"\n        if len(self.in_arcs) == 1:\n            # If only one in_arc, just pull from that\n            if of_type is None:\n                pulled = next(iter(self.in_arcs.values())).send_pull_request(\n                    vqip, tag=tag\n                )\n            elif any(\n                [x in of_type for x, y in self.in_arcs_type.items() if len(y) &gt; 0]\n            ):\n                pulled = next(iter(self.in_arcs.values())).send_pull_request(\n                    vqip, tag=tag\n                )\n            else:\n                # No viable out arcs\n                pulled = self.empty_vqip()\n        else:\n            # Pull in proportion from connected by priority\n\n            # Initialise pulled, deficit, connected, iter_\n            pulled = self.empty_vqip()\n            deficit = vqip[\"volume\"]\n            connected = self.get_connected(direction=\"pull\", of_type=of_type, tag=tag)\n            iter_ = 0\n\n            # Iterate over sending nodes until deficit met\n            while (\n                (deficit &gt; constants.FLOAT_ACCURACY)\n                &amp; (connected[\"avail\"] &gt; constants.FLOAT_ACCURACY)\n            ) &amp; (iter_ &lt; constants.MAXITER):\n                # Pull from connected\n                for key, allocation in connected[\"allocation\"].items():\n                    received = self.in_arcs[key].send_pull_request(\n                        {\"volume\": deficit * allocation / connected[\"priority\"]},\n                        tag=tag,\n                    )\n                    pulled = self.sum_vqip(pulled, received)\n\n                # Update deficit, connected and iter_\n                deficit = vqip[\"volume\"] - pulled[\"volume\"]\n                connected = self.get_connected(\n                    direction=\"pull\", of_type=of_type, tag=tag\n                )\n                iter_ += 1\n\n            if iter_ == constants.MAXITER:\n                print(\"Maxiter reached in {0} at {1}\".format(self.name, self.t))\n        return pulled\n\n    def push_distributed(self, vqip, of_type=None, tag=\"default\"):\n        \"\"\"Send push requests to all (or specified by type) nodes connecting to self.\n        Iterate until request is met or maximum iterations are hit. Streamlines if only\n        one in_arc exists.\n\n        Args:\n            vqip (dict): Total amount to push\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            not_pushed_ (dict): VQIP of water that cannot be pushed\n        \"\"\"\n        if len(self.out_arcs) == 1:\n            # If only one out_arc, just send the water down that\n            if of_type is None:\n                not_pushed_ = next(iter(self.out_arcs.values())).send_push_request(\n                    vqip, tag=tag\n                )\n            elif any(\n                [x in of_type for x, y in self.out_arcs_type.items() if len(y) &gt; 0]\n            ):\n                not_pushed_ = next(iter(self.out_arcs.values())).send_push_request(\n                    vqip, tag=tag\n                )\n            else:\n                # No viable out arcs\n                not_pushed_ = vqip\n        else:\n            # Push in proportion to connected by priority\n            # Initialise pushed, deficit, connected, iter_\n            not_pushed = vqip[\"volume\"]\n            not_pushed_ = self.copy_vqip(vqip)\n            connected = self.get_connected(direction=\"push\", of_type=of_type, tag=tag)\n            iter_ = 0\n            if not_pushed &gt; connected[\"avail\"]:\n                # If more water than can be pushed, ignore preference and allocate all\n                #   available based on capacity\n                connected[\"priority\"] = connected[\"avail\"]\n                connected[\"allocation\"] = connected[\"capacity\"]\n\n            # Iterate over receiving nodes until sent\n            while (\n                (not_pushed &gt; constants.FLOAT_ACCURACY)\n                &amp; (connected[\"avail\"] &gt; constants.FLOAT_ACCURACY)\n                &amp; (iter_ &lt; constants.MAXITER)\n            ):\n                # Push to connected\n                amount_to_push = min(connected[\"avail\"], not_pushed)\n\n                for key, allocation in connected[\"allocation\"].items():\n                    to_send = amount_to_push * allocation / connected[\"priority\"]\n                    to_send = self.v_change_vqip(not_pushed_, to_send)\n                    reply = self.out_arcs[key].send_push_request(to_send, tag=tag)\n\n                    sent = self.extract_vqip(to_send, reply)\n                    not_pushed_ = self.extract_vqip(not_pushed_, sent)\n\n                not_pushed = not_pushed_[\"volume\"]\n                connected = self.get_connected(\n                    direction=\"push\", of_type=of_type, tag=tag\n                )\n                iter_ += 1\n\n            if iter_ == constants.MAXITER:\n                print(\"Maxiter reached in {0} at {1}\".format(self.name, self.t))\n\n        return not_pushed_\n\n    def check_basic(self, direction, vqip=None, of_type=None, tag=\"default\"):\n        \"\"\"Generic function that conveys a pull or push check onwards to connected\n        nodes. It is the default behaviour that treats a node like a junction.\n\n        Args:\n            direction (str): can be either 'pull' or 'push' to send checks to\n                receiving or contributing nodes\n            vqip (dict, optional): The VQIP to check. Defaults to None (if pulling\n                this will return available water to pull, if pushing then available\n                capacity to push).\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            avail (dict): VQIP responses summed over all requests\n        \"\"\"\n        f, arcs = self.get_direction_arcs(direction, of_type)\n\n        # Iterate over arcs, updating total\n        avail = self.empty_vqip()\n        for arc in arcs:\n            avail = self.sum_vqip(avail, getattr(arc, f)(tag=tag))\n\n        if vqip is not None:\n            avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n        return avail\n\n    def pull_check_basic(self, vqip=None, of_type=None, tag=\"default\"):\n        \"\"\"Default node check behaviour that treats a node like a junction. Water\n        available to pull is just the water available to pull from upstream connected\n        nodes.\n\n        Args:\n            vqip (dict, optional): VQIP from handler of amount to pull check\n                (by default, only the 'volume' key is used). Defaults to None (which\n                returns all availalbe water to pull).\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): VQIP check response of upstream nodes\n        \"\"\"\n        return self.check_basic(\"pull\", vqip, of_type, tag)\n\n    def push_check_basic(self, vqip=None, of_type=None, tag=\"default\"):\n        \"\"\"Default node check behaviour that treats a node like a junction. Water\n        available to push is just the water available to push to downstream connected\n        nodes.\n\n        Args:\n            vqip (dict, optional): VQIP from handler of amount to push check.\n                Defaults to None (which returns all available capacity to push).\n            of_type (str or list) : optional, can be specified to send checks only\n                to nodes of a given type (must be a subclass in nodes.py)\n            tag (str, optional): optional message to direct query_handler which pull\n                function to call. Defaults to 'default'.\n\n        Returns:\n            (dict): VQIP check response of downstream nodes\n        \"\"\"\n        return self.check_basic(\"push\", vqip, of_type, tag)\n\n    def pull_set_deny(self, vqip):\n        \"\"\"Responds that no water is available to pull from a request.\n\n        Args:\n            vqip (dict): A VQIP amount of water requested (ignored)\n\n        Returns:\n            (dict): An empty VQIP indicated no water was pulled\n\n        Raises:\n            Message when called, since it would usually occur if a model is\n            improperly connected\n        \"\"\"\n        print(\"Attempted pull set from deny\")\n        return self.empty_vqip()\n\n    def pull_check_deny(self, vqip=None):\n        \"\"\"Responds that no water is available to pull from a check.\n\n        Args:\n            vqip (dict): A VQIP amount of water requested (ignored)\n\n        Returns:\n            (dict): An empty VQIP indicated no water was pulled\n\n        Raises:\n            Message when called, since it would usually occur if a model is\n            improperly connected\n        \"\"\"\n        print(\"Attempted pull check from deny\")\n        return self.empty_vqip()\n\n    def push_set_deny(self, vqip):\n        \"\"\"Responds that no water is available to push in a request.\n\n        Args:\n            vqip (dict): A VQIP amount of water to push\n\n        Returns:\n            vqip (dict): Returns the request indicating no water was pushed\n\n        Raises:\n            Message when called, since it would usually occur if a model is\n            improperly connected\n        \"\"\"\n        print(\"Attempted push set to deny\")\n        return vqip\n\n    def push_check_deny(self, vqip=None):\n        \"\"\"Responds that no water is available to push in a check.\n\n        Args:\n            vqip (dict): A VQIP amount of water to push check (ignored)\n\n        Returns:\n            (dict): An empty VQIP indicated no capacity for pushes exists\n\n        Raises:\n            Message when called, since it would usually occur if a model is\n            improperly connected\n        \"\"\"\n        print(\"Attempted push check to deny\")\n        return self.empty_vqip()\n\n    def push_check_accept(self, vqip=None):\n        \"\"\"Push check function that accepts all water.\n\n        Args:\n            vqip (dict, optional): A VQIP that has been pushed (ignored)\n\n        Returns:\n            (dict): VQIP or an unbounded capacity, indicating all water can be received\n        \"\"\"\n        if not vqip:\n            vqip = self.empty_vqip()\n            vqip[\"volume\"] = constants.UNBOUNDED_CAPACITY\n        return vqip\n\n    def get_data_input(self, var):\n        \"\"\"Read data from data_input_dict. Keys are tuples with the first entry as the\n        variable to read and second entry the time.\n\n        Args:\n            var (str): Name of variable\n\n        Returns:\n            Data read\n        \"\"\"\n        return self.data_input_dict[(var, self.t)]\n\n    def end_timestep(self):\n        \"\"\"Empty function intended to be called at the end of every timestep.\n\n        Subclasses will overwrite this functions.\n        \"\"\"\n        pass\n\n    def reinit(self):\n        \"\"\"Empty function to be written if reinitialisation capability is added.\"\"\"\n        pass\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.__init__","title":"<code>__init__(name, data_input_dict=None)</code>","text":"<p>Base class for CWSD nodes. Constructs all the necessary attributes for the node object.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of node</p> required <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node. Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Defaults to None.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; my_node = nodes.Node(name = 'london_river_junction')\n</code></pre> Key assumptions <ul> <li>No physical processes represented, can be used as a junction.</li> </ul> Input data and parameter requirements <ul> <li>All nodes require a <code>name</code></li> </ul> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def __init__(self, name, data_input_dict=None):\n    \"\"\"Base class for CWSD nodes. Constructs all the necessary attributes for the\n    node object.\n\n    Args:\n        name (str): Name of node\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node. Keys are tuples where first value is the name of the\n            variable to read from the dict and the second value is the time.\n            Defaults to None.\n\n    Examples:\n        &gt;&gt;&gt; my_node = nodes.Node(name = 'london_river_junction')\n\n    Key assumptions:\n        - No physical processes represented, can be used as a junction.\n\n    Input data and parameter requirements:\n        - All nodes require a `name`\n    \"\"\"\n    node_types = list(NODES_REGISTRY.keys())\n\n    # Default essential parameters\n    # Dictionary of arcs\n    self.in_arcs = {}\n    self.out_arcs = {}\n    self.in_arcs_type = {x: {} for x in node_types}\n    self.out_arcs_type = {x: {} for x in node_types}\n\n    # Set parameters\n    self.name = name\n    self.t = None\n    self.data_input_dict = data_input_dict\n\n    # Initiailise default handlers\n    self.pull_set_handler = {\"default\": self.pull_distributed}\n    self.push_set_handler = {\n        \"default\": lambda x: self.push_distributed(\n            x, of_type=[\"Node\", \"River\", \"Waste\", \"Reservoir\"]\n        )\n    }\n    self.pull_check_handler = {\"default\": self.pull_check_basic}\n    self.push_check_handler = {\n        \"default\": lambda x: self.push_check_basic(\n            x, of_type=[\"Node\", \"River\", \"Waste\", \"Reservoir\"]\n        )\n    }\n    super().__init__()\n\n    # Mass balance checking\n    self.mass_balance_in = [self.total_in]\n    self.mass_balance_out = [self.total_out]\n    self.mass_balance_ds = [lambda: self.empty_vqip()]\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.__init_subclass__","title":"<code>__init_subclass__(**kwargs)</code>","text":"<p>Adds all subclasses to the nodes registry.</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def __init_subclass__(cls, **kwargs):\n    \"\"\"Adds all subclasses to the nodes registry.\"\"\"\n    super().__init_subclass__(**kwargs)\n    if cls.__name__ in NODES_REGISTRY:\n        logging.warning(f\"Overwriting {cls.__name__} in NODES_REGISTRY with {cls}\")\n\n    NODES_REGISTRY[cls.__name__] = cls\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the node.</p> <p>The Node does not have any overwriteable parameters. So if any overrides are passed up to the node, this means that there are unused parameters from the Node subclass, which is flagged.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def apply_overrides(self, overrides: Dict[str, Any] = {}) -&gt; None:\n    \"\"\"Apply overrides to the node.\n\n    The Node does not have any overwriteable parameters. So if any\n    overrides are passed up to the node, this means that there are unused\n    parameters from the Node subclass, which is flagged.\n\n    Args:\n        overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n    \"\"\"\n    # overrides data_input_dict\n    from wsimod.orchestration.model import read_csv\n\n    content = overrides.pop(\"filename\", None)\n    if isinstance(content, str):\n        self.data_input_dict = read_csv(content)\n    elif not content:\n        pass\n    else:\n        raise RuntimeError(\"Not recognised format for data_input_dict\")\n\n    if len(overrides) &gt; 0:\n        print(f\"No override behaviour defined for: {overrides.keys()}\")\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.check_basic","title":"<code>check_basic(direction, vqip=None, of_type=None, tag='default')</code>","text":"<p>Generic function that conveys a pull or push check onwards to connected nodes. It is the default behaviour that treats a node like a junction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>can be either 'pull' or 'push' to send checks to receiving or contributing nodes</p> required <code>vqip</code> <code>dict</code> <p>The VQIP to check. Defaults to None (if pulling this will return available water to pull, if pushing then available capacity to push).</p> <code>None</code> <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>avail</code> <code>dict</code> <p>VQIP responses summed over all requests</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def check_basic(self, direction, vqip=None, of_type=None, tag=\"default\"):\n    \"\"\"Generic function that conveys a pull or push check onwards to connected\n    nodes. It is the default behaviour that treats a node like a junction.\n\n    Args:\n        direction (str): can be either 'pull' or 'push' to send checks to\n            receiving or contributing nodes\n        vqip (dict, optional): The VQIP to check. Defaults to None (if pulling\n            this will return available water to pull, if pushing then available\n            capacity to push).\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        avail (dict): VQIP responses summed over all requests\n    \"\"\"\n    f, arcs = self.get_direction_arcs(direction, of_type)\n\n    # Iterate over arcs, updating total\n    avail = self.empty_vqip()\n    for arc in arcs:\n        avail = self.sum_vqip(avail, getattr(arc, f)(tag=tag))\n\n    if vqip is not None:\n        avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n    return avail\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Empty function intended to be called at the end of every timestep.</p> <p>Subclasses will overwrite this functions.</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Empty function intended to be called at the end of every timestep.\n\n    Subclasses will overwrite this functions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.get_connected","title":"<code>get_connected(direction='pull', of_type=None, tag='default')</code>","text":"<p>Send push/pull checks to all attached arcs in a given direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>The type of check to send to all attached nodes. Can be 'push' or 'pull'. The default is 'pull'.</p> <code>'pull'</code> <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <p>connected (dict) : Dictionary containing keys: 'avail': (float) - total available volume for push/pull 'priority': (float) - total (availability * preference)                     of attached arcs 'allocation': (dict) - contains all attached arcs in specified                 direction and respective (availability * preference)</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; vqip_available_to_pull = my_node.get_direction_arcs()\n&gt;&gt;&gt; vqip_available_to_push = my_node.get_direction_arcs('push')\n&gt;&gt;&gt; avail_reservoir_vqip = my_node.get_direction_arcs('pull',\n                                              of_type = 'Reservoir')\n&gt;&gt;&gt; avail_sewer_push_to_sewers = my_node.get_direction_arcs('push',\n                                                    of_type = 'Sewer',\n                                                    tag = 'Sewer')\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def get_connected(self, direction=\"pull\", of_type=None, tag=\"default\"):\n    \"\"\"Send push/pull checks to all attached arcs in a given direction.\n\n    Args:\n        direction (str, optional): The type of check to send to all attached\n            nodes. Can be 'push' or 'pull'. The default is 'pull'.\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        connected (dict) :\n            Dictionary containing keys:\n            'avail': (float) - total available volume for push/pull\n            'priority': (float) - total (availability * preference)\n                                of attached arcs\n            'allocation': (dict) - contains all attached arcs in specified\n                            direction and respective (availability * preference)\n\n    Examples:\n        &gt;&gt;&gt; vqip_available_to_pull = my_node.get_direction_arcs()\n        &gt;&gt;&gt; vqip_available_to_push = my_node.get_direction_arcs('push')\n        &gt;&gt;&gt; avail_reservoir_vqip = my_node.get_direction_arcs('pull',\n                                                      of_type = 'Reservoir')\n        &gt;&gt;&gt; avail_sewer_push_to_sewers = my_node.get_direction_arcs('push',\n                                                            of_type = 'Sewer',\n                                                            tag = 'Sewer')\n    \"\"\"\n    # Initialise connected dict\n    connected = {\"avail\": 0, \"priority\": 0, \"allocation\": {}, \"capacity\": {}}\n\n    # Get arcs\n    f, arcs = self.get_direction_arcs(direction, of_type)\n\n    # Iterate over arcs, updating connected dict\n    for arc in arcs:\n        avail = getattr(arc, f)(tag=tag)[\"volume\"]\n        if avail &lt; constants.FLOAT_ACCURACY:\n            avail = 0  # Improves convergence\n        connected[\"avail\"] += avail\n        preference = arc.preference\n        connected[\"priority\"] += avail * preference\n        connected[\"allocation\"][arc.name] = avail * preference\n        connected[\"capacity\"][arc.name] = avail\n\n    return connected\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.get_data_input","title":"<code>get_data_input(var)</code>","text":"<p>Read data from data_input_dict. Keys are tuples with the first entry as the variable to read and second entry the time.</p> <p>Parameters:</p> Name Type Description Default <code>var</code> <code>str</code> <p>Name of variable</p> required <p>Returns:</p> Type Description <p>Data read</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def get_data_input(self, var):\n    \"\"\"Read data from data_input_dict. Keys are tuples with the first entry as the\n    variable to read and second entry the time.\n\n    Args:\n        var (str): Name of variable\n\n    Returns:\n        Data read\n    \"\"\"\n    return self.data_input_dict[(var, self.t)]\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.get_direction_arcs","title":"<code>get_direction_arcs(direction, of_type=None)</code>","text":"<p>Identify arcs to/from all attached nodes in a given direction.</p> <p>Parameters:</p> Name Type Description Default <code>direction</code> <code>str</code> <p>can be either 'pull' or 'push' to send checks to receiving or contributing nodes</p> required <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <p>Returns:</p> Name Type Description <code>f</code> <code>str</code> <p>Either 'send_pull_check' or 'send_push_check' depending on direction</p> <code>arcs</code> <code>list</code> <p>List of arc objects</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; arcs_to_push_to = my_node.get_direction_arcs('push')\n&gt;&gt;&gt; arcs_to_pull_from = my_node.get_direction_arcs('pull')\n&gt;&gt;&gt; arcs_from_reservoirs = my_node.get_direction_arcs('pull', of_type =\n    'Reservoir')\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def get_direction_arcs(self, direction, of_type=None):\n    \"\"\"Identify arcs to/from all attached nodes in a given direction.\n\n    Args:\n        direction (str): can be either 'pull' or 'push' to send checks to\n            receiving or contributing nodes\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n\n    Returns:\n        f (str): Either 'send_pull_check' or 'send_push_check' depending on\n            direction\n        arcs (list): List of arc objects\n\n    Raises:\n        Message if no direction is specified\n\n    Examples:\n        &gt;&gt;&gt; arcs_to_push_to = my_node.get_direction_arcs('push')\n        &gt;&gt;&gt; arcs_to_pull_from = my_node.get_direction_arcs('pull')\n        &gt;&gt;&gt; arcs_from_reservoirs = my_node.get_direction_arcs('pull', of_type =\n            'Reservoir')\n    \"\"\"\n    if of_type is None:\n        # Return all arcs\n        if direction == \"pull\":\n            arcs = list(self.in_arcs.values())\n            f = \"send_pull_check\"\n        elif direction == \"push\":\n            arcs = list(self.out_arcs.values())\n            f = \"send_push_check\"\n        else:\n            print(\"No direction\")\n\n    else:\n        if isinstance(of_type, str):\n            of_type = [of_type]\n\n        # Assign arcs/function based on parameters\n        arcs = []\n        if direction == \"pull\":\n            for type_ in of_type:\n                arcs += list(self.in_arcs_type[type_].values())\n            f = \"send_pull_check\"\n        elif direction == \"push\":\n            for type_ in of_type:\n                arcs += list(self.out_arcs_type[type_].values())\n            f = \"send_push_check\"\n        else:\n            print(\"No direction\")\n\n    return f, arcs\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.node_mass_balance","title":"<code>node_mass_balance()</code>","text":"<p>Wrapper for core.py/WSIObj/mass_balance. Tracks change in mass balance.</p> <p>Returns:</p> Name Type Description <code>in_</code> <code>dict</code> <p>A VQIP of the total from mass_balance_in functions</p> <code>ds_</code> <code>dict</code> <p>A VQIP of the total from mass_balance_ds functions</p> <code>out_</code> <code>dict</code> <p>A VQIP of the total from mass_balance_out functions</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node_in, node_out, node_ds = my_node.node_mass_balance()\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def node_mass_balance(self):\n    \"\"\"Wrapper for core.py/WSIObj/mass_balance. Tracks change in mass balance.\n\n    Returns:\n        in_ (dict): A VQIP of the total from mass_balance_in functions\n        ds_ (dict): A VQIP of the total from mass_balance_ds functions\n        out_ (dict): A VQIP of the total from mass_balance_out functions\n\n    Examples:\n        &gt;&gt;&gt; node_in, node_out, node_ds = my_node.node_mass_balance()\n    \"\"\"\n    in_, ds_, out_ = self.mass_balance()\n    return in_, ds_, out_\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_check","title":"<code>pull_check(vqip=None, tag='default')</code>","text":"<p>Receives pull check requests from arcs and passes request to query handler.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>the VQIP pull check (by default, only the 'volume' key is used). Defaults to None, which returns all available water to pull.</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP available from query_handler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; water_available = my_node.pull_check({'volume' : 10})\n&gt;&gt;&gt; total_water_available = my_node.pull_check()\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_check(self, vqip=None, tag=\"default\"):\n    \"\"\"Receives pull check requests from arcs and passes request to query handler.\n\n    Args:\n        vqip (dict, optional): the VQIP pull check (by default, only the\n            'volume' key is used). Defaults to None, which returns all available\n            water to pull.\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): VQIP available from query_handler\n\n    Examples:\n        &gt;&gt;&gt; water_available = my_node.pull_check({'volume' : 10})\n        &gt;&gt;&gt; total_water_available = my_node.pull_check()\n    \"\"\"\n    return self.query_handler(self.pull_check_handler, vqip, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_check_basic","title":"<code>pull_check_basic(vqip=None, of_type=None, tag='default')</code>","text":"<p>Default node check behaviour that treats a node like a junction. Water available to pull is just the water available to pull from upstream connected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>VQIP from handler of amount to pull check (by default, only the 'volume' key is used). Defaults to None (which returns all availalbe water to pull).</p> <code>None</code> <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP check response of upstream nodes</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_check_basic(self, vqip=None, of_type=None, tag=\"default\"):\n    \"\"\"Default node check behaviour that treats a node like a junction. Water\n    available to pull is just the water available to pull from upstream connected\n    nodes.\n\n    Args:\n        vqip (dict, optional): VQIP from handler of amount to pull check\n            (by default, only the 'volume' key is used). Defaults to None (which\n            returns all availalbe water to pull).\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): VQIP check response of upstream nodes\n    \"\"\"\n    return self.check_basic(\"pull\", vqip, of_type, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_check_deny","title":"<code>pull_check_deny(vqip=None)</code>","text":"<p>Responds that no water is available to pull from a check.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of water requested (ignored)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP indicated no water was pulled</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_check_deny(self, vqip=None):\n    \"\"\"Responds that no water is available to pull from a check.\n\n    Args:\n        vqip (dict): A VQIP amount of water requested (ignored)\n\n    Returns:\n        (dict): An empty VQIP indicated no water was pulled\n\n    Raises:\n        Message when called, since it would usually occur if a model is\n        improperly connected\n    \"\"\"\n    print(\"Attempted pull check from deny\")\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_distributed","title":"<code>pull_distributed(vqip, of_type=None, tag='default')</code>","text":"<p>Send pull requests to all (or specified by type) nodes connecting to self. Iterate until request is met or maximum iterations are hit. Streamlines if only one in_arc exists.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>Total amount to pull (by default, only the 'volume' key is used)</p> required <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>pulled</code> <code>dict</code> <p>VQIP of combined pulled water</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_distributed(self, vqip, of_type=None, tag=\"default\"):\n    \"\"\"Send pull requests to all (or specified by type) nodes connecting to self.\n    Iterate until request is met or maximum iterations are hit. Streamlines if only\n    one in_arc exists.\n\n    Args:\n        vqip (dict): Total amount to pull (by default, only the\n            'volume' key is used)\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        pulled (dict): VQIP of combined pulled water\n    \"\"\"\n    if len(self.in_arcs) == 1:\n        # If only one in_arc, just pull from that\n        if of_type is None:\n            pulled = next(iter(self.in_arcs.values())).send_pull_request(\n                vqip, tag=tag\n            )\n        elif any(\n            [x in of_type for x, y in self.in_arcs_type.items() if len(y) &gt; 0]\n        ):\n            pulled = next(iter(self.in_arcs.values())).send_pull_request(\n                vqip, tag=tag\n            )\n        else:\n            # No viable out arcs\n            pulled = self.empty_vqip()\n    else:\n        # Pull in proportion from connected by priority\n\n        # Initialise pulled, deficit, connected, iter_\n        pulled = self.empty_vqip()\n        deficit = vqip[\"volume\"]\n        connected = self.get_connected(direction=\"pull\", of_type=of_type, tag=tag)\n        iter_ = 0\n\n        # Iterate over sending nodes until deficit met\n        while (\n            (deficit &gt; constants.FLOAT_ACCURACY)\n            &amp; (connected[\"avail\"] &gt; constants.FLOAT_ACCURACY)\n        ) &amp; (iter_ &lt; constants.MAXITER):\n            # Pull from connected\n            for key, allocation in connected[\"allocation\"].items():\n                received = self.in_arcs[key].send_pull_request(\n                    {\"volume\": deficit * allocation / connected[\"priority\"]},\n                    tag=tag,\n                )\n                pulled = self.sum_vqip(pulled, received)\n\n            # Update deficit, connected and iter_\n            deficit = vqip[\"volume\"] - pulled[\"volume\"]\n            connected = self.get_connected(\n                direction=\"pull\", of_type=of_type, tag=tag\n            )\n            iter_ += 1\n\n        if iter_ == constants.MAXITER:\n            print(\"Maxiter reached in {0} at {1}\".format(self.name, self.t))\n    return pulled\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_set","title":"<code>pull_set(vqip, tag='default')</code>","text":"<p>Receives pull set requests from arcs and passes request to query handler.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>the VQIP pull request (by default, only the 'volume' key is needed).</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP received from query_handler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; water_received = my_node.pull_set({'volume' : 10})\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_set(self, vqip, tag=\"default\"):\n    \"\"\"Receives pull set requests from arcs and passes request to query handler.\n\n    Args:\n        vqip (dict): the VQIP pull request (by default, only the 'volume' key is\n            needed).\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): VQIP received from query_handler\n\n    Examples:\n        &gt;&gt;&gt; water_received = my_node.pull_set({'volume' : 10})\n    \"\"\"\n    return self.query_handler(self.pull_set_handler, vqip, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.pull_set_deny","title":"<code>pull_set_deny(vqip)</code>","text":"<p>Responds that no water is available to pull from a request.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of water requested (ignored)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP indicated no water was pulled</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def pull_set_deny(self, vqip):\n    \"\"\"Responds that no water is available to pull from a request.\n\n    Args:\n        vqip (dict): A VQIP amount of water requested (ignored)\n\n    Returns:\n        (dict): An empty VQIP indicated no water was pulled\n\n    Raises:\n        Message when called, since it would usually occur if a model is\n        improperly connected\n    \"\"\"\n    print(\"Attempted pull set from deny\")\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_check","title":"<code>push_check(vqip=None, tag='default')</code>","text":"<p>Receives push check requests from arcs and passes request to query handler.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>the VQIP push check. Defaults to None, which returns all available capacity to push</p> <code>None</code> <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP available to push from query_handler</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; total_available_push_capacity = my_node.push_check()\n&gt;&gt;&gt; available_push_capacity = my_node.push_check(wastewater_vqip)\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_check(self, vqip=None, tag=\"default\"):\n    \"\"\"Receives push check requests from arcs and passes request to query handler.\n\n    Args:\n        vqip (dict, optional): the VQIP push check. Defaults to None, which\n            returns all available capacity to push\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'\n\n    Returns:\n        (dict): VQIP available to push from query_handler\n\n    Examples:\n        &gt;&gt;&gt; total_available_push_capacity = my_node.push_check()\n        &gt;&gt;&gt; available_push_capacity = my_node.push_check(wastewater_vqip)\n    \"\"\"\n    return self.query_handler(self.push_check_handler, vqip, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_check_accept","title":"<code>push_check_accept(vqip=None)</code>","text":"<p>Push check function that accepts all water.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that has been pushed (ignored)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP or an unbounded capacity, indicating all water can be received</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_check_accept(self, vqip=None):\n    \"\"\"Push check function that accepts all water.\n\n    Args:\n        vqip (dict, optional): A VQIP that has been pushed (ignored)\n\n    Returns:\n        (dict): VQIP or an unbounded capacity, indicating all water can be received\n    \"\"\"\n    if not vqip:\n        vqip = self.empty_vqip()\n        vqip[\"volume\"] = constants.UNBOUNDED_CAPACITY\n    return vqip\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_check_basic","title":"<code>push_check_basic(vqip=None, of_type=None, tag='default')</code>","text":"<p>Default node check behaviour that treats a node like a junction. Water available to push is just the water available to push to downstream connected nodes.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>VQIP from handler of amount to push check. Defaults to None (which returns all available capacity to push).</p> <code>None</code> <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP check response of downstream nodes</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_check_basic(self, vqip=None, of_type=None, tag=\"default\"):\n    \"\"\"Default node check behaviour that treats a node like a junction. Water\n    available to push is just the water available to push to downstream connected\n    nodes.\n\n    Args:\n        vqip (dict, optional): VQIP from handler of amount to push check.\n            Defaults to None (which returns all available capacity to push).\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): VQIP check response of downstream nodes\n    \"\"\"\n    return self.check_basic(\"push\", vqip, of_type, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_check_deny","title":"<code>push_check_deny(vqip=None)</code>","text":"<p>Responds that no water is available to push in a check.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of water to push check (ignored)</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP indicated no capacity for pushes exists</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_check_deny(self, vqip=None):\n    \"\"\"Responds that no water is available to push in a check.\n\n    Args:\n        vqip (dict): A VQIP amount of water to push check (ignored)\n\n    Returns:\n        (dict): An empty VQIP indicated no capacity for pushes exists\n\n    Raises:\n        Message when called, since it would usually occur if a model is\n        improperly connected\n    \"\"\"\n    print(\"Attempted push check to deny\")\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_distributed","title":"<code>push_distributed(vqip, of_type=None, tag='default')</code>","text":"<p>Send push requests to all (or specified by type) nodes connecting to self. Iterate until request is met or maximum iterations are hit. Streamlines if only one in_arc exists.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>Total amount to push</p> required <code>of_type (str or list) </code> <p>optional, can be specified to send checks only to nodes of a given type (must be a subclass in nodes.py)</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Name Type Description <code>not_pushed_</code> <code>dict</code> <p>VQIP of water that cannot be pushed</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_distributed(self, vqip, of_type=None, tag=\"default\"):\n    \"\"\"Send push requests to all (or specified by type) nodes connecting to self.\n    Iterate until request is met or maximum iterations are hit. Streamlines if only\n    one in_arc exists.\n\n    Args:\n        vqip (dict): Total amount to push\n        of_type (str or list) : optional, can be specified to send checks only\n            to nodes of a given type (must be a subclass in nodes.py)\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        not_pushed_ (dict): VQIP of water that cannot be pushed\n    \"\"\"\n    if len(self.out_arcs) == 1:\n        # If only one out_arc, just send the water down that\n        if of_type is None:\n            not_pushed_ = next(iter(self.out_arcs.values())).send_push_request(\n                vqip, tag=tag\n            )\n        elif any(\n            [x in of_type for x, y in self.out_arcs_type.items() if len(y) &gt; 0]\n        ):\n            not_pushed_ = next(iter(self.out_arcs.values())).send_push_request(\n                vqip, tag=tag\n            )\n        else:\n            # No viable out arcs\n            not_pushed_ = vqip\n    else:\n        # Push in proportion to connected by priority\n        # Initialise pushed, deficit, connected, iter_\n        not_pushed = vqip[\"volume\"]\n        not_pushed_ = self.copy_vqip(vqip)\n        connected = self.get_connected(direction=\"push\", of_type=of_type, tag=tag)\n        iter_ = 0\n        if not_pushed &gt; connected[\"avail\"]:\n            # If more water than can be pushed, ignore preference and allocate all\n            #   available based on capacity\n            connected[\"priority\"] = connected[\"avail\"]\n            connected[\"allocation\"] = connected[\"capacity\"]\n\n        # Iterate over receiving nodes until sent\n        while (\n            (not_pushed &gt; constants.FLOAT_ACCURACY)\n            &amp; (connected[\"avail\"] &gt; constants.FLOAT_ACCURACY)\n            &amp; (iter_ &lt; constants.MAXITER)\n        ):\n            # Push to connected\n            amount_to_push = min(connected[\"avail\"], not_pushed)\n\n            for key, allocation in connected[\"allocation\"].items():\n                to_send = amount_to_push * allocation / connected[\"priority\"]\n                to_send = self.v_change_vqip(not_pushed_, to_send)\n                reply = self.out_arcs[key].send_push_request(to_send, tag=tag)\n\n                sent = self.extract_vqip(to_send, reply)\n                not_pushed_ = self.extract_vqip(not_pushed_, sent)\n\n            not_pushed = not_pushed_[\"volume\"]\n            connected = self.get_connected(\n                direction=\"push\", of_type=of_type, tag=tag\n            )\n            iter_ += 1\n\n        if iter_ == constants.MAXITER:\n            print(\"Maxiter reached in {0} at {1}\".format(self.name, self.t))\n\n    return not_pushed_\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_set","title":"<code>push_set(vqip, tag='default')</code>","text":"<p>Receives push set requests from arcs and passes request to query handler.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>_type_</code> <p>the VQIP push request</p> required <code>tag</code> <code>str</code> <p>optional message to direct query_handler which pull function to call. Defaults to 'default'.</p> <code>'default'</code> <p>Returns:</p> Type Description <code>dict</code> <p>VQIP not received from query_handler</p> <p>Examples:</p> <p>water_not_pushed = my_node.push_set(wastewater_vqip)</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_set(self, vqip, tag=\"default\"):\n    \"\"\"Receives push set requests from arcs and passes request to query handler.\n\n    Args:\n        vqip (_type_): the VQIP push request\n        tag (str, optional): optional message to direct query_handler which pull\n            function to call. Defaults to 'default'.\n\n    Returns:\n        (dict): VQIP not received from query_handler\n\n    Examples:\n        water_not_pushed = my_node.push_set(wastewater_vqip)\n    \"\"\"\n    return self.query_handler(self.push_set_handler, vqip, tag)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.push_set_deny","title":"<code>push_set_deny(vqip)</code>","text":"<p>Responds that no water is available to push in a request.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of water to push</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>Returns the request indicating no water was pushed</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def push_set_deny(self, vqip):\n    \"\"\"Responds that no water is available to push in a request.\n\n    Args:\n        vqip (dict): A VQIP amount of water to push\n\n    Returns:\n        vqip (dict): Returns the request indicating no water was pushed\n\n    Raises:\n        Message when called, since it would usually occur if a model is\n        improperly connected\n    \"\"\"\n    print(\"Attempted push set to deny\")\n    return vqip\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.query_handler","title":"<code>query_handler(handler, ip, tag)</code>","text":"<p>Sends all push/pull requests/checks using the handler (i.e., ensures the correct function is used that lines up with 'tag').</p> <p>Parameters:</p> Name Type Description Default <code>handler</code> <code>dict</code> <p>contains all push/pull requests for various tags</p> required <code>ip</code> <code>vqip</code> <p>the vqip request</p> required <code>tag</code> <code>str</code> <p>describes what type of push/pull request should be called</p> required <p>Returns:</p> Type Description <code>dict</code> <p>the VQIP reply from push/pull request</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def query_handler(self, handler, ip, tag):\n    \"\"\"Sends all push/pull requests/checks using the handler (i.e., ensures the\n    correct function is used that lines up with 'tag').\n\n    Args:\n        handler (dict): contains all push/pull requests for various tags\n        ip (vqip): the vqip request\n        tag (str): describes what type of push/pull request should be called\n\n    Returns:\n        (dict): the VQIP reply from push/pull request\n\n    Raises:\n        Message if no functions are defined for tag and if request/check\n        function fails\n    \"\"\"\n    try:\n        return handler[tag](ip)\n    except Exception:\n        if tag not in handler.keys():\n            print(\"No functions defined for \" + tag)\n            return handler[tag](ip)\n        else:\n            print(\"Some other error\")\n            return handler[tag](ip)\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.reinit","title":"<code>reinit()</code>","text":"<p>Empty function to be written if reinitialisation capability is added.</p> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def reinit(self):\n    \"\"\"Empty function to be written if reinitialisation capability is added.\"\"\"\n    pass\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.total_in","title":"<code>total_in()</code>","text":"<p>Sum flow and pollutant amounts entering a node via in_arcs.</p> <p>Returns:</p> Name Type Description <code>in_</code> <code>dict</code> <p>Summed VQIP of in_arcs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node_inflow = my_node.total_in()\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def total_in(self):\n    \"\"\"Sum flow and pollutant amounts entering a node via in_arcs.\n\n    Returns:\n        in_ (dict): Summed VQIP of in_arcs\n\n    Examples:\n        &gt;&gt;&gt; node_inflow = my_node.total_in()\n    \"\"\"\n    in_ = self.empty_vqip()\n    for arc in self.in_arcs.values():\n        in_ = self.sum_vqip(in_, arc.vqip_out)\n\n    return in_\n</code></pre>"},{"location":"reference-nodes/#wsimod.nodes.nodes.Node.total_out","title":"<code>total_out()</code>","text":"<p>Sum flow and pollutant amounts leaving a node via out_arcs.</p> <p>Returns:</p> Name Type Description <code>out_</code> <code>dict</code> <p>Summed VQIP of out_arcs</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; node_outflow = my_node.total_out()\n</code></pre> Source code in <code>wsimod/nodes/nodes.py</code> <pre><code>def total_out(self):\n    \"\"\"Sum flow and pollutant amounts leaving a node via out_arcs.\n\n    Returns:\n        out_ (dict): Summed VQIP of out_arcs\n\n    Examples:\n        &gt;&gt;&gt; node_outflow = my_node.total_out()\n    \"\"\"\n    out_ = self.empty_vqip()\n    for arc in self.out_arcs.values():\n        out_ = self.sum_vqip(out_, arc.vqip_in)\n\n    return out_\n</code></pre>"},{"location":"reference-other/","title":"API Reference - Other Components","text":"<p>This section of the documentation provides a reference for the API of the  nodes.catchment, nodes.demand, nodes.distribution, and nodes.waste modules.</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson</p> <p>Converted to totals on 2022-05-03</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson</p> <p>Converted to totals BD 2022-05-03</p> <p>Created on Sun Aug 14 16:27:14 2022.</p> <p>@author: bdobson</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson</p>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment","title":"<code>Catchment</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>class Catchment(Node):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name,\n        data_input_dict={},\n    ):\n        \"\"\"Node that reads input data to create VQIPs that are pushed downstream and\n        tracks abstractions made from the node, adjusting pushes accordingly.\n\n        Args:\n            name (str): Node name\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node. Keys are tuples where first value is the name of the\n                variable to read from the dict and the second value is the time.\n                Defaults to {}.\n\n        Functions intended to call in orchestration:\n            route\n\n        Key assumptions:\n            - Flows from `Catchment` nodes are simply read from data, thus\n                assumed to be unresponsive to wider water cycle changes.\n\n        Input data and parameter requirements:\n            - Flow data in the `data_input_dict` at the model timestep.\n                _Units_: cubic metres/timestep\n            - Values for each variable defined in `constants.POLLUTANTS` also\n                stored in `data_input_dict` at the model timestep.\n                _Units_: kg/m3/timestep (additive pollutants)\n        \"\"\"\n        # Update args\n        super().__init__(name)\n        self.data_input_dict = data_input_dict\n\n        # Update handlers\n        self.pull_set_handler[\"default\"] = self.pull_set_abstraction\n        self.pull_check_handler[\"default\"] = self.pull_check_abstraction\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_set_deny\n        self.unrouted_water = self.empty_vqip()\n        # Mass balance\n        self.mass_balance_in.append(lambda: self.get_flow())\n        self.mass_balance_out.append(lambda: self.unrouted_water)\n        self.end_timestep = self.end_timestep_\n\n    def get_flow(self):\n        \"\"\"Read volume data, read pollutant data, convert additibve pollutants from\n        kg/m3 to kg.\n\n        Returns:\n            vqip (dict): Return read data as a VQIP\n        \"\"\"\n        # TODO (if used) - note that if flow is &lt; float accuracy then it won't\n        # get pushed, and the pollutants will 'disappear', causing a mass balance error\n        vqip = {\"volume\": self.data_input_dict[(\"flow\", self.t)]}\n        for pollutant in constants.POLLUTANTS:\n            vqip[pollutant] = self.data_input_dict[(pollutant, self.t)]\n        for pollutant in constants.ADDITIVE_POLLUTANTS:\n            vqip[pollutant] *= vqip[\"volume\"]\n\n        return vqip\n\n    def route(self):\n        \"\"\"Send any water that has not already been abstracted downstream.\"\"\"\n        # Get amount of water\n        avail = self.get_avail()\n        # Route excess flow onwards\n        reply = self.push_distributed(avail, of_type=[\"Node\", \"River\", \"Waste\"])\n        self.unrouted_water = self.sum_vqip(self.unrouted_water, reply)\n        if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            pass\n            # print('Catchment unable to route')\n\n    def get_avail(self):\n        \"\"\"Water available for abstraction (Read data and subtract pre-existing\n        abstractions).\n\n        Returns:\n            avail (dict): A VQIP of water available for abstraction\n        \"\"\"\n        # Get available vqip\n        avail = self.get_flow()\n\n        # Remove abstractions already made\n        for name, arc in self.out_arcs.items():\n            avail = self.v_change_vqip(avail, avail[\"volume\"] - arc.vqip_in[\"volume\"])\n\n        return avail\n\n    def pull_check_abstraction(self, vqip=None):\n        \"\"\"Check wrapper for get_avail that updates response if VQIP is given.\n\n        Args:\n            vqip (dict, optional): A VQIP that is compared with get_avail and the\n                minimum is returned. Only the 'volume' key is used. Defaults to None.\n\n        Returns:\n            avail (dict): A VQIP of water available for abstraction\n        \"\"\"\n        # Respond to abstraction check request\n        avail = self.get_avail()\n\n        if vqip:\n            avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n        return avail\n\n    def pull_set_abstraction(self, vqip):\n        \"\"\"Request set wrapper for get_avail where VQIP is specified.\n\n        Args:\n            vqip (dict): A VQIP of water to pull. Only the 'volume' key is used.\n\n        Returns:\n            avail (dict): A VQIP of water abstracted\n        \"\"\"\n        # Respond to abstraction set request\n        avail = self.get_avail()\n        avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n        return avail\n\n    def end_timestep_(self):\n        \"\"\"Reset unrouted water.\"\"\"\n        self.unrouted_water = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.__init__","title":"<code>__init__(name, data_input_dict={})</code>","text":"<p>Node that reads input data to create VQIPs that are pushed downstream and tracks abstractions made from the node, adjusting pushes accordingly.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Node name</p> required <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node. Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Defaults to {}.</p> <code>{}</code> Functions intended to call in orchestration <p>route</p> Key assumptions <ul> <li>Flows from <code>Catchment</code> nodes are simply read from data, thus     assumed to be unresponsive to wider water cycle changes.</li> </ul> Input data and parameter requirements <ul> <li>Flow data in the <code>data_input_dict</code> at the model timestep.     Units: cubic metres/timestep</li> <li>Values for each variable defined in <code>constants.POLLUTANTS</code> also     stored in <code>data_input_dict</code> at the model timestep.     Units: kg/m3/timestep (additive pollutants)</li> </ul> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def __init__(\n    self,\n    name,\n    data_input_dict={},\n):\n    \"\"\"Node that reads input data to create VQIPs that are pushed downstream and\n    tracks abstractions made from the node, adjusting pushes accordingly.\n\n    Args:\n        name (str): Node name\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node. Keys are tuples where first value is the name of the\n            variable to read from the dict and the second value is the time.\n            Defaults to {}.\n\n    Functions intended to call in orchestration:\n        route\n\n    Key assumptions:\n        - Flows from `Catchment` nodes are simply read from data, thus\n            assumed to be unresponsive to wider water cycle changes.\n\n    Input data and parameter requirements:\n        - Flow data in the `data_input_dict` at the model timestep.\n            _Units_: cubic metres/timestep\n        - Values for each variable defined in `constants.POLLUTANTS` also\n            stored in `data_input_dict` at the model timestep.\n            _Units_: kg/m3/timestep (additive pollutants)\n    \"\"\"\n    # Update args\n    super().__init__(name)\n    self.data_input_dict = data_input_dict\n\n    # Update handlers\n    self.pull_set_handler[\"default\"] = self.pull_set_abstraction\n    self.pull_check_handler[\"default\"] = self.pull_check_abstraction\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_set_deny\n    self.unrouted_water = self.empty_vqip()\n    # Mass balance\n    self.mass_balance_in.append(lambda: self.get_flow())\n    self.mass_balance_out.append(lambda: self.unrouted_water)\n    self.end_timestep = self.end_timestep_\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.end_timestep_","title":"<code>end_timestep_()</code>","text":"<p>Reset unrouted water.</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def end_timestep_(self):\n    \"\"\"Reset unrouted water.\"\"\"\n    self.unrouted_water = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.get_avail","title":"<code>get_avail()</code>","text":"<p>Water available for abstraction (Read data and subtract pre-existing abstractions).</p> <p>Returns:</p> Name Type Description <code>avail</code> <code>dict</code> <p>A VQIP of water available for abstraction</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def get_avail(self):\n    \"\"\"Water available for abstraction (Read data and subtract pre-existing\n    abstractions).\n\n    Returns:\n        avail (dict): A VQIP of water available for abstraction\n    \"\"\"\n    # Get available vqip\n    avail = self.get_flow()\n\n    # Remove abstractions already made\n    for name, arc in self.out_arcs.items():\n        avail = self.v_change_vqip(avail, avail[\"volume\"] - arc.vqip_in[\"volume\"])\n\n    return avail\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.get_flow","title":"<code>get_flow()</code>","text":"<p>Read volume data, read pollutant data, convert additibve pollutants from kg/m3 to kg.</p> <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>Return read data as a VQIP</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def get_flow(self):\n    \"\"\"Read volume data, read pollutant data, convert additibve pollutants from\n    kg/m3 to kg.\n\n    Returns:\n        vqip (dict): Return read data as a VQIP\n    \"\"\"\n    # TODO (if used) - note that if flow is &lt; float accuracy then it won't\n    # get pushed, and the pollutants will 'disappear', causing a mass balance error\n    vqip = {\"volume\": self.data_input_dict[(\"flow\", self.t)]}\n    for pollutant in constants.POLLUTANTS:\n        vqip[pollutant] = self.data_input_dict[(pollutant, self.t)]\n    for pollutant in constants.ADDITIVE_POLLUTANTS:\n        vqip[pollutant] *= vqip[\"volume\"]\n\n    return vqip\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.pull_check_abstraction","title":"<code>pull_check_abstraction(vqip=None)</code>","text":"<p>Check wrapper for get_avail that updates response if VQIP is given.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that is compared with get_avail and the minimum is returned. Only the 'volume' key is used. Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>avail</code> <code>dict</code> <p>A VQIP of water available for abstraction</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def pull_check_abstraction(self, vqip=None):\n    \"\"\"Check wrapper for get_avail that updates response if VQIP is given.\n\n    Args:\n        vqip (dict, optional): A VQIP that is compared with get_avail and the\n            minimum is returned. Only the 'volume' key is used. Defaults to None.\n\n    Returns:\n        avail (dict): A VQIP of water available for abstraction\n    \"\"\"\n    # Respond to abstraction check request\n    avail = self.get_avail()\n\n    if vqip:\n        avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n    return avail\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.pull_set_abstraction","title":"<code>pull_set_abstraction(vqip)</code>","text":"<p>Request set wrapper for get_avail where VQIP is specified.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP of water to pull. Only the 'volume' key is used.</p> required <p>Returns:</p> Name Type Description <code>avail</code> <code>dict</code> <p>A VQIP of water abstracted</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def pull_set_abstraction(self, vqip):\n    \"\"\"Request set wrapper for get_avail where VQIP is specified.\n\n    Args:\n        vqip (dict): A VQIP of water to pull. Only the 'volume' key is used.\n\n    Returns:\n        avail (dict): A VQIP of water abstracted\n    \"\"\"\n    # Respond to abstraction set request\n    avail = self.get_avail()\n    avail = self.v_change_vqip(avail, min(avail[\"volume\"], vqip[\"volume\"]))\n\n    return avail\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.catchment.Catchment.route","title":"<code>route()</code>","text":"<p>Send any water that has not already been abstracted downstream.</p> Source code in <code>wsimod/nodes/catchment.py</code> <pre><code>def route(self):\n    \"\"\"Send any water that has not already been abstracted downstream.\"\"\"\n    # Get amount of water\n    avail = self.get_avail()\n    # Route excess flow onwards\n    reply = self.push_distributed(avail, of_type=[\"Node\", \"River\", \"Waste\"])\n    self.unrouted_water = self.sum_vqip(self.unrouted_water, reply)\n    if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        pass\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand","title":"<code>Demand</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>class Demand(Node):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name,\n        constant_demand=0,\n        pollutant_load={},\n        data_input_dict={},\n    ):\n        \"\"\"Node that generates and moves water. Currently only subclass\n        ResidentialDemand is in use.\n\n        Args:\n            name (str): node name constant_demand (float, optional): A constant portion\n            of demand if no subclass\n                is used. Defaults to 0.\n            pollutant_load (dict, optional): Pollutant mass per timestep of\n            constant_demand.\n                Defaults to 0.\n            data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n                the node (temperature). Keys are tuples where first value is the name of\n                the variable to read from the dict and the second value is the time.\n                Defaults to {}\n\n        Functions intended to call in orchestration:\n            create_demand\n        \"\"\"\n        # TODO should temperature be defined in pollutant dict? TODO a lot of this\n        # should be moved to ResidentialDemand Assign parameters\n        self.constant_demand = constant_demand\n        self.pollutant_load = pollutant_load\n        # Update args\n        super().__init__(name, data_input_dict=data_input_dict)\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_check_deny\n        self.pull_set_handler[\"default\"] = self.pull_set_deny\n        self.pull_check_handler[\"default\"] = self.pull_check_deny\n\n        # Initialise states\n        self.total_demand = self.empty_vqip()\n        self.total_backup = self.empty_vqip()  # ew\n        self.total_received = self.empty_vqip()\n\n        # Mass balance Because we assume demand is always satisfied received water\n        # 'disappears' for mass balance and consumed water 'appears' (this makes)\n        # introduction of pollutants easy\n        self.mass_balance_in.append(lambda: self.total_demand)\n        self.mass_balance_out.append(lambda: self.total_backup)\n        self.mass_balance_out.append(lambda: self.total_received)\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}):\n        \"\"\"Apply overrides to the sewer.\n\n        Enables a user to override any of the following parameters:\n        constant_demand, pollutant_load.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.constant_demand = overrides.pop(\"constant_demand\", self.constant_demand)\n        self.pollutant_load.update(overrides.pop(\"pollutant_load\", {}))\n        super().apply_overrides(overrides)\n\n    def create_demand(self):\n        \"\"\"Function to call get_demand, which should return a dict with keys that match\n        the keys in directions.\n\n        A dict that determines how to push_distributed the generated wastewater/garden\n        irrigation. Water is drawn from attached nodes.\n        \"\"\"\n        demand = self.get_demand()\n        total_requested = 0\n        for dem in demand.values():\n            total_requested += dem[\"volume\"]\n\n        self.total_received = self.pull_distributed({\"volume\": total_requested})\n\n        # TODO Currently just assume all water is received and then pushed onwards\n        if (total_requested - self.total_received[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n            print(\n                \"demand deficit of {2} at {0} on {1}\".format(\n                    self.name, self.t, total_requested - self.total_received[\"volume\"]\n                )\n            )\n\n        directions = {\n            \"garden\": {\"tag\": (\"Demand\", \"Garden\"), \"of_type\": \"Land\"},\n            \"house\": {\"tag\": \"Demand\", \"of_type\": \"Sewer\"},\n            \"default\": {\"tag\": \"default\", \"of_type\": None},\n        }\n\n        # Send water where it needs to go\n        for key, item in demand.items():\n            # Distribute\n            remaining = self.push_distributed(\n                item, of_type=directions[key][\"of_type\"], tag=directions[key][\"tag\"]\n            )\n            self.total_backup = self.sum_vqip(self.total_backup, remaining)\n            if remaining[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n                print(\"Demand not able to push\")\n\n        # Update for mass balance\n        for dem in demand.values():\n            self.total_demand = self.sum_vqip(self.total_demand, dem)\n\n    def get_demand(self):\n        \"\"\"Holder function to enable constant demand generation.\n\n        Returns:\n            (dict): A VQIP that will contain constant demand\n        \"\"\"\n        # TODO read/gen demand\n        pol = self.v_change_vqip(self.empty_vqip(), self.constant_demand)\n        for key, item in self.pollutant_load.items():\n            pol[key] = item\n        return {\"default\": pol}\n\n    def end_timestep(self):\n        \"\"\"Reset state variable trackers.\"\"\"\n        self.total_demand = self.empty_vqip()\n        self.total_backup = self.empty_vqip()\n        self.total_received = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand.__init__","title":"<code>__init__(name, constant_demand=0, pollutant_load={}, data_input_dict={})</code>","text":"<p>Node that generates and moves water. Currently only subclass ResidentialDemand is in use.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>node name constant_demand (float, optional): A constant portion</p> required <code>pollutant_load</code> <code>dict</code> <p>Pollutant mass per timestep of</p> <code>{}</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (temperature). Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Defaults to {}</p> <code>{}</code> Functions intended to call in orchestration <p>create_demand</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def __init__(\n    self,\n    name,\n    constant_demand=0,\n    pollutant_load={},\n    data_input_dict={},\n):\n    \"\"\"Node that generates and moves water. Currently only subclass\n    ResidentialDemand is in use.\n\n    Args:\n        name (str): node name constant_demand (float, optional): A constant portion\n        of demand if no subclass\n            is used. Defaults to 0.\n        pollutant_load (dict, optional): Pollutant mass per timestep of\n        constant_demand.\n            Defaults to 0.\n        data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n            the node (temperature). Keys are tuples where first value is the name of\n            the variable to read from the dict and the second value is the time.\n            Defaults to {}\n\n    Functions intended to call in orchestration:\n        create_demand\n    \"\"\"\n    # TODO should temperature be defined in pollutant dict? TODO a lot of this\n    # should be moved to ResidentialDemand Assign parameters\n    self.constant_demand = constant_demand\n    self.pollutant_load = pollutant_load\n    # Update args\n    super().__init__(name, data_input_dict=data_input_dict)\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_check_deny\n    self.pull_set_handler[\"default\"] = self.pull_set_deny\n    self.pull_check_handler[\"default\"] = self.pull_check_deny\n\n    # Initialise states\n    self.total_demand = self.empty_vqip()\n    self.total_backup = self.empty_vqip()  # ew\n    self.total_received = self.empty_vqip()\n\n    # Mass balance Because we assume demand is always satisfied received water\n    # 'disappears' for mass balance and consumed water 'appears' (this makes)\n    # introduction of pollutants easy\n    self.mass_balance_in.append(lambda: self.total_demand)\n    self.mass_balance_out.append(lambda: self.total_backup)\n    self.mass_balance_out.append(lambda: self.total_received)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the sewer.</p> <p>Enables a user to override any of the following parameters: constant_demand, pollutant_load.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def apply_overrides(self, overrides: Dict[str, Any] = {}):\n    \"\"\"Apply overrides to the sewer.\n\n    Enables a user to override any of the following parameters:\n    constant_demand, pollutant_load.\n\n    Args:\n        overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n    \"\"\"\n    self.constant_demand = overrides.pop(\"constant_demand\", self.constant_demand)\n    self.pollutant_load.update(overrides.pop(\"pollutant_load\", {}))\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand.create_demand","title":"<code>create_demand()</code>","text":"<p>Function to call get_demand, which should return a dict with keys that match the keys in directions.</p> <p>A dict that determines how to push_distributed the generated wastewater/garden irrigation. Water is drawn from attached nodes.</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def create_demand(self):\n    \"\"\"Function to call get_demand, which should return a dict with keys that match\n    the keys in directions.\n\n    A dict that determines how to push_distributed the generated wastewater/garden\n    irrigation. Water is drawn from attached nodes.\n    \"\"\"\n    demand = self.get_demand()\n    total_requested = 0\n    for dem in demand.values():\n        total_requested += dem[\"volume\"]\n\n    self.total_received = self.pull_distributed({\"volume\": total_requested})\n\n    # TODO Currently just assume all water is received and then pushed onwards\n    if (total_requested - self.total_received[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n        print(\n            \"demand deficit of {2} at {0} on {1}\".format(\n                self.name, self.t, total_requested - self.total_received[\"volume\"]\n            )\n        )\n\n    directions = {\n        \"garden\": {\"tag\": (\"Demand\", \"Garden\"), \"of_type\": \"Land\"},\n        \"house\": {\"tag\": \"Demand\", \"of_type\": \"Sewer\"},\n        \"default\": {\"tag\": \"default\", \"of_type\": None},\n    }\n\n    # Send water where it needs to go\n    for key, item in demand.items():\n        # Distribute\n        remaining = self.push_distributed(\n            item, of_type=directions[key][\"of_type\"], tag=directions[key][\"tag\"]\n        )\n        self.total_backup = self.sum_vqip(self.total_backup, remaining)\n        if remaining[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"Demand not able to push\")\n\n    # Update for mass balance\n    for dem in demand.values():\n        self.total_demand = self.sum_vqip(self.total_demand, dem)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Reset state variable trackers.</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Reset state variable trackers.\"\"\"\n    self.total_demand = self.empty_vqip()\n    self.total_backup = self.empty_vqip()\n    self.total_received = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.Demand.get_demand","title":"<code>get_demand()</code>","text":"<p>Holder function to enable constant demand generation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP that will contain constant demand</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def get_demand(self):\n    \"\"\"Holder function to enable constant demand generation.\n\n    Returns:\n        (dict): A VQIP that will contain constant demand\n    \"\"\"\n    # TODO read/gen demand\n    pol = self.v_change_vqip(self.empty_vqip(), self.constant_demand)\n    for key, item in self.pollutant_load.items():\n        pol[key] = item\n    return {\"default\": pol}\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.NonResidentialDemand","title":"<code>NonResidentialDemand</code>","text":"<p>               Bases: <code>Demand</code></p> <p>Holder class to enable non-residential demand generation.</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>class NonResidentialDemand(Demand):\n    \"\"\"Holder class to enable non-residential demand generation.\"\"\"\n\n    def get_demand(self):\n        \"\"\"Holder function.\n\n        Returns:\n            (dict): A dict of VQIPs, where the keys match with directions\n                in Demand/create_demand\n        \"\"\"\n        return {\"house\": self.get_demand()}\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.NonResidentialDemand.get_demand","title":"<code>get_demand()</code>","text":"<p>Holder function.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict of VQIPs, where the keys match with directions in Demand/create_demand</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def get_demand(self):\n    \"\"\"Holder function.\n\n    Returns:\n        (dict): A dict of VQIPs, where the keys match with directions\n            in Demand/create_demand\n    \"\"\"\n    return {\"house\": self.get_demand()}\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand","title":"<code>ResidentialDemand</code>","text":"<p>               Bases: <code>Demand</code></p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>class ResidentialDemand(Demand):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        population=1,\n        pollutant_load={},\n        per_capita=0.12,\n        gardening_efficiency=0.6 * 0.7,  # Watering efficiency by irrigated area\n        data_input_dict={},  # For temperature\n        constant_temp=30,\n        constant_weighting=0.2,\n        **kwargs,\n    ):\n        \"\"\"Subclass of demand with functions to handle internal and external water use.\n\n        Args:\n            population (float, optional): population of node. Defaults to 1. per_capita\n            (float, optional): Volume per person per timestep of water\n                used. Defaults to 0.12.\n            pollutant_load (dict, optional): Mass per person per timestep of\n                different pollutants generated. Defaults to {}.\n            gardening_efficiency (float, optional): Value between 0 and 1 that\n                translates irrigation demand from GardenSurface into water requested\n                from the distribution network. Should account for percent of garden that\n                is irrigated and the efficacy of people in meeting their garden water\n                demand. Defaults to 0.6*0.7.\n            data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n                the node (temperature). Keys are tuples where first value is the name of\n                the variable to read from the dict and the second value is the time.\n                Defaults to {}\n            constant_temp (float, optional): A constant temperature associated with\n                generated water. Defaults to 30\n            constant_weighting (float, optional): Proportion of temperature that is\n                made up from by constant_temp. Defaults to 0.2.\n\n        Key assumptions:\n            - Per capita calculations to generate demand based on population.\n            - Pollutant concentration of generated demand uses a fixed mass per person\n              per timestep.\n            - Temperature of generated wastewater is based partially on air temperature\n              and partially on a constant.\n            - Can interact with `land.py/GardenSurface` to simulate garden water use.\n\n        Input data and parameter requirements:\n            - `population`.\n                _Units_: n\n            - `per_capita`.\n                _Units_: m3/timestep\n            - `data_input_dict` should contain air temperature at model timestep.\n                _Units_: C\n        \"\"\"\n        self.gardening_efficiency = gardening_efficiency\n        self.population = population\n        self.per_capita = per_capita\n        self.constant_weighting = constant_weighting\n        self.constant_temp = constant_temp\n        super().__init__(\n            data_input_dict=data_input_dict, pollutant_load=pollutant_load, **kwargs\n        )\n        # Label as Demand class so that other nodes treat it the same\n        self.__class__.__name__ = \"Demand\"\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}):\n        \"\"\"Apply overrides to the sewer.\n\n        Enables a user to override any of the following parameters:\n        gardening_efficiency, population, per_capita, constant_weighting, constant_temp.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.gardening_efficiency = overrides.pop(\n            \"gardening_efficiency\", self.gardening_efficiency\n        )\n        self.population = overrides.pop(\"population\", self.population)\n        self.per_capita = overrides.pop(\"per_capita\", self.per_capita)\n        self.constant_weighting = overrides.pop(\n            \"constant_weighting\", self.constant_weighting\n        )\n        self.constant_temp = overrides.pop(\"constant_temp\", self.constant_temp)\n        super().apply_overrides(overrides)\n\n    def get_demand(self):\n        \"\"\"Overwrite get_demand and replace with custom functions.\n\n        Returns:\n            (dict): A dict of VQIPs, where the keys match with directions\n                in Demand/create_demand\n        \"\"\"\n        water_output = {}\n\n        water_output[\"garden\"] = self.get_garden_demand()\n        water_output[\"house\"] = self.get_house_demand()\n\n        return water_output\n\n    def get_garden_demand(self):\n        \"\"\"Calculate garden water demand in the current timestep by get_connected to all\n        attached land nodes. This check should return garden water demand. Applies\n        irrigation coefficient. Can function when a single population node is connected\n        to multiple land nodes, however, the capacity and preferences of arcs should be\n        updated to reflect what is possible based on area.\n\n        Returns:\n            vqip (dict): A VQIP of garden water use (including pollutants) to be\n                pushed to land\n        \"\"\"\n        # Get garden water demand\n        excess = self.get_connected(\n            direction=\"push\", of_type=\"Land\", tag=(\"Demand\", \"Garden\")\n        )[\"avail\"]\n\n        # Apply garden_efficiency\n        excess = self.excess_to_garden_demand(excess)\n\n        # Apply any pollutants\n        vqip = self.apply_gardening_pollutants(excess)\n        return vqip\n\n    def apply_gardening_pollutants(self, excess):\n        \"\"\"Holder function to apply pollutants (i.e., presumably fertiliser) to the\n        garden.\n\n        Args:\n            excess (float): A volume of water applied to a garden\n\n        Returns:\n            (dict): A VQIP of water that includes pollutants to be sent to land\n        \"\"\"\n        # TODO Fertilisers are currently applied in the land node... which is\n        # preferable?\n        vqip = self.empty_vqip()\n        vqip[\"volume\"] = excess\n        return vqip\n\n    def excess_to_garden_demand(self, excess):\n        \"\"\"Apply garden_efficiency.\n\n        Args:\n            excess (float): Volume of water required to satisfy garden irrigation\n\n        Returns:\n            (float): Amount of water actually applied to garden\n        \"\"\"\n        # TODO Anything more than this needed? (yes - population presence if eventually\n        # included!)\n\n        return excess * self.gardening_efficiency\n\n    def get_house_demand(self):\n        \"\"\"Per capita calculations for household wastewater generation. Applies weighted\n        temperature calculation.\n\n        Returns:\n            (dict): A VQIP containg foul water\n        \"\"\"\n        # TODO water that is consumed but not sent onwards as foul Total water required\n        consumption = self.population * self.per_capita\n        # Apply pollutants\n        foul = self.copy_vqip(self.pollutant_load)\n        # Scale to population\n        for pol in constants.ADDITIVE_POLLUTANTS:\n            foul[pol] *= self.population\n        # Update volume and temperature (which is weighted based on air temperature and\n        # constant_temp)\n        foul[\"volume\"] = consumption\n        foul[\"temperature\"] = (\n            self.get_data_input(\"temperature\") * (1 - self.constant_weighting)\n            + self.constant_temp * self.constant_weighting\n        )\n        return foul\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.__init__","title":"<code>__init__(population=1, pollutant_load={}, per_capita=0.12, gardening_efficiency=0.6 * 0.7, data_input_dict={}, constant_temp=30, constant_weighting=0.2, **kwargs)</code>","text":"<p>Subclass of demand with functions to handle internal and external water use.</p> <p>Parameters:</p> Name Type Description Default <code>population</code> <code>float</code> <p>population of node. Defaults to 1. per_capita</p> <code>1</code> <code></code> <code>float</code> <p>Volume per person per timestep of water used. Defaults to 0.12.</p> required <code>pollutant_load</code> <code>dict</code> <p>Mass per person per timestep of different pollutants generated. Defaults to {}.</p> <code>{}</code> <code>gardening_efficiency</code> <code>float</code> <p>Value between 0 and 1 that translates irrigation demand from GardenSurface into water requested from the distribution network. Should account for percent of garden that is irrigated and the efficacy of people in meeting their garden water demand. Defaults to 0.6*0.7.</p> <code>0.6 * 0.7</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (temperature). Keys are tuples where first value is the name of the variable to read from the dict and the second value is the time. Defaults to {}</p> <code>{}</code> <code>constant_temp</code> <code>float</code> <p>A constant temperature associated with generated water. Defaults to 30</p> <code>30</code> <code>constant_weighting</code> <code>float</code> <p>Proportion of temperature that is made up from by constant_temp. Defaults to 0.2.</p> <code>0.2</code> Key assumptions <ul> <li>Per capita calculations to generate demand based on population.</li> <li>Pollutant concentration of generated demand uses a fixed mass per person   per timestep.</li> <li>Temperature of generated wastewater is based partially on air temperature   and partially on a constant.</li> <li>Can interact with <code>land.py/GardenSurface</code> to simulate garden water use.</li> </ul> Input data and parameter requirements <ul> <li><code>population</code>.     Units: n</li> <li><code>per_capita</code>.     Units: m3/timestep</li> <li><code>data_input_dict</code> should contain air temperature at model timestep.     Units: C</li> </ul> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def __init__(\n    self,\n    population=1,\n    pollutant_load={},\n    per_capita=0.12,\n    gardening_efficiency=0.6 * 0.7,  # Watering efficiency by irrigated area\n    data_input_dict={},  # For temperature\n    constant_temp=30,\n    constant_weighting=0.2,\n    **kwargs,\n):\n    \"\"\"Subclass of demand with functions to handle internal and external water use.\n\n    Args:\n        population (float, optional): population of node. Defaults to 1. per_capita\n        (float, optional): Volume per person per timestep of water\n            used. Defaults to 0.12.\n        pollutant_load (dict, optional): Mass per person per timestep of\n            different pollutants generated. Defaults to {}.\n        gardening_efficiency (float, optional): Value between 0 and 1 that\n            translates irrigation demand from GardenSurface into water requested\n            from the distribution network. Should account for percent of garden that\n            is irrigated and the efficacy of people in meeting their garden water\n            demand. Defaults to 0.6*0.7.\n        data_input_dict (dict, optional):  Dictionary of data inputs relevant for\n            the node (temperature). Keys are tuples where first value is the name of\n            the variable to read from the dict and the second value is the time.\n            Defaults to {}\n        constant_temp (float, optional): A constant temperature associated with\n            generated water. Defaults to 30\n        constant_weighting (float, optional): Proportion of temperature that is\n            made up from by constant_temp. Defaults to 0.2.\n\n    Key assumptions:\n        - Per capita calculations to generate demand based on population.\n        - Pollutant concentration of generated demand uses a fixed mass per person\n          per timestep.\n        - Temperature of generated wastewater is based partially on air temperature\n          and partially on a constant.\n        - Can interact with `land.py/GardenSurface` to simulate garden water use.\n\n    Input data and parameter requirements:\n        - `population`.\n            _Units_: n\n        - `per_capita`.\n            _Units_: m3/timestep\n        - `data_input_dict` should contain air temperature at model timestep.\n            _Units_: C\n    \"\"\"\n    self.gardening_efficiency = gardening_efficiency\n    self.population = population\n    self.per_capita = per_capita\n    self.constant_weighting = constant_weighting\n    self.constant_temp = constant_temp\n    super().__init__(\n        data_input_dict=data_input_dict, pollutant_load=pollutant_load, **kwargs\n    )\n    # Label as Demand class so that other nodes treat it the same\n    self.__class__.__name__ = \"Demand\"\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.apply_gardening_pollutants","title":"<code>apply_gardening_pollutants(excess)</code>","text":"<p>Holder function to apply pollutants (i.e., presumably fertiliser) to the garden.</p> <p>Parameters:</p> Name Type Description Default <code>excess</code> <code>float</code> <p>A volume of water applied to a garden</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP of water that includes pollutants to be sent to land</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def apply_gardening_pollutants(self, excess):\n    \"\"\"Holder function to apply pollutants (i.e., presumably fertiliser) to the\n    garden.\n\n    Args:\n        excess (float): A volume of water applied to a garden\n\n    Returns:\n        (dict): A VQIP of water that includes pollutants to be sent to land\n    \"\"\"\n    # TODO Fertilisers are currently applied in the land node... which is\n    # preferable?\n    vqip = self.empty_vqip()\n    vqip[\"volume\"] = excess\n    return vqip\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the sewer.</p> <p>Enables a user to override any of the following parameters: gardening_efficiency, population, per_capita, constant_weighting, constant_temp.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def apply_overrides(self, overrides: Dict[str, Any] = {}):\n    \"\"\"Apply overrides to the sewer.\n\n    Enables a user to override any of the following parameters:\n    gardening_efficiency, population, per_capita, constant_weighting, constant_temp.\n\n    Args:\n        overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n    \"\"\"\n    self.gardening_efficiency = overrides.pop(\n        \"gardening_efficiency\", self.gardening_efficiency\n    )\n    self.population = overrides.pop(\"population\", self.population)\n    self.per_capita = overrides.pop(\"per_capita\", self.per_capita)\n    self.constant_weighting = overrides.pop(\n        \"constant_weighting\", self.constant_weighting\n    )\n    self.constant_temp = overrides.pop(\"constant_temp\", self.constant_temp)\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.excess_to_garden_demand","title":"<code>excess_to_garden_demand(excess)</code>","text":"<p>Apply garden_efficiency.</p> <p>Parameters:</p> Name Type Description Default <code>excess</code> <code>float</code> <p>Volume of water required to satisfy garden irrigation</p> required <p>Returns:</p> Type Description <code>float</code> <p>Amount of water actually applied to garden</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def excess_to_garden_demand(self, excess):\n    \"\"\"Apply garden_efficiency.\n\n    Args:\n        excess (float): Volume of water required to satisfy garden irrigation\n\n    Returns:\n        (float): Amount of water actually applied to garden\n    \"\"\"\n    # TODO Anything more than this needed? (yes - population presence if eventually\n    # included!)\n\n    return excess * self.gardening_efficiency\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.get_demand","title":"<code>get_demand()</code>","text":"<p>Overwrite get_demand and replace with custom functions.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A dict of VQIPs, where the keys match with directions in Demand/create_demand</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def get_demand(self):\n    \"\"\"Overwrite get_demand and replace with custom functions.\n\n    Returns:\n        (dict): A dict of VQIPs, where the keys match with directions\n            in Demand/create_demand\n    \"\"\"\n    water_output = {}\n\n    water_output[\"garden\"] = self.get_garden_demand()\n    water_output[\"house\"] = self.get_house_demand()\n\n    return water_output\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.get_garden_demand","title":"<code>get_garden_demand()</code>","text":"<p>Calculate garden water demand in the current timestep by get_connected to all attached land nodes. This check should return garden water demand. Applies irrigation coefficient. Can function when a single population node is connected to multiple land nodes, however, the capacity and preferences of arcs should be updated to reflect what is possible based on area.</p> <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP of garden water use (including pollutants) to be pushed to land</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def get_garden_demand(self):\n    \"\"\"Calculate garden water demand in the current timestep by get_connected to all\n    attached land nodes. This check should return garden water demand. Applies\n    irrigation coefficient. Can function when a single population node is connected\n    to multiple land nodes, however, the capacity and preferences of arcs should be\n    updated to reflect what is possible based on area.\n\n    Returns:\n        vqip (dict): A VQIP of garden water use (including pollutants) to be\n            pushed to land\n    \"\"\"\n    # Get garden water demand\n    excess = self.get_connected(\n        direction=\"push\", of_type=\"Land\", tag=(\"Demand\", \"Garden\")\n    )[\"avail\"]\n\n    # Apply garden_efficiency\n    excess = self.excess_to_garden_demand(excess)\n\n    # Apply any pollutants\n    vqip = self.apply_gardening_pollutants(excess)\n    return vqip\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.demand.ResidentialDemand.get_house_demand","title":"<code>get_house_demand()</code>","text":"<p>Per capita calculations for household wastewater generation. Applies weighted temperature calculation.</p> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP containg foul water</p> Source code in <code>wsimod/nodes/demand.py</code> <pre><code>def get_house_demand(self):\n    \"\"\"Per capita calculations for household wastewater generation. Applies weighted\n    temperature calculation.\n\n    Returns:\n        (dict): A VQIP containg foul water\n    \"\"\"\n    # TODO water that is consumed but not sent onwards as foul Total water required\n    consumption = self.population * self.per_capita\n    # Apply pollutants\n    foul = self.copy_vqip(self.pollutant_load)\n    # Scale to population\n    for pol in constants.ADDITIVE_POLLUTANTS:\n        foul[pol] *= self.population\n    # Update volume and temperature (which is weighted based on air temperature and\n    # constant_temp)\n    foul[\"volume\"] = consumption\n    foul[\"temperature\"] = (\n        self.get_data_input(\"temperature\") * (1 - self.constant_weighting)\n        + self.constant_temp * self.constant_weighting\n    )\n    return foul\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.Distribution","title":"<code>Distribution</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>class Distribution(Node):\n    \"\"\"\"\"\"\n\n    def __init__(self, leakage=0, **kwargs):\n        \"\"\"A Node that cannot be pushed to. Intended to pass calls to FWTW - though this\n        currently relies on the user to connect it properly.\n\n        Args:\n            leakage (float, optional): 1 &gt; float &gt;= 0 to express how much\n                water should be leaked to any attached groundwater nodes. This\n                number represents the proportion of total flow through the node\n                that should be leaked.\n                Defaults to 0.\n\n        Functions intended to call in orchestration:\n            None\n\n        Key assumptions:\n            - No distribution processes yet represented, this class is just\n                for conveyance.\n\n        Input data and parameter requirements:\n            - None\n        \"\"\"\n        self.leakage = leakage\n        super().__init__(**kwargs)\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_check_deny\n        self.decorate_pull_handlers()\n\n    def decorate_pull_handlers(self):\n        \"\"\"Decorate handlers if there is leakage ratio.\"\"\"\n        if self.leakage &gt; 0:\n            self.pull_set_handler[\"default\"] = decorate_leakage_set(\n                self, self.pull_set_handler[\"default\"]\n            )\n            self.pull_check_handler[\"default\"] = decorate_leakage_check(\n                self, self.pull_check_handler[\"default\"]\n            )\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}):\n        \"\"\"Apply overrides to the sewer.\n\n        Enables a user to override any of the following parameters:\n        leakage.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.leakage = overrides.pop(\"leakage\", self.leakage)\n        self.decorate_pull_handlers()\n        super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.Distribution.__init__","title":"<code>__init__(leakage=0, **kwargs)</code>","text":"<p>A Node that cannot be pushed to. Intended to pass calls to FWTW - though this currently relies on the user to connect it properly.</p> <p>Parameters:</p> Name Type Description Default <code>leakage</code> <code>float</code> <p>1 &gt; float &gt;= 0 to express how much water should be leaked to any attached groundwater nodes. This number represents the proportion of total flow through the node that should be leaked. Defaults to 0.</p> <code>0</code> Functions intended to call in orchestration <p>None</p> Key assumptions <ul> <li>No distribution processes yet represented, this class is just     for conveyance.</li> </ul> Input data and parameter requirements <ul> <li>None</li> </ul> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def __init__(self, leakage=0, **kwargs):\n    \"\"\"A Node that cannot be pushed to. Intended to pass calls to FWTW - though this\n    currently relies on the user to connect it properly.\n\n    Args:\n        leakage (float, optional): 1 &gt; float &gt;= 0 to express how much\n            water should be leaked to any attached groundwater nodes. This\n            number represents the proportion of total flow through the node\n            that should be leaked.\n            Defaults to 0.\n\n    Functions intended to call in orchestration:\n        None\n\n    Key assumptions:\n        - No distribution processes yet represented, this class is just\n            for conveyance.\n\n    Input data and parameter requirements:\n        - None\n    \"\"\"\n    self.leakage = leakage\n    super().__init__(**kwargs)\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_check_deny\n    self.decorate_pull_handlers()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.Distribution.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the sewer.</p> <p>Enables a user to override any of the following parameters: leakage.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def apply_overrides(self, overrides: Dict[str, Any] = {}):\n    \"\"\"Apply overrides to the sewer.\n\n    Enables a user to override any of the following parameters:\n    leakage.\n\n    Args:\n        overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n    \"\"\"\n    self.leakage = overrides.pop(\"leakage\", self.leakage)\n    self.decorate_pull_handlers()\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.Distribution.decorate_pull_handlers","title":"<code>decorate_pull_handlers()</code>","text":"<p>Decorate handlers if there is leakage ratio.</p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def decorate_pull_handlers(self):\n    \"\"\"Decorate handlers if there is leakage ratio.\"\"\"\n    if self.leakage &gt; 0:\n        self.pull_set_handler[\"default\"] = decorate_leakage_set(\n            self, self.pull_set_handler[\"default\"]\n        )\n        self.pull_check_handler[\"default\"] = decorate_leakage_check(\n            self, self.pull_check_handler[\"default\"]\n        )\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.UnlimitedDistribution","title":"<code>UnlimitedDistribution</code>","text":"<p>               Bases: <code>Distribution</code></p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>class UnlimitedDistribution(Distribution):\n    \"\"\"\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"A distribution node that provides unlimited water while tracking pass\n        balance.\n\n        Functions intended to call in orchestration:\n            None\n\n        Key assumptions:\n            - Water demand is always satisfied.\n\n        Input data and parameter requirements:\n            - None\n        \"\"\"\n        super().__init__(**kwargs)\n        # Update handlers\n        self.pull_set_handler[\"default\"] = self.pull_set_unlimited\n        self.pull_check_handler[\"default\"] = lambda x: self.v_change_vqip(\n            self.empty_vqip(), constants.UNBOUNDED_CAPACITY\n        )\n\n        # States\n        self.supplied = self.empty_vqip()\n\n        self.mass_balance_in.append(lambda: self.supplied)\n\n    def pull_set_unlimited(self, vqip):\n        \"\"\"Respond that VQIP was fulfilled and update state variables for mass balance.\n\n        Args:\n            vqip (dict): A VQIP amount to request\n\n        Returns:\n            vqip (dict): A VQIP amount that was supplied\n        \"\"\"\n        # TODO maybe need some pollutant concentrations?\n        vqip = self.v_change_vqip(self.empty_vqip(), vqip[\"volume\"])\n        self.supplied = self.sum_vqip(self.supplied, vqip)\n        return vqip\n\n    def end_timestep(self):\n        \"\"\"Update state variables.\"\"\"\n        self.supplied = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.UnlimitedDistribution.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>A distribution node that provides unlimited water while tracking pass balance.</p> Functions intended to call in orchestration <p>None</p> Key assumptions <ul> <li>Water demand is always satisfied.</li> </ul> Input data and parameter requirements <ul> <li>None</li> </ul> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"A distribution node that provides unlimited water while tracking pass\n    balance.\n\n    Functions intended to call in orchestration:\n        None\n\n    Key assumptions:\n        - Water demand is always satisfied.\n\n    Input data and parameter requirements:\n        - None\n    \"\"\"\n    super().__init__(**kwargs)\n    # Update handlers\n    self.pull_set_handler[\"default\"] = self.pull_set_unlimited\n    self.pull_check_handler[\"default\"] = lambda x: self.v_change_vqip(\n        self.empty_vqip(), constants.UNBOUNDED_CAPACITY\n    )\n\n    # States\n    self.supplied = self.empty_vqip()\n\n    self.mass_balance_in.append(lambda: self.supplied)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.UnlimitedDistribution.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Update state variables.</p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Update state variables.\"\"\"\n    self.supplied = self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.UnlimitedDistribution.pull_set_unlimited","title":"<code>pull_set_unlimited(vqip)</code>","text":"<p>Respond that VQIP was fulfilled and update state variables for mass balance.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to request</p> required <p>Returns:</p> Name Type Description <code>vqip</code> <code>dict</code> <p>A VQIP amount that was supplied</p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def pull_set_unlimited(self, vqip):\n    \"\"\"Respond that VQIP was fulfilled and update state variables for mass balance.\n\n    Args:\n        vqip (dict): A VQIP amount to request\n\n    Returns:\n        vqip (dict): A VQIP amount that was supplied\n    \"\"\"\n    # TODO maybe need some pollutant concentrations?\n    vqip = self.v_change_vqip(self.empty_vqip(), vqip[\"volume\"])\n    self.supplied = self.sum_vqip(self.supplied, vqip)\n    return vqip\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.decorate_leakage_check","title":"<code>decorate_leakage_check(self, f)</code>","text":"<p>Decorator to extend the functionality of <code>f</code> by introducing leakage. This is achieved by adjusting the volume of the request (vqip) to include anticipated leakage and then calling the original function <code>f</code>.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>instance of Distribution class</code> <p>The Distribution object to be extended</p> required <code>f</code> <code>function</code> <p>The function to be extended. Expected to be the Distribution object's pull_set function.</p> required <p>Returns:</p> Name Type Description <code>pull_check</code> <code>function</code> <p>The decorated function which includes the original functionality of <code>f</code> and additional leakage operations.</p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def decorate_leakage_check(self, f):\n    \"\"\"Decorator to extend the functionality of `f` by introducing leakage. This is\n    achieved by adjusting the volume of the request (vqip) to include anticipated\n    leakage and then calling the original function `f`.\n\n    Args:\n        self (instance of Distribution class): The Distribution object to be\n            extended\n        f (function): The function to be extended. Expected to be the\n            Distribution object's pull_set function.\n\n    Returns:\n        pull_check (function): The decorated function which includes the\n            original functionality of `f` and additional leakage operations.\n    \"\"\"\n\n    def pull_check(vqip, **kwargs):\n        \"\"\"\n\n        Args:\n            vqip:\n            **kwargs:\n\n        Returns:\n\n        \"\"\"\n        if vqip is not None:\n            vqip[\"volume\"] /= 1 - self.leakage\n        reply = f(vqip, **kwargs)\n        amount_leaked = self.v_change_vqip(reply, reply[\"volume\"] * self.leakage)\n\n        reply = self.extract_vqip(reply, amount_leaked)\n        return reply\n\n    return pull_check\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.distribution.decorate_leakage_set","title":"<code>decorate_leakage_set(self, f)</code>","text":"<p>Decorator to extend the functionality of <code>f</code> by introducing leakage. This is achieved by adjusting the volume of the request (vqip) to include anticipated leakage, calling the original function <code>f</code>, and then distributing the leaked amount to groundwater.</p> <p>Parameters:</p> Name Type Description Default <code>self</code> <code>instance of Distribution class</code> <p>The Distribution object to be extended</p> required <code>f</code> <code>function</code> <p>The function to be extended. Expected to be the Distribution object's pull_set function.</p> required <p>Returns:</p> Name Type Description <code>pull_set</code> <code>function</code> <p>The decorated function which includes the original functionality of <code>f</code> and additional leakage operations.</p> Source code in <code>wsimod/nodes/distribution.py</code> <pre><code>def decorate_leakage_set(self, f):\n    \"\"\"Decorator to extend the functionality of `f` by introducing leakage. This is\n    achieved by adjusting the volume of the request (vqip) to include anticipated\n    leakage, calling the original function `f`, and then distributing the leaked amount\n    to groundwater.\n\n    Args:\n        self (instance of Distribution class): The Distribution object to be\n            extended\n        f (function): The function to be extended. Expected to be the\n            Distribution object's pull_set function.\n\n    Returns:\n        pull_set (function): The decorated function which includes the\n            original functionality of `f` and additional leakage operations.\n    \"\"\"\n\n    def pull_set(vqip, **kwargs):\n        \"\"\"\n\n        Args:\n            vqip:\n            **kwargs:\n\n        Returns:\n\n        \"\"\"\n        vqip[\"volume\"] /= 1 - self.leakage\n\n        reply = f(vqip, **kwargs)\n\n        amount_leaked = self.v_change_vqip(reply, reply[\"volume\"] * self.leakage)\n\n        reply = self.extract_vqip(reply, amount_leaked)\n\n        unsuccessful_leakage = self.push_distributed(\n            amount_leaked, of_type=\"Groundwater\"\n        )\n        if unsuccessful_leakage[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\n                \"warning, distribution leakage not going to GW in {0} at {1}\".format(\n                    self.name, self.t\n                )\n            )\n            reply = self.sum_vqip(reply, unsuccessful_leakage)\n\n        return reply\n\n    return pull_set\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.waste.Waste","title":"<code>Waste</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/waste.py</code> <pre><code>class Waste(Node):\n    \"\"\"\"\"\"\n\n    def __init__(self, name):\n        \"\"\"Outlet node that can receive any amount of water by pushes.\n\n        Args:\n            name (str): Node name\n\n        Functions intended to call in orchestration:\n            None\n\n        Key assumptions:\n            - Water 'disappears' (leaves the model) from these nodes.\n\n        Input data and parameter requirements:\n            - None\n        \"\"\"\n        # Update args\n        super().__init__(name)\n\n        # Update handlers\n        self.pull_set_handler[\"default\"] = self.pull_set_deny\n        self.pull_check_handler[\"default\"] = self.pull_check_deny\n        self.push_set_handler[\"default\"] = self.push_set_accept\n        self.push_check_handler[\"default\"] = self.push_check_accept\n\n        # Mass balance\n        self.mass_balance_out.append(self.total_in)\n\n    def push_set_accept(self, vqip):\n        \"\"\"Push set function that accepts all water.\n\n        Args:\n            vqip (dict): A VQIP that has been pushed (ignored)\n\n        Returns:\n            (dict): An empty VQIP, indicating all water was received\n        \"\"\"\n        return self.empty_vqip()\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.waste.Waste.__init__","title":"<code>__init__(name)</code>","text":"<p>Outlet node that can receive any amount of water by pushes.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Node name</p> required Functions intended to call in orchestration <p>None</p> Key assumptions <ul> <li>Water 'disappears' (leaves the model) from these nodes.</li> </ul> Input data and parameter requirements <ul> <li>None</li> </ul> Source code in <code>wsimod/nodes/waste.py</code> <pre><code>def __init__(self, name):\n    \"\"\"Outlet node that can receive any amount of water by pushes.\n\n    Args:\n        name (str): Node name\n\n    Functions intended to call in orchestration:\n        None\n\n    Key assumptions:\n        - Water 'disappears' (leaves the model) from these nodes.\n\n    Input data and parameter requirements:\n        - None\n    \"\"\"\n    # Update args\n    super().__init__(name)\n\n    # Update handlers\n    self.pull_set_handler[\"default\"] = self.pull_set_deny\n    self.pull_check_handler[\"default\"] = self.pull_check_deny\n    self.push_set_handler[\"default\"] = self.push_set_accept\n    self.push_check_handler[\"default\"] = self.push_check_accept\n\n    # Mass balance\n    self.mass_balance_out.append(self.total_in)\n</code></pre>"},{"location":"reference-other/#wsimod.nodes.waste.Waste.push_set_accept","title":"<code>push_set_accept(vqip)</code>","text":"<p>Push set function that accepts all water.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that has been pushed (ignored)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>An empty VQIP, indicating all water was received</p> Source code in <code>wsimod/nodes/waste.py</code> <pre><code>def push_set_accept(self, vqip):\n    \"\"\"Push set function that accepts all water.\n\n    Args:\n        vqip (dict): A VQIP that has been pushed (ignored)\n\n    Returns:\n        (dict): An empty VQIP, indicating all water was received\n    \"\"\"\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-sewer/","title":"API Reference - Sewer","text":"<p>This section of the documentation provides a reference for the API of the nodes.sewer module.</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson Converted to totals on 2022-05-03</p>"},{"location":"reference-sewer/#wsimod.nodes.sewer.EnfieldFoulSewer","title":"<code>EnfieldFoulSewer</code>","text":"<p>               Bases: <code>Sewer</code></p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>class EnfieldFoulSewer(Sewer):\n    \"\"\"\"\"\"\n\n    # TODO: combine with sewer\n    def __init__(\n        self,\n        name,\n        capacity=0,\n        pipe_time=0,  # Sewer to sewer travel time\n        pipe_timearea={0: 1},\n        chamber_area=1,\n        chamber_floor=10,\n        data_input_dict={},\n    ):\n        \"\"\"Alternate legacy sewer class...\n\n        I dont think this is needed any more.\n        \"\"\"\n        # TODO above\n\n        super().__init__(\n            name,\n            capacity=capacity,\n            pipe_time=pipe_time,\n            pipe_timearea=pipe_timearea,\n            chamber_area=chamber_area,\n            chamber_floor=chamber_floor,\n            data_input_dict=data_input_dict,\n        )\n        self.__class__.__name__ = \"Sewer\"\n\n    def make_discharge(self):\n        \"\"\"\"\"\"\n        _ = self.sewer_tank.internal_arc.update_queue(direction=\"push\")\n\n        # Discharge downstream\n        if (\n            self.sewer_tank.storage[\"volume\"]\n            &gt; self.storm_exchange * self.sewer_tank.capacity\n        ):\n            exchange_v = min(\n                (1 - self.storm_exchange) * self.sewer_tank.capacity,\n                self.sewer_tank.active_storage[\"volume\"],\n            )\n            exchange = self.v_change_vqip(self.sewer_tank.active_storage, exchange_v)\n            remaining = self.push_distributed(exchange)\n            sent_to_exchange = self.v_change_vqip(\n                self.sewer_tank.active_storage, exchange_v - remaining[\"volume\"]\n            )\n            self.sewer_tank.pull_storage(sent_to_exchange)\n\n        remaining = self.push_distributed(\n            self.sewer_tank.active_storage, of_type=[\"Waste\"]\n        )\n\n        # Update tank\n        sent = self.sewer_tank.active_storage[\"volume\"] - remaining[\"volume\"]\n        sent = self.v_change_vqip(self.sewer_tank.active_storage, sent)\n        reply = self.sewer_tank.pull_storage(sent)\n        if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n            print(\"Miscalculated tank storage in discharge\")\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.EnfieldFoulSewer.__init__","title":"<code>__init__(name, capacity=0, pipe_time=0, pipe_timearea={0: 1}, chamber_area=1, chamber_floor=10, data_input_dict={})</code>","text":"<p>Alternate legacy sewer class...</p> <p>I dont think this is needed any more.</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def __init__(\n    self,\n    name,\n    capacity=0,\n    pipe_time=0,  # Sewer to sewer travel time\n    pipe_timearea={0: 1},\n    chamber_area=1,\n    chamber_floor=10,\n    data_input_dict={},\n):\n    \"\"\"Alternate legacy sewer class...\n\n    I dont think this is needed any more.\n    \"\"\"\n    # TODO above\n\n    super().__init__(\n        name,\n        capacity=capacity,\n        pipe_time=pipe_time,\n        pipe_timearea=pipe_timearea,\n        chamber_area=chamber_area,\n        chamber_floor=chamber_floor,\n        data_input_dict=data_input_dict,\n    )\n    self.__class__.__name__ = \"Sewer\"\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.EnfieldFoulSewer.make_discharge","title":"<code>make_discharge()</code>","text":"Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def make_discharge(self):\n    \"\"\"\"\"\"\n    _ = self.sewer_tank.internal_arc.update_queue(direction=\"push\")\n\n    # Discharge downstream\n    if (\n        self.sewer_tank.storage[\"volume\"]\n        &gt; self.storm_exchange * self.sewer_tank.capacity\n    ):\n        exchange_v = min(\n            (1 - self.storm_exchange) * self.sewer_tank.capacity,\n            self.sewer_tank.active_storage[\"volume\"],\n        )\n        exchange = self.v_change_vqip(self.sewer_tank.active_storage, exchange_v)\n        remaining = self.push_distributed(exchange)\n        sent_to_exchange = self.v_change_vqip(\n            self.sewer_tank.active_storage, exchange_v - remaining[\"volume\"]\n        )\n        self.sewer_tank.pull_storage(sent_to_exchange)\n\n    remaining = self.push_distributed(\n        self.sewer_tank.active_storage, of_type=[\"Waste\"]\n    )\n\n    # Update tank\n    sent = self.sewer_tank.active_storage[\"volume\"] - remaining[\"volume\"]\n    sent = self.v_change_vqip(self.sewer_tank.active_storage, sent)\n    reply = self.sewer_tank.pull_storage(sent)\n    if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n        print(\"Miscalculated tank storage in discharge\")\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer","title":"<code>Sewer</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>class Sewer(Node):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name,\n        capacity=0,\n        pipe_time=0,  # Sewer to sewer travel time\n        pipe_timearea={0: 1},\n        chamber_area=1,\n        chamber_floor=10,\n        data_input_dict={},\n    ):\n        \"\"\"Sewer node that has a QueueTank and storage capacity. Think carefully about\n        parameterising this tank, because of course the amount of water that can flow\n        through a sewer in a timestep is different in reality than in a.\n\n        steady state (e.g., a sewer that can handle a peak of 6m3/s in practice could\n        not handle 6 * 86400 m3 of water in a day because that water does not flow\n        uniformly over the day).\n\n        Args:\n            name (str): node name\n            capacity (float, optional): Sewer tank capacity. Defaults to 0.\n            pipe_time (float, optional): Number of timesteps to spend in the queue of\n                the sewer tank. Defaults to 0.\n            pipe_timearea (dict, optional): Time area diagram that enables flows to\n                take a range of different durations to 'traverse' the tank. The keys\n                of the dict are the number of timesteps while the values are the\n                proportion of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes\n                0 timesteps and 30% takes 1 timesteps.\n            chamber_area (float, optional): Sewer tank area. Defaults to 1.\n            chamber_floor (float, optional): Sewer tank datum. Defaults to 10.\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node (though I don't think it is used). Defaults to {}.\n\n        NOTE that currently the queuetank either applies the pipe_timearea\n        (push_set_land) OR the pipe_time (push_set_sewer). Though this behaviour\n        could be changed by setting the number_of_timesteps property to pipe_time of\n        the sewer_tank and removing the pipe_time setting in push_set_sewer.\n\n        Functions intended to call in orchestration:\n            make_discharge\n\n        Key assumptions:\n            - Sewer networks can be represented in an aggregated manner, where\n                the behaviour of collections of manholes/pipes can be captured\n                in a single component.\n            - Travel time of water received from either `land.py/Land` objects\n                or `demand.py/Demand` objects is assumed to be received as a\n                non-point source and thus can be represented with the time-area\n                method.\n            - Travel time of water from an upstream `Sewer` object has a fixed\n                travel time through the node.\n            - The flow capacity of sewer network can be represented as with a\n                `Tank`.\n            - The `Sewer` object is not currently biochemically active.\n\n        Input data and parameter requirements:\n            - `pipe_timearea` is a dictionary containing the timearea diagram.\n                _Units_: duration of flow (in timesteps) and proportion of flow\n            - `pipe_time` describes the travel time of water received from upstream\n                `Sewer`\n                objects.\n                _Units_: number of timesteps\n            - `capacity`, `chamber_area`, `chamber_datum` describe the dimensions of the\n                `Tank` that controls flow.\n                _Units_: cubic metres, squared metres, metres\n        \"\"\"\n        # Set parameters\n        self.capacity = capacity\n        self.pipe_time = pipe_time\n        self.pipe_timearea = pipe_timearea\n        self.chamber_area = chamber_area\n        self.chamber_floor = chamber_floor\n        # TODO I don't think this is used..\n        self.data_input_dict = data_input_dict\n\n        # Update args\n        super().__init__(name)\n\n        # Update handlers\n        self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n        self.push_set_handler[\"default\"] = self.push_set_sewer\n        self.push_set_handler[\"Land\"] = self.push_set_land\n        self.push_set_handler[\"Demand\"] = self.push_set_land\n\n        self.push_check_handler[\"default\"] = self.push_check_sewer\n        self.push_check_handler[\"Sewer\"] = self.push_check_sewer\n        self.push_check_handler[\"Demand\"] = self.push_check_sewer\n        self.push_check_handler[\"Land\"] = self.push_check_sewer\n\n        # Create sewer tank\n        # TODO this might work better as a ResidenceTank (maybe also decay?)\n        self.sewer_tank = QueueTank(\n            capacity=self.capacity,\n            number_of_timesteps=0,\n            datum=self.chamber_floor,\n            area=self.chamber_area,\n        )\n\n        # Mass balance\n        self.mass_balance_ds.append(lambda: self.sewer_tank.ds())\n\n    def apply_overrides(self, overrides: Dict[str, Any] = {}):\n        \"\"\"Apply overrides to the sewer.\n\n        Enables a user to override any of the following parameters:\n        capacity, chamber_area, chamber_floor, pipe_time, pipe_timearea.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.capacity = overrides.pop(\"capacity\", self.capacity)\n        self.chamber_area = overrides.pop(\"chamber_area\", self.chamber_area)\n        self.chamber_floor = overrides.pop(\"chamber_floor\", self.chamber_floor)\n        self.sewer_tank.capacity = self.capacity\n        self.sewer_tank.area = self.chamber_area\n        self.sewer_tank.datum = self.chamber_floor\n\n        self.pipe_time = overrides.pop(\"pipe_time\", self.pipe_time)\n        if \"pipe_timearea\" in overrides.keys():\n            pipe_timearea_sum = sum([v for k, v in overrides[\"pipe_timearea\"].items()])\n            if pipe_timearea_sum != 1:\n                print(\n                    \"ERROR: the sum of pipe_timearea in the overrides dict \\\n\t\t\tis not equal to 1, please check it\"\n                )\n        self.pipe_timearea = overrides.pop(\"pipe_timearea\", self.pipe_timearea)\n        super().apply_overrides(overrides)\n\n    def push_check_sewer(self, vqip=None):\n        \"\"\"Generic push check, simply looks at excess.\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            excess (dict): Sewer tank excess\n        \"\"\"\n        # Get excess\n        excess = self.sewer_tank.get_excess()\n        if vqip is None:\n            return excess\n        # Limit respone to vqip volume\n        excess = self.v_change_vqip(excess, min(excess[\"volume\"], vqip[\"volume\"]))\n        return excess\n\n    def push_set_sewer(self, vqip):\n        \"\"\"Generic push request setting that implements basic queue travel time (it does\n        NOT implement timearea travel time). Updates the sewer tank storage. Assumes\n        that the inflow arc has accurately calculated capacity with push_check_sewer,\n        thus the water is forced.\n\n        Args:\n            vqip (dict): A VQIP amount of water to push\n\n        Returns:\n            (dict): A VQIP amount of water that was not received\n        \"\"\"\n        # Sewer to sewer push, update queued tank\n        return self.sewer_tank.push_storage(vqip, time=self.pipe_time)\n\n    def push_set_land(self, vqip):\n        \"\"\"Push request that applies pipe_timearea (see __init__ for description). As\n        with push_set_sewer, push is also forced. Used to receive flow from land or\n        demand that is assumed to occur widely across some kind of sewer catchment.\n\n        Args:\n            vqip (dict): A VQIP amount to be pushed\n\n        Returns:\n            (dict): A VQIP amount that was not received\n        \"\"\"\n        # Land/demand to sewer push, update queued tank\n\n        reply = self.empty_vqip()\n\n        # Iterate over timearea diagram\n        for time, normalised in self.pipe_timearea.items():\n            vqip_ = self.v_change_vqip(vqip, vqip[\"volume\"] * normalised)\n            reply_ = self.sewer_tank.push_storage(vqip_, time=time)\n            reply = self.sum_vqip(reply, reply_)\n\n        return reply\n\n    def make_discharge(self):\n        \"\"\"Function to trigger downstream sewer flow.\n\n        Updates sewer tank travel time, pushes to WWTW, then sewer, then CSO. May flood\n        land if, after these attempts, the sewer tank storage is above capacity.\n        \"\"\"\n        self.sewer_tank.internal_arc.update_queue(direction=\"push\")\n        # TODO... do I need to do anything with this backflow... does it ever happen?\n        # Discharge to Sewer if possible\n        # remaining = self.push_distributed(self.sewer_tank.active_storage,\n        #                                 of_type = 'Sewer',\n        #                                 tag = 'Sewer')\n\n        # #Discharge to WWTW if possible\n        # remaining = self.push_distributed(remaining,\n        #                                 of_type = 'WWTW',\n        #                                 tag = 'Sewer')\n\n        # #CSO discharge\n        # remaining = self.push_distributed(remaining,\n        #                                   of_type = ['Node', 'River'])\n\n        remaining = self.push_distributed(self.sewer_tank.active_storage)\n\n        # TODO backflow can cause mass balance errors here\n\n        # Update tank\n        sent = self.extract_vqip(self.sewer_tank.active_storage, remaining)\n        reply = self.sewer_tank.pull_storage_exact(sent)\n        if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n            print(\"Miscalculated tank storage in discharge\")\n\n        # Flood excess\n        ponded = self.sewer_tank.pull_ponded()\n        if ponded[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            reply_ = self.push_distributed(ponded, of_type=[\"Land\"], tag=\"Sewer\")\n            reply_ = self.sewer_tank.push_storage(reply_, time=0, force=True)\n            if reply_[\"volume\"]:\n                print(\"ponded water cant reenter\")\n\n    def end_timestep(self):\n        \"\"\"Overwrite end_timestep behaviour to update tank variables.\"\"\"\n        self.sewer_tank.end_timestep()\n\n    def reinit(self):\n        \"\"\"Call Tank reinit.\"\"\"\n        self.sewer_tank.reinit()\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.__init__","title":"<code>__init__(name, capacity=0, pipe_time=0, pipe_timearea={0: 1}, chamber_area=1, chamber_floor=10, data_input_dict={})</code>","text":"<p>Sewer node that has a QueueTank and storage capacity. Think carefully about parameterising this tank, because of course the amount of water that can flow through a sewer in a timestep is different in reality than in a.</p> <p>steady state (e.g., a sewer that can handle a peak of 6m3/s in practice could not handle 6 * 86400 m3 of water in a day because that water does not flow uniformly over the day).</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>node name</p> required <code>capacity</code> <code>float</code> <p>Sewer tank capacity. Defaults to 0.</p> <code>0</code> <code>pipe_time</code> <code>float</code> <p>Number of timesteps to spend in the queue of the sewer tank. Defaults to 0.</p> <code>0</code> <code>pipe_timearea</code> <code>dict</code> <p>Time area diagram that enables flows to take a range of different durations to 'traverse' the tank. The keys of the dict are the number of timesteps while the values are the proportion of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes 0 timesteps and 30% takes 1 timesteps.</p> <code>{0: 1}</code> <code>chamber_area</code> <code>float</code> <p>Sewer tank area. Defaults to 1.</p> <code>1</code> <code>chamber_floor</code> <code>float</code> <p>Sewer tank datum. Defaults to 10.</p> <code>10</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (though I don't think it is used). Defaults to {}.</p> <code>{}</code> <p>NOTE that currently the queuetank either applies the pipe_timearea (push_set_land) OR the pipe_time (push_set_sewer). Though this behaviour could be changed by setting the number_of_timesteps property to pipe_time of the sewer_tank and removing the pipe_time setting in push_set_sewer.</p> Functions intended to call in orchestration <p>make_discharge</p> Key assumptions <ul> <li>Sewer networks can be represented in an aggregated manner, where     the behaviour of collections of manholes/pipes can be captured     in a single component.</li> <li>Travel time of water received from either <code>land.py/Land</code> objects     or <code>demand.py/Demand</code> objects is assumed to be received as a     non-point source and thus can be represented with the time-area     method.</li> <li>Travel time of water from an upstream <code>Sewer</code> object has a fixed     travel time through the node.</li> <li>The flow capacity of sewer network can be represented as with a     <code>Tank</code>.</li> <li>The <code>Sewer</code> object is not currently biochemically active.</li> </ul> Input data and parameter requirements <ul> <li><code>pipe_timearea</code> is a dictionary containing the timearea diagram.     Units: duration of flow (in timesteps) and proportion of flow</li> <li><code>pipe_time</code> describes the travel time of water received from upstream     <code>Sewer</code>     objects.     Units: number of timesteps</li> <li><code>capacity</code>, <code>chamber_area</code>, <code>chamber_datum</code> describe the dimensions of the     <code>Tank</code> that controls flow.     Units: cubic metres, squared metres, metres</li> </ul> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def __init__(\n    self,\n    name,\n    capacity=0,\n    pipe_time=0,  # Sewer to sewer travel time\n    pipe_timearea={0: 1},\n    chamber_area=1,\n    chamber_floor=10,\n    data_input_dict={},\n):\n    \"\"\"Sewer node that has a QueueTank and storage capacity. Think carefully about\n    parameterising this tank, because of course the amount of water that can flow\n    through a sewer in a timestep is different in reality than in a.\n\n    steady state (e.g., a sewer that can handle a peak of 6m3/s in practice could\n    not handle 6 * 86400 m3 of water in a day because that water does not flow\n    uniformly over the day).\n\n    Args:\n        name (str): node name\n        capacity (float, optional): Sewer tank capacity. Defaults to 0.\n        pipe_time (float, optional): Number of timesteps to spend in the queue of\n            the sewer tank. Defaults to 0.\n        pipe_timearea (dict, optional): Time area diagram that enables flows to\n            take a range of different durations to 'traverse' the tank. The keys\n            of the dict are the number of timesteps while the values are the\n            proportion of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes\n            0 timesteps and 30% takes 1 timesteps.\n        chamber_area (float, optional): Sewer tank area. Defaults to 1.\n        chamber_floor (float, optional): Sewer tank datum. Defaults to 10.\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node (though I don't think it is used). Defaults to {}.\n\n    NOTE that currently the queuetank either applies the pipe_timearea\n    (push_set_land) OR the pipe_time (push_set_sewer). Though this behaviour\n    could be changed by setting the number_of_timesteps property to pipe_time of\n    the sewer_tank and removing the pipe_time setting in push_set_sewer.\n\n    Functions intended to call in orchestration:\n        make_discharge\n\n    Key assumptions:\n        - Sewer networks can be represented in an aggregated manner, where\n            the behaviour of collections of manholes/pipes can be captured\n            in a single component.\n        - Travel time of water received from either `land.py/Land` objects\n            or `demand.py/Demand` objects is assumed to be received as a\n            non-point source and thus can be represented with the time-area\n            method.\n        - Travel time of water from an upstream `Sewer` object has a fixed\n            travel time through the node.\n        - The flow capacity of sewer network can be represented as with a\n            `Tank`.\n        - The `Sewer` object is not currently biochemically active.\n\n    Input data and parameter requirements:\n        - `pipe_timearea` is a dictionary containing the timearea diagram.\n            _Units_: duration of flow (in timesteps) and proportion of flow\n        - `pipe_time` describes the travel time of water received from upstream\n            `Sewer`\n            objects.\n            _Units_: number of timesteps\n        - `capacity`, `chamber_area`, `chamber_datum` describe the dimensions of the\n            `Tank` that controls flow.\n            _Units_: cubic metres, squared metres, metres\n    \"\"\"\n    # Set parameters\n    self.capacity = capacity\n    self.pipe_time = pipe_time\n    self.pipe_timearea = pipe_timearea\n    self.chamber_area = chamber_area\n    self.chamber_floor = chamber_floor\n    # TODO I don't think this is used..\n    self.data_input_dict = data_input_dict\n\n    # Update args\n    super().__init__(name)\n\n    # Update handlers\n    self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n    self.push_set_handler[\"default\"] = self.push_set_sewer\n    self.push_set_handler[\"Land\"] = self.push_set_land\n    self.push_set_handler[\"Demand\"] = self.push_set_land\n\n    self.push_check_handler[\"default\"] = self.push_check_sewer\n    self.push_check_handler[\"Sewer\"] = self.push_check_sewer\n    self.push_check_handler[\"Demand\"] = self.push_check_sewer\n    self.push_check_handler[\"Land\"] = self.push_check_sewer\n\n    # Create sewer tank\n    # TODO this might work better as a ResidenceTank (maybe also decay?)\n    self.sewer_tank = QueueTank(\n        capacity=self.capacity,\n        number_of_timesteps=0,\n        datum=self.chamber_floor,\n        area=self.chamber_area,\n    )\n\n    # Mass balance\n    self.mass_balance_ds.append(lambda: self.sewer_tank.ds())\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.apply_overrides","title":"<code>apply_overrides(overrides={})</code>","text":"<p>Apply overrides to the sewer.</p> <p>Enables a user to override any of the following parameters: capacity, chamber_area, chamber_floor, pipe_time, pipe_timearea.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>dict</code> <p>Dictionary of overrides. Defaults to {}.</p> <code>{}</code> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>    def apply_overrides(self, overrides: Dict[str, Any] = {}):\n        \"\"\"Apply overrides to the sewer.\n\n        Enables a user to override any of the following parameters:\n        capacity, chamber_area, chamber_floor, pipe_time, pipe_timearea.\n\n        Args:\n            overrides (dict, optional): Dictionary of overrides. Defaults to {}.\n        \"\"\"\n        self.capacity = overrides.pop(\"capacity\", self.capacity)\n        self.chamber_area = overrides.pop(\"chamber_area\", self.chamber_area)\n        self.chamber_floor = overrides.pop(\"chamber_floor\", self.chamber_floor)\n        self.sewer_tank.capacity = self.capacity\n        self.sewer_tank.area = self.chamber_area\n        self.sewer_tank.datum = self.chamber_floor\n\n        self.pipe_time = overrides.pop(\"pipe_time\", self.pipe_time)\n        if \"pipe_timearea\" in overrides.keys():\n            pipe_timearea_sum = sum([v for k, v in overrides[\"pipe_timearea\"].items()])\n            if pipe_timearea_sum != 1:\n                print(\n                    \"ERROR: the sum of pipe_timearea in the overrides dict \\\n\t\t\tis not equal to 1, please check it\"\n                )\n        self.pipe_timearea = overrides.pop(\"pipe_timearea\", self.pipe_timearea)\n        super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Overwrite end_timestep behaviour to update tank variables.</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Overwrite end_timestep behaviour to update tank variables.\"\"\"\n    self.sewer_tank.end_timestep()\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.make_discharge","title":"<code>make_discharge()</code>","text":"<p>Function to trigger downstream sewer flow.</p> <p>Updates sewer tank travel time, pushes to WWTW, then sewer, then CSO. May flood land if, after these attempts, the sewer tank storage is above capacity.</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def make_discharge(self):\n    \"\"\"Function to trigger downstream sewer flow.\n\n    Updates sewer tank travel time, pushes to WWTW, then sewer, then CSO. May flood\n    land if, after these attempts, the sewer tank storage is above capacity.\n    \"\"\"\n    self.sewer_tank.internal_arc.update_queue(direction=\"push\")\n    # TODO... do I need to do anything with this backflow... does it ever happen?\n    # Discharge to Sewer if possible\n    # remaining = self.push_distributed(self.sewer_tank.active_storage,\n    #                                 of_type = 'Sewer',\n    #                                 tag = 'Sewer')\n\n    # #Discharge to WWTW if possible\n    # remaining = self.push_distributed(remaining,\n    #                                 of_type = 'WWTW',\n    #                                 tag = 'Sewer')\n\n    # #CSO discharge\n    # remaining = self.push_distributed(remaining,\n    #                                   of_type = ['Node', 'River'])\n\n    remaining = self.push_distributed(self.sewer_tank.active_storage)\n\n    # TODO backflow can cause mass balance errors here\n\n    # Update tank\n    sent = self.extract_vqip(self.sewer_tank.active_storage, remaining)\n    reply = self.sewer_tank.pull_storage_exact(sent)\n    if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n        print(\"Miscalculated tank storage in discharge\")\n\n    # Flood excess\n    ponded = self.sewer_tank.pull_ponded()\n    if ponded[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        reply_ = self.push_distributed(ponded, of_type=[\"Land\"], tag=\"Sewer\")\n        reply_ = self.sewer_tank.push_storage(reply_, time=0, force=True)\n        if reply_[\"volume\"]:\n            print(\"ponded water cant reenter\")\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.push_check_sewer","title":"<code>push_check_sewer(vqip=None)</code>","text":"<p>Generic push check, simply looks at excess.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>excess</code> <code>dict</code> <p>Sewer tank excess</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def push_check_sewer(self, vqip=None):\n    \"\"\"Generic push check, simply looks at excess.\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        excess (dict): Sewer tank excess\n    \"\"\"\n    # Get excess\n    excess = self.sewer_tank.get_excess()\n    if vqip is None:\n        return excess\n    # Limit respone to vqip volume\n    excess = self.v_change_vqip(excess, min(excess[\"volume\"], vqip[\"volume\"]))\n    return excess\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.push_set_land","title":"<code>push_set_land(vqip)</code>","text":"<p>Push request that applies pipe_timearea (see init for description). As with push_set_sewer, push is also forced. Used to receive flow from land or demand that is assumed to occur widely across some kind of sewer catchment.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be pushed</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount that was not received</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def push_set_land(self, vqip):\n    \"\"\"Push request that applies pipe_timearea (see __init__ for description). As\n    with push_set_sewer, push is also forced. Used to receive flow from land or\n    demand that is assumed to occur widely across some kind of sewer catchment.\n\n    Args:\n        vqip (dict): A VQIP amount to be pushed\n\n    Returns:\n        (dict): A VQIP amount that was not received\n    \"\"\"\n    # Land/demand to sewer push, update queued tank\n\n    reply = self.empty_vqip()\n\n    # Iterate over timearea diagram\n    for time, normalised in self.pipe_timearea.items():\n        vqip_ = self.v_change_vqip(vqip, vqip[\"volume\"] * normalised)\n        reply_ = self.sewer_tank.push_storage(vqip_, time=time)\n        reply = self.sum_vqip(reply, reply_)\n\n    return reply\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.push_set_sewer","title":"<code>push_set_sewer(vqip)</code>","text":"<p>Generic push request setting that implements basic queue travel time (it does NOT implement timearea travel time). Updates the sewer tank storage. Assumes that the inflow arc has accurately calculated capacity with push_check_sewer, thus the water is forced.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount of water to push</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was not received</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def push_set_sewer(self, vqip):\n    \"\"\"Generic push request setting that implements basic queue travel time (it does\n    NOT implement timearea travel time). Updates the sewer tank storage. Assumes\n    that the inflow arc has accurately calculated capacity with push_check_sewer,\n    thus the water is forced.\n\n    Args:\n        vqip (dict): A VQIP amount of water to push\n\n    Returns:\n        (dict): A VQIP amount of water that was not received\n    \"\"\"\n    # Sewer to sewer push, update queued tank\n    return self.sewer_tank.push_storage(vqip, time=self.pipe_time)\n</code></pre>"},{"location":"reference-sewer/#wsimod.nodes.sewer.Sewer.reinit","title":"<code>reinit()</code>","text":"<p>Call Tank reinit.</p> Source code in <code>wsimod/nodes/sewer.py</code> <pre><code>def reinit(self):\n    \"\"\"Call Tank reinit.\"\"\"\n    self.sewer_tank.reinit()\n</code></pre>"},{"location":"reference-storage/","title":"API Reference - Storage (reservoir, river, groundwater)","text":"<p>This section of the documentation provides a reference for the API of the nodes.storage module.</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson Converted to totals on 2022-05-03</p>"},{"location":"reference-storage/#wsimod.nodes.storage.Groundwater","title":"<code>Groundwater</code>","text":"<p>               Bases: <code>Storage</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class Groundwater(Storage):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        residence_time=200,\n        infiltration_threshold=1,\n        infiltration_pct=0,\n        data_input_dict={},\n        **kwargs,\n    ):\n        # TODO why isn't this using a ResidenceTank?\n        \"\"\"A storage with a residence time for groundwater. Can also infiltrate to\n        sewers.\n\n        Args:\n            residence_time (float, optional): Residence time (see nodes.py/\n                ResidenceTank). Defaults to 200.\n            infiltration_threshold (float, optional): Proportion of storage capacity\n                that must be exceeded to generate infiltration. Defaults to 1.\n            infiltration_pct (float, optional): Proportion of storage above the\n                threshold that is square rooted and infiltrated. Defaults to 0.\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node (though I don't think it is used). Defaults to {}.\n\n        Functions intended to call in orchestration:\n            infiltrate (before sewers are discharged)\n\n            distribute\n\n        Key assumptions:\n            - Conceptualises groundwater as a tank.\n            - Baseflow is generated following a residence-time method.\n            - Baseflow is sent to `storage.py/River`, `nodes.py/Node` or\n                `waste.py/Waste` nodes.\n            - Infiltration to `sewer.py/Sewer` nodes occurs when the storage\n                in the tank is greater than a specified threshold, at a rate\n                proportional to the sqrt of volume above the threshold. (Note, this\n                behaviour is __not validated__ and a high uncertainty process in\n                general)\n            - If `decays` are provided to model water quality transformations,\n                see `core.py/DecayObj`.\n\n        Input data and parameter requirements:\n            - Groundwater tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n            - Infiltration behaviour determined by an `infiltration_threshold`\n                and `infiltration_pct`. _Units_: proportion of capacity\n            - Optional dictionary of decays with pollutants as keys and decay\n                parameters (a constant and a temperature sensitivity exponent) as\n                values. _Units_: -\n        \"\"\"\n        self.residence_time = residence_time\n        self.infiltration_threshold = infiltration_threshold\n        self.infiltration_pct = infiltration_pct\n        # TODO not used data_input\n        self.data_input_dict = data_input_dict\n        super().__init__(**kwargs)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        residence_time, infiltration_threshold, infiltration_pct.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.residence_time = overrides.pop(\"residence_time\", self.residence_time)\n        self.infiltration_threshold = overrides.pop(\n            \"infiltration_threshold\", self.infiltration_threshold\n        )\n        self.infiltration_pct = overrides.pop(\"infiltration_pct\", self.infiltration_pct)\n        super().apply_overrides(overrides)\n\n    def distribute(self):\n        \"\"\"Calculate outflow with residence time and send to Nodes or Rivers.\"\"\"\n        avail = self.tank.get_avail()[\"volume\"] / self.residence_time\n        to_send = self.tank.pull_storage({\"volume\": avail})\n        retained = self.push_distributed(to_send, of_type=[\"Node\", \"River\", \"Waste\"])\n        _ = self.tank.push_storage(retained, force=True)\n        if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"Storage unable to push\")\n\n    def infiltrate(self):\n        \"\"\"Calculate amount of water available for infiltration and send to sewers.\"\"\"\n        # Calculate infiltration\n        avail = self.tank.get_avail()[\"volume\"]\n        avail = max(avail - self.tank.capacity * self.infiltration_threshold, 0)\n        avail = (avail * self.infiltration_pct) ** 0.5\n\n        # Push to sewers\n        to_send = self.tank.pull_storage({\"volume\": avail})\n        retained = self.push_distributed(to_send, of_type=\"Sewer\")\n        _ = self.tank.push_storage(retained, force=True)\n        # Any not sent is left in tank\n        if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            # print('unable to infiltrate')\n            pass\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Groundwater.__init__","title":"<code>__init__(residence_time=200, infiltration_threshold=1, infiltration_pct=0, data_input_dict={}, **kwargs)</code>","text":"<p>A storage with a residence time for groundwater. Can also infiltrate to sewers.</p> <p>Parameters:</p> Name Type Description Default <code>residence_time</code> <code>float</code> <p>Residence time (see nodes.py/ ResidenceTank). Defaults to 200.</p> <code>200</code> <code>infiltration_threshold</code> <code>float</code> <p>Proportion of storage capacity that must be exceeded to generate infiltration. Defaults to 1.</p> <code>1</code> <code>infiltration_pct</code> <code>float</code> <p>Proportion of storage above the threshold that is square rooted and infiltrated. Defaults to 0.</p> <code>0</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (though I don't think it is used). Defaults to {}.</p> <code>{}</code> Functions intended to call in orchestration <p>infiltrate (before sewers are discharged)</p> <p>distribute</p> Key assumptions <ul> <li>Conceptualises groundwater as a tank.</li> <li>Baseflow is generated following a residence-time method.</li> <li>Baseflow is sent to <code>storage.py/River</code>, <code>nodes.py/Node</code> or     <code>waste.py/Waste</code> nodes.</li> <li>Infiltration to <code>sewer.py/Sewer</code> nodes occurs when the storage     in the tank is greater than a specified threshold, at a rate     proportional to the sqrt of volume above the threshold. (Note, this     behaviour is not validated and a high uncertainty process in     general)</li> <li>If <code>decays</code> are provided to model water quality transformations,     see <code>core.py/DecayObj</code>.</li> </ul> Input data and parameter requirements <ul> <li>Groundwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> <li>Infiltration behaviour determined by an <code>infiltration_threshold</code>     and <code>infiltration_pct</code>. Units: proportion of capacity</li> <li>Optional dictionary of decays with pollutants as keys and decay     parameters (a constant and a temperature sensitivity exponent) as     values. Units: -</li> </ul> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def __init__(\n    self,\n    residence_time=200,\n    infiltration_threshold=1,\n    infiltration_pct=0,\n    data_input_dict={},\n    **kwargs,\n):\n    # TODO why isn't this using a ResidenceTank?\n    \"\"\"A storage with a residence time for groundwater. Can also infiltrate to\n    sewers.\n\n    Args:\n        residence_time (float, optional): Residence time (see nodes.py/\n            ResidenceTank). Defaults to 200.\n        infiltration_threshold (float, optional): Proportion of storage capacity\n            that must be exceeded to generate infiltration. Defaults to 1.\n        infiltration_pct (float, optional): Proportion of storage above the\n            threshold that is square rooted and infiltrated. Defaults to 0.\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node (though I don't think it is used). Defaults to {}.\n\n    Functions intended to call in orchestration:\n        infiltrate (before sewers are discharged)\n\n        distribute\n\n    Key assumptions:\n        - Conceptualises groundwater as a tank.\n        - Baseflow is generated following a residence-time method.\n        - Baseflow is sent to `storage.py/River`, `nodes.py/Node` or\n            `waste.py/Waste` nodes.\n        - Infiltration to `sewer.py/Sewer` nodes occurs when the storage\n            in the tank is greater than a specified threshold, at a rate\n            proportional to the sqrt of volume above the threshold. (Note, this\n            behaviour is __not validated__ and a high uncertainty process in\n            general)\n        - If `decays` are provided to model water quality transformations,\n            see `core.py/DecayObj`.\n\n    Input data and parameter requirements:\n        - Groundwater tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n        - Infiltration behaviour determined by an `infiltration_threshold`\n            and `infiltration_pct`. _Units_: proportion of capacity\n        - Optional dictionary of decays with pollutants as keys and decay\n            parameters (a constant and a temperature sensitivity exponent) as\n            values. _Units_: -\n    \"\"\"\n    self.residence_time = residence_time\n    self.infiltration_threshold = infiltration_threshold\n    self.infiltration_pct = infiltration_pct\n    # TODO not used data_input\n    self.data_input_dict = data_input_dict\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Groundwater.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: residence_time, infiltration_threshold, infiltration_pct.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    residence_time, infiltration_threshold, infiltration_pct.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.residence_time = overrides.pop(\"residence_time\", self.residence_time)\n    self.infiltration_threshold = overrides.pop(\n        \"infiltration_threshold\", self.infiltration_threshold\n    )\n    self.infiltration_pct = overrides.pop(\"infiltration_pct\", self.infiltration_pct)\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Groundwater.distribute","title":"<code>distribute()</code>","text":"<p>Calculate outflow with residence time and send to Nodes or Rivers.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def distribute(self):\n    \"\"\"Calculate outflow with residence time and send to Nodes or Rivers.\"\"\"\n    avail = self.tank.get_avail()[\"volume\"] / self.residence_time\n    to_send = self.tank.pull_storage({\"volume\": avail})\n    retained = self.push_distributed(to_send, of_type=[\"Node\", \"River\", \"Waste\"])\n    _ = self.tank.push_storage(retained, force=True)\n    if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"Storage unable to push\")\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Groundwater.infiltrate","title":"<code>infiltrate()</code>","text":"<p>Calculate amount of water available for infiltration and send to sewers.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def infiltrate(self):\n    \"\"\"Calculate amount of water available for infiltration and send to sewers.\"\"\"\n    # Calculate infiltration\n    avail = self.tank.get_avail()[\"volume\"]\n    avail = max(avail - self.tank.capacity * self.infiltration_threshold, 0)\n    avail = (avail * self.infiltration_pct) ** 0.5\n\n    # Push to sewers\n    to_send = self.tank.pull_storage({\"volume\": avail})\n    retained = self.push_distributed(to_send, of_type=\"Sewer\")\n    _ = self.tank.push_storage(retained, force=True)\n    # Any not sent is left in tank\n    if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        # print('unable to infiltrate')\n        pass\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater","title":"<code>QueueGroundwater</code>","text":"<p>               Bases: <code>Storage</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class QueueGroundwater(Storage):\n    \"\"\"\"\"\"\n\n    # TODO - no infiltration as yet\n    def __init__(self, timearea={0: 1}, data_input_dict={}, **kwargs):\n        \"\"\"Alternate formulation of Groundwater that uses a timearea property to enable\n        more nonlinear time behaviour of baseflow routing. Uses the QueueTank or\n        DecayQueueTank (see nodes.py/Tank subclassses).\n\n        NOTE: abstraction behaviour from this kind of node need careful checking\n\n        Args:\n            timearea (dict, optional): Time area diagram that enables flows to\n                take a range of different durations to 'traverse' the tank. The keys of\n                the dict are the number of timesteps while the values are the proportion\n                of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes 0 timesteps\n                and 30% takes 1 timesteps. Defaults to {0 : 1}.\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node (though I don't think it is used). Defaults to {}.\n\n        Functions intended to call in orchestration:\n            distribute\n\n        Key assumptions:\n            - Conceptualises groundwater as a tank.\n            - Baseflow is generated following a timearea method.\n            - Baseflow is sent to `storage.py/River`, `nodes.py/Node` or\n                `waste.py/Waste` nodes.\n            - No infiltration to sewers is modelled.\n            - If `decays` are provided to model water quality transformations,\n                see `core.py/DecayObj`.\n\n        Input data and parameter requirements:\n            - Groundwater tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n            - `timearea` is a dictionary containing the timearea diagram.\n                _Units_: duration of flow (in timesteps) and proportion of flow\n            - Optional dictionary of decays with pollutants as keys and decay\n                parameters (a constant and a temperature sensitivity exponent) as\n                values. _Units_: -\n        \"\"\"\n        self.timearea = timearea\n        # TODO not used\n        self.data_input_dict = data_input_dict\n        super().__init__(**kwargs)\n        # Label as Groundwater class so that other nodes treat it the same\n        self.__class__.__name__ = \"Groundwater\"\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_timearea\n        self.pull_set_handler[\"default\"] = self.pull_set_active\n        self.pull_check_handler[\"default\"] = self.pull_check_active\n        # Enable decay\n        if self.decays is None:\n            self.tank = QueueTank(\n                capacity=self.capacity,\n                area=self.area,\n                datum=self.datum,\n                initial_storage=self.initial_storage,\n            )\n        else:\n            self.tank = DecayQueueTank(\n                capacity=self.capacity,\n                area=self.area,\n                datum=self.datum,\n                decays=self.decays,\n                parent=self,\n                initial_storage=self.initial_storage,\n            )\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        timearea.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.timearea = overrides.pop(\"timearea\", self.timearea)\n        super().apply_overrides(overrides)\n\n    def push_set_timearea(self, vqip):\n        \"\"\"Push setting that enables timearea behaviour, (see __init__ for\n        description).Used to receive flow that is assumed to occur widely across some\n        kind of catchment.\n\n        Args:\n            vqip (dict): A VQIP that has been pushed\n\n        Returns:\n            reply (dict): A VQIP amount that was not successfuly receivesd\n        \"\"\"\n        reply = self.empty_vqip()\n        # Iterate over timearea diagram TODO timearea diagram behaviour be generalised\n        # across nodes\n        for time, normalised in self.timearea.items():\n            vqip_ = self.v_change_vqip(vqip, vqip[\"volume\"] * normalised)\n            reply_ = self.tank.push_storage(vqip_, time=time)\n            reply = self.sum_vqip(reply, reply_)\n        return reply\n\n    def distribute(self):\n        \"\"\"Update internal arc, push active_storage onwards, update tank.\"\"\"\n        _ = self.tank.internal_arc.update_queue(direction=\"push\")\n\n        remaining = self.push_distributed(self.tank.active_storage)\n\n        if remaining[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"Groundwater couldnt push all\")\n\n        # Update tank\n        sent = self.tank.active_storage[\"volume\"] - remaining[\"volume\"]\n        sent = self.v_change_vqip(self.tank.active_storage, sent)\n        reply = self.tank.pull_storage(sent)\n        if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n            print(\"Miscalculated tank storage in discharge\")\n\n    def infiltrate(self):\n        \"\"\"\"\"\"\n        pass\n\n    def pull_check_active(self, vqip=None):\n        \"\"\"A pull check that returns the active storage.\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            (dict): A VQIP amount that is available to pull\n        \"\"\"\n        if vqip is None:\n            return self.tank.active_storage\n        else:\n            reply = min(vqip[\"volume\"], self.tank.active_storage[\"volume\"])\n            return self.v_change_vqip(self.tank.active_storage, reply)\n\n    def pull_set_active(self, vqip):\n        # TODO - this is quite weird behaviour, and inconsistent with pull_check_active\n        \"\"\"Pull proportionately from both the active storage and the queue. Adjudging\n        groundwater abstractions to not be particularly sensitive to the within\n        catchment travel time.\n\n        Args:\n            vqip (dict): A VQIP amount to be pulled (only volume key is used)\n\n        Returns:\n            pulled (dict): A VQIP amount that was successfully pulled\n        \"\"\"\n        # Calculate actual pull\n        total_storage = self.tank.storage[\"volume\"]\n        total_pull = min(self.tank.storage[\"volume\"], vqip[\"volume\"])\n\n        if total_pull &lt; constants.FLOAT_ACCURACY:\n            return self.empty_vqip()\n        else:\n            # Track total pull in pulled\n            pulled = self.empty_vqip()\n            # Iterate over queue\n            if isinstance(self.tank.internal_arc.queue, dict):\n                for t, v in self.tank.internal_arc.queue.items():\n                    # Pull proportionately\n                    t_pulled = self.v_change_vqip(\n                        self.tank.internal_arc.queue[t],\n                        v[\"volume\"] * total_pull / total_storage,\n                    )\n                    # Reduce queue VQIPs\n                    self.tank.internal_arc.queue[t] = self.extract_vqip(\n                        self.tank.internal_arc.queue[t], t_pulled\n                    )\n                    # Track pull\n                    pulled = self.sum_vqip(pulled, t_pulled)\n                # Pull also from active storage\n                a_pulled = self.v_change_vqip(\n                    self.tank.active_storage,\n                    self.tank.active_storage[\"volume\"] * total_pull / total_storage,\n                )\n                self.tank.active_storage = self.extract_vqip(\n                    self.tank.active_storage, a_pulled\n                )\n                pulled = self.sum_vqip(pulled, a_pulled)\n\n                # Recalculate storage\n                self.tank.storage = self.extract_vqip(self.tank.storage, pulled)\n                return pulled\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.__init__","title":"<code>__init__(timearea={0: 1}, data_input_dict={}, **kwargs)</code>","text":"<p>Alternate formulation of Groundwater that uses a timearea property to enable more nonlinear time behaviour of baseflow routing. Uses the QueueTank or DecayQueueTank (see nodes.py/Tank subclassses).</p> <p>NOTE: abstraction behaviour from this kind of node need careful checking</p> <p>Parameters:</p> Name Type Description Default <code>timearea</code> <code>dict</code> <p>Time area diagram that enables flows to take a range of different durations to 'traverse' the tank. The keys of the dict are the number of timesteps while the values are the proportion of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes 0 timesteps and 30% takes 1 timesteps. Defaults to {0 : 1}.</p> <code>{0: 1}</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (though I don't think it is used). Defaults to {}.</p> <code>{}</code> Functions intended to call in orchestration <p>distribute</p> Key assumptions <ul> <li>Conceptualises groundwater as a tank.</li> <li>Baseflow is generated following a timearea method.</li> <li>Baseflow is sent to <code>storage.py/River</code>, <code>nodes.py/Node</code> or     <code>waste.py/Waste</code> nodes.</li> <li>No infiltration to sewers is modelled.</li> <li>If <code>decays</code> are provided to model water quality transformations,     see <code>core.py/DecayObj</code>.</li> </ul> Input data and parameter requirements <ul> <li>Groundwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> <li><code>timearea</code> is a dictionary containing the timearea diagram.     Units: duration of flow (in timesteps) and proportion of flow</li> <li>Optional dictionary of decays with pollutants as keys and decay     parameters (a constant and a temperature sensitivity exponent) as     values. Units: -</li> </ul> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def __init__(self, timearea={0: 1}, data_input_dict={}, **kwargs):\n    \"\"\"Alternate formulation of Groundwater that uses a timearea property to enable\n    more nonlinear time behaviour of baseflow routing. Uses the QueueTank or\n    DecayQueueTank (see nodes.py/Tank subclassses).\n\n    NOTE: abstraction behaviour from this kind of node need careful checking\n\n    Args:\n        timearea (dict, optional): Time area diagram that enables flows to\n            take a range of different durations to 'traverse' the tank. The keys of\n            the dict are the number of timesteps while the values are the proportion\n            of flow. E.g., {0 : 0.7, 1 : 0.3} means 70% of flow takes 0 timesteps\n            and 30% takes 1 timesteps. Defaults to {0 : 1}.\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node (though I don't think it is used). Defaults to {}.\n\n    Functions intended to call in orchestration:\n        distribute\n\n    Key assumptions:\n        - Conceptualises groundwater as a tank.\n        - Baseflow is generated following a timearea method.\n        - Baseflow is sent to `storage.py/River`, `nodes.py/Node` or\n            `waste.py/Waste` nodes.\n        - No infiltration to sewers is modelled.\n        - If `decays` are provided to model water quality transformations,\n            see `core.py/DecayObj`.\n\n    Input data and parameter requirements:\n        - Groundwater tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n        - `timearea` is a dictionary containing the timearea diagram.\n            _Units_: duration of flow (in timesteps) and proportion of flow\n        - Optional dictionary of decays with pollutants as keys and decay\n            parameters (a constant and a temperature sensitivity exponent) as\n            values. _Units_: -\n    \"\"\"\n    self.timearea = timearea\n    # TODO not used\n    self.data_input_dict = data_input_dict\n    super().__init__(**kwargs)\n    # Label as Groundwater class so that other nodes treat it the same\n    self.__class__.__name__ = \"Groundwater\"\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_timearea\n    self.pull_set_handler[\"default\"] = self.pull_set_active\n    self.pull_check_handler[\"default\"] = self.pull_check_active\n    # Enable decay\n    if self.decays is None:\n        self.tank = QueueTank(\n            capacity=self.capacity,\n            area=self.area,\n            datum=self.datum,\n            initial_storage=self.initial_storage,\n        )\n    else:\n        self.tank = DecayQueueTank(\n            capacity=self.capacity,\n            area=self.area,\n            datum=self.datum,\n            decays=self.decays,\n            parent=self,\n            initial_storage=self.initial_storage,\n        )\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: timearea.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    timearea.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.timearea = overrides.pop(\"timearea\", self.timearea)\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.distribute","title":"<code>distribute()</code>","text":"<p>Update internal arc, push active_storage onwards, update tank.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def distribute(self):\n    \"\"\"Update internal arc, push active_storage onwards, update tank.\"\"\"\n    _ = self.tank.internal_arc.update_queue(direction=\"push\")\n\n    remaining = self.push_distributed(self.tank.active_storage)\n\n    if remaining[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"Groundwater couldnt push all\")\n\n    # Update tank\n    sent = self.tank.active_storage[\"volume\"] - remaining[\"volume\"]\n    sent = self.v_change_vqip(self.tank.active_storage, sent)\n    reply = self.tank.pull_storage(sent)\n    if (reply[\"volume\"] - sent[\"volume\"]) &gt; constants.FLOAT_ACCURACY:\n        print(\"Miscalculated tank storage in discharge\")\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.infiltrate","title":"<code>infiltrate()</code>","text":"Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def infiltrate(self):\n    \"\"\"\"\"\"\n    pass\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.pull_check_active","title":"<code>pull_check_active(vqip=None)</code>","text":"<p>A pull check that returns the active storage.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount that is available to pull</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def pull_check_active(self, vqip=None):\n    \"\"\"A pull check that returns the active storage.\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        (dict): A VQIP amount that is available to pull\n    \"\"\"\n    if vqip is None:\n        return self.tank.active_storage\n    else:\n        reply = min(vqip[\"volume\"], self.tank.active_storage[\"volume\"])\n        return self.v_change_vqip(self.tank.active_storage, reply)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.pull_set_active","title":"<code>pull_set_active(vqip)</code>","text":"<p>Pull proportionately from both the active storage and the queue. Adjudging groundwater abstractions to not be particularly sensitive to the within catchment travel time.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be pulled (only volume key is used)</p> required <p>Returns:</p> Name Type Description <code>pulled</code> <code>dict</code> <p>A VQIP amount that was successfully pulled</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def pull_set_active(self, vqip):\n    # TODO - this is quite weird behaviour, and inconsistent with pull_check_active\n    \"\"\"Pull proportionately from both the active storage and the queue. Adjudging\n    groundwater abstractions to not be particularly sensitive to the within\n    catchment travel time.\n\n    Args:\n        vqip (dict): A VQIP amount to be pulled (only volume key is used)\n\n    Returns:\n        pulled (dict): A VQIP amount that was successfully pulled\n    \"\"\"\n    # Calculate actual pull\n    total_storage = self.tank.storage[\"volume\"]\n    total_pull = min(self.tank.storage[\"volume\"], vqip[\"volume\"])\n\n    if total_pull &lt; constants.FLOAT_ACCURACY:\n        return self.empty_vqip()\n    else:\n        # Track total pull in pulled\n        pulled = self.empty_vqip()\n        # Iterate over queue\n        if isinstance(self.tank.internal_arc.queue, dict):\n            for t, v in self.tank.internal_arc.queue.items():\n                # Pull proportionately\n                t_pulled = self.v_change_vqip(\n                    self.tank.internal_arc.queue[t],\n                    v[\"volume\"] * total_pull / total_storage,\n                )\n                # Reduce queue VQIPs\n                self.tank.internal_arc.queue[t] = self.extract_vqip(\n                    self.tank.internal_arc.queue[t], t_pulled\n                )\n                # Track pull\n                pulled = self.sum_vqip(pulled, t_pulled)\n            # Pull also from active storage\n            a_pulled = self.v_change_vqip(\n                self.tank.active_storage,\n                self.tank.active_storage[\"volume\"] * total_pull / total_storage,\n            )\n            self.tank.active_storage = self.extract_vqip(\n                self.tank.active_storage, a_pulled\n            )\n            pulled = self.sum_vqip(pulled, a_pulled)\n\n            # Recalculate storage\n            self.tank.storage = self.extract_vqip(self.tank.storage, pulled)\n            return pulled\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.QueueGroundwater.push_set_timearea","title":"<code>push_set_timearea(vqip)</code>","text":"<p>Push setting that enables timearea behaviour, (see init for description).Used to receive flow that is assumed to occur widely across some kind of catchment.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that has been pushed</p> required <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>A VQIP amount that was not successfuly receivesd</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def push_set_timearea(self, vqip):\n    \"\"\"Push setting that enables timearea behaviour, (see __init__ for\n    description).Used to receive flow that is assumed to occur widely across some\n    kind of catchment.\n\n    Args:\n        vqip (dict): A VQIP that has been pushed\n\n    Returns:\n        reply (dict): A VQIP amount that was not successfuly receivesd\n    \"\"\"\n    reply = self.empty_vqip()\n    # Iterate over timearea diagram TODO timearea diagram behaviour be generalised\n    # across nodes\n    for time, normalised in self.timearea.items():\n        vqip_ = self.v_change_vqip(vqip, vqip[\"volume\"] * normalised)\n        reply_ = self.tank.push_storage(vqip_, time=time)\n        reply = self.sum_vqip(reply, reply_)\n    return reply\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Reservoir","title":"<code>Reservoir</code>","text":"<p>               Bases: <code>Storage</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class Reservoir(Storage):\n    \"\"\"\"\"\"\n\n    def __init__(self, **kwargs):\n        \"\"\"Storage node that makes abstractions by calling pull_distributed.\n\n        Functions intended to call in orchestration:\n            make_abstractions (before any river routing)\n\n        Key assumptions:\n            - Conceptualised as a `Tank`.\n            - Recharged only via pumped abstractions.\n            - Evaporation/precipitation onto surface area currently ignored.\n            - If `decays` are provided to model water quality transformations,\n                see `core.py/DecayObj`.\n\n        Input data and parameter requirements:\n            - Tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n            - Optional dictionary of decays with pollutants as keys and decay\n                parameters (a constant and a temperature sensitivity exponent) as\n                values. _Units_: -\n        \"\"\"\n        super().__init__(**kwargs)\n\n    def make_abstractions(self):\n        \"\"\"Pulls water and updates tanks.\"\"\"\n        reply = self.pull_distributed(self.tank.get_excess())\n        spill = self.tank.push_storage(reply)\n        _ = self.tank.push_storage(spill, force=True)\n        if spill[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"Spill at reservoir by {0}\".format(spill[\"volume\"]))\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Reservoir.__init__","title":"<code>__init__(**kwargs)</code>","text":"<p>Storage node that makes abstractions by calling pull_distributed.</p> Functions intended to call in orchestration <p>make_abstractions (before any river routing)</p> Key assumptions <ul> <li>Conceptualised as a <code>Tank</code>.</li> <li>Recharged only via pumped abstractions.</li> <li>Evaporation/precipitation onto surface area currently ignored.</li> <li>If <code>decays</code> are provided to model water quality transformations,     see <code>core.py/DecayObj</code>.</li> </ul> Input data and parameter requirements <ul> <li>Tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> <li>Optional dictionary of decays with pollutants as keys and decay     parameters (a constant and a temperature sensitivity exponent) as     values. Units: -</li> </ul> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def __init__(self, **kwargs):\n    \"\"\"Storage node that makes abstractions by calling pull_distributed.\n\n    Functions intended to call in orchestration:\n        make_abstractions (before any river routing)\n\n    Key assumptions:\n        - Conceptualised as a `Tank`.\n        - Recharged only via pumped abstractions.\n        - Evaporation/precipitation onto surface area currently ignored.\n        - If `decays` are provided to model water quality transformations,\n            see `core.py/DecayObj`.\n\n    Input data and parameter requirements:\n        - Tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n        - Optional dictionary of decays with pollutants as keys and decay\n            parameters (a constant and a temperature sensitivity exponent) as\n            values. _Units_: -\n    \"\"\"\n    super().__init__(**kwargs)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Reservoir.make_abstractions","title":"<code>make_abstractions()</code>","text":"<p>Pulls water and updates tanks.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def make_abstractions(self):\n    \"\"\"Pulls water and updates tanks.\"\"\"\n    reply = self.pull_distributed(self.tank.get_excess())\n    spill = self.tank.push_storage(reply)\n    _ = self.tank.push_storage(spill, force=True)\n    if spill[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"Spill at reservoir by {0}\".format(spill[\"volume\"]))\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River","title":"<code>River</code>","text":"<p>               Bases: <code>Storage</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class River(Storage):\n    \"\"\"\"\"\"\n\n    # TODO non-day timestep\n    def __init__(\n        self,\n        depth=2,\n        length=200,\n        width=20,\n        velocity=0.2 * constants.M_S_TO_M_DT,\n        damp=0.1,\n        mrf=0,\n        **kwargs,\n    ):\n        \"\"\"Node that contains extensive in-river biochemical processes.\n\n        Args:\n            depth (float, optional): River tank depth. Defaults to 2. length (float,\n            optional): River tank length. Defaults to 200. width (float, optional):\n            River tank width. Defaults to 20. velocity (float, optional): River velocity\n            (if someone wants to calculate\n                this on the fly that would also work). Defaults to\n                0.2*constants.M_S_TO_M_DT.\n            damp (float, optional): Flow delay and attentuation parameter. Defaults\n                to 0.1.\n            mrf (float, optional): Minimum required flow in river (volume per timestep),\n                can limit pulls made to the river. Defaults to 0.\n\n        Functions intended to call in orchestration:\n            distribute\n\n        Key assumptions:\n             - River is conceptualised as a water tank that receives flows from various\n                sources (e.g., runoffs from urban and rural land, baseflow from\n                groundwater), interacts with water infrastructure (e.g., abstraction for\n                irrigation and domestic supply, sewage and treated effluent discharge),\n                and discharges flows downstream. It has length and width as shape\n                parameters, average velocity to indicate flow speed and capacity to\n                indicate the maximum storage limit.\n             - Flows from different sources into rivers will fully mix. River tank is\n               assumed to\n                have delay and attenuation effects when generate outflows. These effects\n                are simulated based on the average velocity.\n             - In-river biochemical processes are simulated as sources/sinks of\n               nutrients\n                in the river tank, including - denitrification (for nitrogen) -\n                phytoplankton absorption/release (for nitrogen and phosphorus) -\n                macrophyte uptake (for nitrogen and phosphorus) These processes are\n                affected by river temperature.\n\n        Input data and parameter requirements:\n             - depth, length, width\n                _Units_: m\n             - velocity\n                _Units_: m/day\n             - damping coefficient\n                _Units_: -\n             - minimum required flow\n                _Units_: m3/day\n        \"\"\"\n        # Set parameters\n        self.depth = depth\n        if depth != 2:\n            warnings.warn(\n                \"warning: the depth parameter is unused by River nodes because it is \\\n\t\tintended for capacity to be unbounded. It may be removed in a future version.\"\n            )\n        self.length = length  # [m]\n        self.width = width  # [m]\n        self.velocity = velocity  # [m/dt]\n        self.damp = damp  # [&gt;=0] flow delay and attenuation\n        self.mrf = mrf\n        area = length * width  # [m2]\n\n        capacity = (\n            constants.UNBOUNDED_CAPACITY\n        )  # TODO might be depth * area if flood indunation is going to be simulated\n\n        # Required in cases where 'area' conflicts with length*width\n        kwargs[\"area\"] = area\n        # Required in cases where 'capacity' conflicts with depth*area\n        kwargs[\"capacity\"] = capacity\n\n        super().__init__(**kwargs)\n\n        # TODO check units TODO Will a user want to change any of these? Wide variety of\n        # river parameters (from HYPE)\n        self.uptake_PNratio = 1 / 7.2  # [-] P:N during crop uptake\n        self.bulk_density = 1300  # [kg/m3] soil density\n        self.denpar_w = 0.0015  # 0.001, # [kg/m2/day] reference denitrification rate\n        # in water course\n        self.T_wdays = 5  # [days] weighting constant for river temperature calculation\n        # (similar to moving average period)\n        self.halfsatINwater = (\n            1.5 * constants.MG_L_TO_KG_M3\n        )  # [kg/m3] half saturation parameter for denitrification in river\n        self.T_10_days = []  # [degree C] average water temperature of 10 days\n        self.T_20_days = []  # [degree C] average water temperature of 20 days\n        self.TP_365_days = []  # [degree C] average water temperature of 20 days\n        self.hsatTP = 0.05 * constants.MG_L_TO_KG_M3  # [kg/m3]\n        self.limpppar = 0.1 * constants.MG_L_TO_KG_M3  # [kg/m3]\n        self.prodNpar = 0.001  # [kg N/m3/day] nitrogen production/mineralisation rate\n        self.prodPpar = (\n            0.0001  # [kg N/m3/day] phosphorus production/mineralisation rate\n        )\n        self.muptNpar = 0.001  # [kg/m2/day] nitrogen macrophyte uptake rate\n        self.muptPpar = 0.0001  # 0.01, # [kg/m2/day] phosphorus macrophyte uptake rate\n\n        self.max_temp_lag = 20\n        self.lagged_temperatures = []\n\n        self.max_phosphorus_lag = 365\n        self.lagged_total_phosphorus = []\n\n        self.din_components = [\"ammonia\", \"nitrate\"]\n        # TODO need a cleaner way to do this depending on whether e.g., nitrite is\n        # included\n\n        # Initialise paramters\n        self.current_depth = 0  # [m]\n        # self.river_temperature = 0 # [degree C] self.river_denitrification = 0 #\n        # [kg/day] self.macrophyte_uptake_N = 0 # [kg/day] self.macrophyte_uptake_P = 0\n        # # [kg/day] self.sediment_particulate_phosphorus_pool = 60000 # [kg]\n        # self.sediment_pool = 1000000 # [kg] self.benthos_source_sink = 0 # [kg/day]\n        # self.t_res = 0 # [day] self.outflow = self.empty_vqip()\n\n        # Update end_teimstep\n        self.end_timestep = self.end_timestep_\n\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_river\n        self.push_check_handler[\"default\"] = self.push_check_accept\n\n        self.pull_check_handler[\"default\"] = self.pull_check_river\n        self.pull_set_handler[\"default\"] = self.pull_set_river\n\n        # TODO - RiparianBuffer\n        self.pull_check_handler[(\"RiparianBuffer\", \"volume\")] = self.pull_check_fp\n\n        # Update mass balance\n        self.bio_in = self.empty_vqip()\n        self.bio_out = self.empty_vqip()\n\n        self.mass_balance_in.append(lambda: self.bio_in)\n        self.mass_balance_out.append(lambda: self.bio_out)\n\n    # TODO something like this might be needed if you want sewers backing up from river\n    # height... would need to incorporate expected river outflow def get_dt_excess(self,\n    #     vqip = None): reply = self.empty_vqip() reply['volume'] =\n    #     self.tank.get_excess()['volume'] + self.tank.get_avail()['volume'] *\n    #     self.get_riverrc() if vqip is not None: reply['volume'] = min(vqip['volume'],\n    #         reply['volume']) return reply\n\n    # def push_set_river(self, vqip): vqip_ = vqip.copy() vqip_ =\n    #     self.v_change_vqip(vqip_, min(vqip_['volume'],\n    #     self.get_dt_excess()['volume'])) _ = self.tank.push_storage(vqip_, force=True)\n    #     return self.extract_vqip(vqip, vqip_)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        timearea.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        overwrite_params = set(\n            [\n                \"length\",\n                \"width\",\n                \"velocity\",\n                \"damp\",\n                \"mrf\",\n                \"uptake_PNratio\",\n                \"bulk_density\",\n                \"denpar_w\",\n                \"T_wdays\",\n                \"halfsatINwater\",\n                \"hsatTP\",\n                \"limpppar\",\n                \"prodNpar\",\n                \"prodPpar\",\n                \"muptNpar\",\n                \"muptPpar\",\n                \"max_temp_lag\",\n                \"max_phosphorus_lag\",\n            ]\n        )\n\n        for param in overwrite_params.intersection(overrides.keys()):\n            setattr(self, param, overrides.pop(param))\n\n        if \"area\" in overrides.keys():\n            warnings.warn(\n                \"WARNING: specifying area is depreciated in overrides \\\n\t\tfor river, please specify length and width instead\"\n            )\n        overrides[\"area\"] = self.length * self.width\n        if \"capacity\" in overrides.keys():\n            warnings.warn(\n                \"ERROR: specifying capacity is depreciated in overrides \\\n\t\tfor river, it is always set as unbounded capacity\"\n            )\n        overrides[\"capacity\"] = constants.UNBOUNDED_CAPACITY\n        super().apply_overrides(overrides)\n\n    def pull_check_river(self, vqip=None):\n        \"\"\"Check amount of water that can be pulled from river tank and upstream.\n\n        Args:\n            vqip (dict, optional): Maximum water required (only 'volume' is used)\n\n        Returns:\n            avail (dict): A VQIP amount that can be pulled\n        \"\"\"\n        # Get storage\n        avail = self.tank.get_avail()\n\n        # Check incoming\n        upstream = self.get_connected(direction=\"pull\", of_type=[\"River\", \"Node\"])\n        avail[\"volume\"] += upstream[\"avail\"]\n\n        # convert mrf from volume/timestep to discrete value\n        mrf = self.mrf / self.get_riverrc()\n\n        # Apply mrf\n        avail_vol = max(avail[\"volume\"] - mrf, 0)\n        if vqip is None:\n            avail = self.v_change_vqip(avail, avail_vol)\n        else:\n            avail = self.v_change_vqip(avail, min(avail_vol, vqip[\"volume\"]))\n\n        return avail\n\n    def pull_set_river(self, vqip):\n        \"\"\"Pull from river tank and upstream, acknowledging MRF with pull_check.\n\n        Args:\n            vqip (dict): A VQIP amount to pull (only volume key used)\n\n        Returns:\n            (dict): A VQIP amount that was pulled\n        \"\"\"\n        # Calculate available pull\n        avail = self.pull_check_river(vqip)\n\n        # Take first from tank\n        pulled = self.tank.pull_storage(avail)\n\n        # Take remaining from upstream\n        to_pull = {\"volume\": avail[\"volume\"] - pulled[\"volume\"]}\n        pulled_ = self.pull_distributed(to_pull, of_type=[\"River\", \"Node\"])\n\n        reply = self.sum_vqip(pulled, pulled_)\n\n        return reply\n\n    def push_set_river(self, vqip):\n        \"\"\"Push to river tank, currently forced.\n\n        Args:\n            vqip (dict): A VQIP amount to push\n\n        Returns:\n            (dict): A VQIP amount that was not successfully received\n        \"\"\"\n        _ = self.tank.push_storage(vqip, force=True)\n        return self.empty_vqip()\n\n    def update_depth(self):\n        \"\"\"Recalculate depth.\"\"\"\n        self.current_depth = self.tank.storage[\"volume\"] / self.area\n\n    def get_din_pool(self):\n        \"\"\"Get total dissolved inorganic nitrogen from tank storage.\n\n        Returns:\n            (float): total din\n        \"\"\"\n        return sum(\n            [self.tank.storage[x] for x in self.din_components]\n        )  # TODO + self.tank.storage['nitrite'] but nitrite might not be modelled...\n        # need some ways to address this\n\n    def biochemical_processes(self):\n        \"\"\"Runs all biochemical processes and updates pollutant amounts.\n\n        Returns:\n            in_ (dict): A VQIP amount that represents total gain in pollutant amounts\n            out_ (dict): A VQIP amount that represents total loss in pollutant amounts\n        \"\"\"\n        # TODO make more modular\n        self.update_depth()\n\n        self.tank.storage[\"temperature\"] = (1 - 1 / self.T_wdays) * self.tank.storage[\n            \"temperature\"\n        ] + (1 / self.T_wdays) * self.get_data_input(\"temperature\")\n\n        # Update lagged temperatures\n        if len(self.lagged_temperatures) &gt; self.max_temp_lag:\n            del self.lagged_temperatures[0]\n        self.lagged_temperatures.append(self.tank.storage[\"temperature\"])\n\n        # Update lagged total phosphorus\n        if len(self.lagged_total_phosphorus) &gt; self.max_phosphorus_lag:\n            del self.lagged_total_phosphorus[0]\n        total_phosphorus = (\n            self.tank.storage[\"phosphate\"] + self.tank.storage[\"org-phosphorus\"]\n        )\n        self.lagged_total_phosphorus.append(total_phosphorus)\n\n        # Check if any water\n        if self.tank.storage[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n            # Assume these only do something when there is water\n            return (self.empty_vqip(), self.empty_vqip())\n\n        if self.tank.storage[\"temperature\"] &lt;= 0:\n            # Seems that these things are only active when above freezing\n            return (self.empty_vqip(), self.empty_vqip())\n\n        # Denitrification\n        tempfcn = 2 ** ((self.tank.storage[\"temperature\"] - 20) / 10)\n        if self.tank.storage[\"temperature\"] &lt; 5:\n            tempfcn *= self.tank.storage[\"temperature\"] / 5\n\n        din = self.get_din_pool()\n        din_concentration = din / self.tank.storage[\"volume\"]\n        confcn = din_concentration / (\n            din_concentration + self.halfsatINwater\n        )  # [kg/m3]\n        denitri_water = (\n            self.denpar_w * self.area * tempfcn * confcn\n        )  # [kg/day] #TODO convert to per DT\n\n        river_denitrification = min(\n            denitri_water, 0.5 * din\n        )  # [kg/day] max 50% kan be denitrified\n        din_ = din - river_denitrification  # [kg]\n\n        # Update mass balance\n        in_ = self.empty_vqip()\n        out_ = self.empty_vqip()\n        if din &gt; 0:\n            for pol in self.din_components:\n                # denitrification\n                loss = (din - din_) / din * self.tank.storage[pol]\n                out_[pol] += loss\n                self.tank.storage[pol] -= loss\n\n        din = self.get_din_pool()\n\n        # Calculate moving averages TODO generalise\n        temp_10_day = sum(self.lagged_temperatures[-10:]) / 10\n        temp_20_day = sum(self.lagged_temperatures[-20:]) / 20\n        total_phos_365_day = sum(self.lagged_total_phosphorus) / self.max_phosphorus_lag\n\n        # Calculate coefficients\n        tempfcn = (\n            (self.tank.storage[\"temperature\"]) / 20 * (temp_10_day - temp_20_day) / 5\n        )\n        if (total_phos_365_day - self.limpppar + self.hsatTP) &gt; 0:\n            totalphosfcn = (total_phos_365_day - self.limpppar) / (\n                total_phos_365_day - self.limpppar + self.hsatTP\n            )\n        else:\n            totalphosfcn = 0\n\n        # Mineralisation/production TODO this feels like it could be much tidier\n        minprodN = (\n            self.prodNpar * totalphosfcn * tempfcn * self.area * self.current_depth\n        )  # [kg N/day]\n        minprodP = (\n            self.prodPpar\n            * totalphosfcn\n            * tempfcn\n            * self.area\n            * self.current_depth\n            * self.uptake_PNratio\n        )  # [kg N/day]\n        if minprodN &gt; 0:\n            # production (inorg -&gt; org)\n            minprodN = min(\n                0.5 * din, minprodN\n            )  # only half pool can be used for production\n            minprodP = min(\n                0.5 * self.tank.storage[\"phosphate\"], minprodP\n            )  # only half pool can be used for production\n\n            # Update mass balance\n            out_[\"phosphate\"] = minprodP\n            self.tank.storage[\"phosphate\"] -= minprodP\n            in_[\"org-phosphorus\"] = minprodP\n            self.tank.storage[\"org-phosphorus\"] += minprodP\n            if din &gt; 0:\n                for pol in self.din_components:\n                    loss = minprodN * self.tank.storage[pol] / din\n                    out_[pol] += loss\n                    self.tank.storage[pol] -= loss\n\n            in_[\"org-nitrogen\"] = minprodN\n            self.tank.storage[\"org-nitrogen\"] += minprodN\n\n        else:\n            # mineralisation (org -&gt; inorg)\n            minprodN = min(0.5 * self.tank.storage[\"org-nitrogen\"], -minprodN)\n            minprodP = min(0.5 * self.tank.storage[\"org-phosphorus\"], -minprodP)\n\n            # Update mass balance\n            in_[\"phosphate\"] = minprodP\n            self.tank.storage[\"phosphate\"] += minprodP\n            out_[\"org-phosphorus\"] = minprodP\n            self.tank.storage[\"org-phosphorus\"] -= minprodP\n            if din &gt; 0:\n                for pol in self.din_components:\n                    gain = minprodN * self.tank.storage[pol] / din\n                    in_[pol] += gain\n                    self.tank.storage[pol] += gain\n\n            out_[\"org-nitrogen\"] = minprodN\n            self.tank.storage[\"org-nitrogen\"] -= minprodN\n\n        din = self.get_din_pool()\n\n        # macrophyte uptake temperature dependence factor\n        tempfcn1 = (max(0, self.tank.storage[\"temperature\"]) / 20) ** 0.3\n        tempfcn2 = (self.tank.storage[\"temperature\"] - temp_20_day) / 5\n        tempfcn = max(0, tempfcn1 * tempfcn2)\n\n        macrouptN = self.muptNpar * tempfcn * self.area  # [kg/day]\n        macrophyte_uptake_N = min(0.5 * din, macrouptN)\n        if din &gt; 0:\n            for pol in self.din_components:\n                loss = macrophyte_uptake_N * self.tank.storage[pol] / din\n                out_[pol] += loss\n                self.tank.storage[pol] -= loss\n\n        macrouptP = (\n            self.muptPpar * tempfcn * max(0, totalphosfcn) * self.area\n        )  # [kg/day]\n        macrophyte_uptake_P = min(0.5 * self.tank.storage[\"phosphate\"], macrouptP)\n        out_[\"phosphate\"] += macrophyte_uptake_P\n        self.tank.storage[\"phosphate\"] -= macrophyte_uptake_P\n\n        # TODO source/sink for benthos sediment P suspension/resuspension\n        return in_, out_\n\n    def get_riverrc(self):\n        \"\"\"Get river outflow coefficient (i.e., how much water leaves the tank in this\n        timestep).\n\n        Returns:\n            riverrc (float): outflow coeffficient\n        \"\"\"\n        # Calculate travel time\n        total_time = self.length / self.velocity\n        # Apply damp\n        kt = self.damp * total_time  # [day]\n        if kt != 0:\n            riverrc = 1 - kt + kt * exp(-1 / kt)  # [-]\n        else:\n            riverrc = 1\n        return riverrc\n\n    def calculate_discharge(self):\n        \"\"\"\"\"\"\n        if \"nitrate\" in constants.POLLUTANTS:\n            # TODO clumsy Run biochemical processes\n            in_, out_ = self.biochemical_processes()\n            # Mass balance\n            self.bio_in = in_\n            self.bio_out = out_\n\n    def distribute(self):\n        \"\"\"Run biochemical processes, track mass balance, and distribute water.\"\"\"\n        # self.calculate_discharge() Get outflow\n        outflow = self.tank.pull_storage(\n            {\"volume\": self.tank.storage[\"volume\"] * self.get_riverrc()}\n        )\n        # Distribute outflow\n        reply = self.push_distributed(outflow, of_type=[\"River\", \"Node\", \"Waste\"])\n        _ = self.tank.push_storage(reply, force=True)\n        if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"river cant push: {0}\".format(reply[\"volume\"]))\n\n    def pull_check_fp(self, vqip=None):\n        \"\"\"\n\n        Args:\n            vqip:\n\n        Returns:\n\n        \"\"\"\n        # TODO Pull checking for riparian buffer, needs updating update river depth\n        self.update_depth()\n        return self.current_depth, self.area, self.width, self.river_tank.storage\n\n    def end_timestep_(self):\n        \"\"\"Update state variables.\"\"\"\n        self.tank.end_timestep()\n        self.bio_in = self.empty_vqip()\n        self.bio_out = self.empty_vqip()\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.__init__","title":"<code>__init__(depth=2, length=200, width=20, velocity=0.2 * constants.M_S_TO_M_DT, damp=0.1, mrf=0, **kwargs)</code>","text":"<p>Node that contains extensive in-river biochemical processes.</p> <p>Parameters:</p> Name Type Description Default <code>depth</code> <code>float</code> <p>River tank depth. Defaults to 2. length (float,</p> <code>2</code> <code>optional)</code> <p>River tank length. Defaults to 200. width (float, optional):</p> required <code>River tank width. Defaults to 20. velocity</code> <code>float</code> <p>River velocity</p> required <code>damp</code> <code>float</code> <p>Flow delay and attentuation parameter. Defaults to 0.1.</p> <code>0.1</code> <code>mrf</code> <code>float</code> <p>Minimum required flow in river (volume per timestep), can limit pulls made to the river. Defaults to 0.</p> <code>0</code> Functions intended to call in orchestration <p>distribute</p> Key assumptions <ul> <li>River is conceptualised as a water tank that receives flows from various    sources (e.g., runoffs from urban and rural land, baseflow from    groundwater), interacts with water infrastructure (e.g., abstraction for    irrigation and domestic supply, sewage and treated effluent discharge),    and discharges flows downstream. It has length and width as shape    parameters, average velocity to indicate flow speed and capacity to    indicate the maximum storage limit.</li> <li>Flows from different sources into rivers will fully mix. River tank is   assumed to    have delay and attenuation effects when generate outflows. These effects    are simulated based on the average velocity.</li> <li>In-river biochemical processes are simulated as sources/sinks of   nutrients    in the river tank, including - denitrification (for nitrogen) -    phytoplankton absorption/release (for nitrogen and phosphorus) -    macrophyte uptake (for nitrogen and phosphorus) These processes are    affected by river temperature.</li> </ul> Input data and parameter requirements <ul> <li>depth, length, width    Units: m</li> <li>velocity    Units: m/day</li> <li>damping coefficient    Units: -</li> <li>minimum required flow    Units: m3/day</li> </ul> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>    def __init__(\n        self,\n        depth=2,\n        length=200,\n        width=20,\n        velocity=0.2 * constants.M_S_TO_M_DT,\n        damp=0.1,\n        mrf=0,\n        **kwargs,\n    ):\n        \"\"\"Node that contains extensive in-river biochemical processes.\n\n        Args:\n            depth (float, optional): River tank depth. Defaults to 2. length (float,\n            optional): River tank length. Defaults to 200. width (float, optional):\n            River tank width. Defaults to 20. velocity (float, optional): River velocity\n            (if someone wants to calculate\n                this on the fly that would also work). Defaults to\n                0.2*constants.M_S_TO_M_DT.\n            damp (float, optional): Flow delay and attentuation parameter. Defaults\n                to 0.1.\n            mrf (float, optional): Minimum required flow in river (volume per timestep),\n                can limit pulls made to the river. Defaults to 0.\n\n        Functions intended to call in orchestration:\n            distribute\n\n        Key assumptions:\n             - River is conceptualised as a water tank that receives flows from various\n                sources (e.g., runoffs from urban and rural land, baseflow from\n                groundwater), interacts with water infrastructure (e.g., abstraction for\n                irrigation and domestic supply, sewage and treated effluent discharge),\n                and discharges flows downstream. It has length and width as shape\n                parameters, average velocity to indicate flow speed and capacity to\n                indicate the maximum storage limit.\n             - Flows from different sources into rivers will fully mix. River tank is\n               assumed to\n                have delay and attenuation effects when generate outflows. These effects\n                are simulated based on the average velocity.\n             - In-river biochemical processes are simulated as sources/sinks of\n               nutrients\n                in the river tank, including - denitrification (for nitrogen) -\n                phytoplankton absorption/release (for nitrogen and phosphorus) -\n                macrophyte uptake (for nitrogen and phosphorus) These processes are\n                affected by river temperature.\n\n        Input data and parameter requirements:\n             - depth, length, width\n                _Units_: m\n             - velocity\n                _Units_: m/day\n             - damping coefficient\n                _Units_: -\n             - minimum required flow\n                _Units_: m3/day\n        \"\"\"\n        # Set parameters\n        self.depth = depth\n        if depth != 2:\n            warnings.warn(\n                \"warning: the depth parameter is unused by River nodes because it is \\\n\t\tintended for capacity to be unbounded. It may be removed in a future version.\"\n            )\n        self.length = length  # [m]\n        self.width = width  # [m]\n        self.velocity = velocity  # [m/dt]\n        self.damp = damp  # [&gt;=0] flow delay and attenuation\n        self.mrf = mrf\n        area = length * width  # [m2]\n\n        capacity = (\n            constants.UNBOUNDED_CAPACITY\n        )  # TODO might be depth * area if flood indunation is going to be simulated\n\n        # Required in cases where 'area' conflicts with length*width\n        kwargs[\"area\"] = area\n        # Required in cases where 'capacity' conflicts with depth*area\n        kwargs[\"capacity\"] = capacity\n\n        super().__init__(**kwargs)\n\n        # TODO check units TODO Will a user want to change any of these? Wide variety of\n        # river parameters (from HYPE)\n        self.uptake_PNratio = 1 / 7.2  # [-] P:N during crop uptake\n        self.bulk_density = 1300  # [kg/m3] soil density\n        self.denpar_w = 0.0015  # 0.001, # [kg/m2/day] reference denitrification rate\n        # in water course\n        self.T_wdays = 5  # [days] weighting constant for river temperature calculation\n        # (similar to moving average period)\n        self.halfsatINwater = (\n            1.5 * constants.MG_L_TO_KG_M3\n        )  # [kg/m3] half saturation parameter for denitrification in river\n        self.T_10_days = []  # [degree C] average water temperature of 10 days\n        self.T_20_days = []  # [degree C] average water temperature of 20 days\n        self.TP_365_days = []  # [degree C] average water temperature of 20 days\n        self.hsatTP = 0.05 * constants.MG_L_TO_KG_M3  # [kg/m3]\n        self.limpppar = 0.1 * constants.MG_L_TO_KG_M3  # [kg/m3]\n        self.prodNpar = 0.001  # [kg N/m3/day] nitrogen production/mineralisation rate\n        self.prodPpar = (\n            0.0001  # [kg N/m3/day] phosphorus production/mineralisation rate\n        )\n        self.muptNpar = 0.001  # [kg/m2/day] nitrogen macrophyte uptake rate\n        self.muptPpar = 0.0001  # 0.01, # [kg/m2/day] phosphorus macrophyte uptake rate\n\n        self.max_temp_lag = 20\n        self.lagged_temperatures = []\n\n        self.max_phosphorus_lag = 365\n        self.lagged_total_phosphorus = []\n\n        self.din_components = [\"ammonia\", \"nitrate\"]\n        # TODO need a cleaner way to do this depending on whether e.g., nitrite is\n        # included\n\n        # Initialise paramters\n        self.current_depth = 0  # [m]\n        # self.river_temperature = 0 # [degree C] self.river_denitrification = 0 #\n        # [kg/day] self.macrophyte_uptake_N = 0 # [kg/day] self.macrophyte_uptake_P = 0\n        # # [kg/day] self.sediment_particulate_phosphorus_pool = 60000 # [kg]\n        # self.sediment_pool = 1000000 # [kg] self.benthos_source_sink = 0 # [kg/day]\n        # self.t_res = 0 # [day] self.outflow = self.empty_vqip()\n\n        # Update end_teimstep\n        self.end_timestep = self.end_timestep_\n\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_river\n        self.push_check_handler[\"default\"] = self.push_check_accept\n\n        self.pull_check_handler[\"default\"] = self.pull_check_river\n        self.pull_set_handler[\"default\"] = self.pull_set_river\n\n        # TODO - RiparianBuffer\n        self.pull_check_handler[(\"RiparianBuffer\", \"volume\")] = self.pull_check_fp\n\n        # Update mass balance\n        self.bio_in = self.empty_vqip()\n        self.bio_out = self.empty_vqip()\n\n        self.mass_balance_in.append(lambda: self.bio_in)\n        self.mass_balance_out.append(lambda: self.bio_out)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: timearea.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        timearea.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        overwrite_params = set(\n            [\n                \"length\",\n                \"width\",\n                \"velocity\",\n                \"damp\",\n                \"mrf\",\n                \"uptake_PNratio\",\n                \"bulk_density\",\n                \"denpar_w\",\n                \"T_wdays\",\n                \"halfsatINwater\",\n                \"hsatTP\",\n                \"limpppar\",\n                \"prodNpar\",\n                \"prodPpar\",\n                \"muptNpar\",\n                \"muptPpar\",\n                \"max_temp_lag\",\n                \"max_phosphorus_lag\",\n            ]\n        )\n\n        for param in overwrite_params.intersection(overrides.keys()):\n            setattr(self, param, overrides.pop(param))\n\n        if \"area\" in overrides.keys():\n            warnings.warn(\n                \"WARNING: specifying area is depreciated in overrides \\\n\t\tfor river, please specify length and width instead\"\n            )\n        overrides[\"area\"] = self.length * self.width\n        if \"capacity\" in overrides.keys():\n            warnings.warn(\n                \"ERROR: specifying capacity is depreciated in overrides \\\n\t\tfor river, it is always set as unbounded capacity\"\n            )\n        overrides[\"capacity\"] = constants.UNBOUNDED_CAPACITY\n        super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.biochemical_processes","title":"<code>biochemical_processes()</code>","text":"<p>Runs all biochemical processes and updates pollutant amounts.</p> <p>Returns:</p> Name Type Description <code>in_</code> <code>dict</code> <p>A VQIP amount that represents total gain in pollutant amounts</p> <code>out_</code> <code>dict</code> <p>A VQIP amount that represents total loss in pollutant amounts</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def biochemical_processes(self):\n    \"\"\"Runs all biochemical processes and updates pollutant amounts.\n\n    Returns:\n        in_ (dict): A VQIP amount that represents total gain in pollutant amounts\n        out_ (dict): A VQIP amount that represents total loss in pollutant amounts\n    \"\"\"\n    # TODO make more modular\n    self.update_depth()\n\n    self.tank.storage[\"temperature\"] = (1 - 1 / self.T_wdays) * self.tank.storage[\n        \"temperature\"\n    ] + (1 / self.T_wdays) * self.get_data_input(\"temperature\")\n\n    # Update lagged temperatures\n    if len(self.lagged_temperatures) &gt; self.max_temp_lag:\n        del self.lagged_temperatures[0]\n    self.lagged_temperatures.append(self.tank.storage[\"temperature\"])\n\n    # Update lagged total phosphorus\n    if len(self.lagged_total_phosphorus) &gt; self.max_phosphorus_lag:\n        del self.lagged_total_phosphorus[0]\n    total_phosphorus = (\n        self.tank.storage[\"phosphate\"] + self.tank.storage[\"org-phosphorus\"]\n    )\n    self.lagged_total_phosphorus.append(total_phosphorus)\n\n    # Check if any water\n    if self.tank.storage[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n        # Assume these only do something when there is water\n        return (self.empty_vqip(), self.empty_vqip())\n\n    if self.tank.storage[\"temperature\"] &lt;= 0:\n        # Seems that these things are only active when above freezing\n        return (self.empty_vqip(), self.empty_vqip())\n\n    # Denitrification\n    tempfcn = 2 ** ((self.tank.storage[\"temperature\"] - 20) / 10)\n    if self.tank.storage[\"temperature\"] &lt; 5:\n        tempfcn *= self.tank.storage[\"temperature\"] / 5\n\n    din = self.get_din_pool()\n    din_concentration = din / self.tank.storage[\"volume\"]\n    confcn = din_concentration / (\n        din_concentration + self.halfsatINwater\n    )  # [kg/m3]\n    denitri_water = (\n        self.denpar_w * self.area * tempfcn * confcn\n    )  # [kg/day] #TODO convert to per DT\n\n    river_denitrification = min(\n        denitri_water, 0.5 * din\n    )  # [kg/day] max 50% kan be denitrified\n    din_ = din - river_denitrification  # [kg]\n\n    # Update mass balance\n    in_ = self.empty_vqip()\n    out_ = self.empty_vqip()\n    if din &gt; 0:\n        for pol in self.din_components:\n            # denitrification\n            loss = (din - din_) / din * self.tank.storage[pol]\n            out_[pol] += loss\n            self.tank.storage[pol] -= loss\n\n    din = self.get_din_pool()\n\n    # Calculate moving averages TODO generalise\n    temp_10_day = sum(self.lagged_temperatures[-10:]) / 10\n    temp_20_day = sum(self.lagged_temperatures[-20:]) / 20\n    total_phos_365_day = sum(self.lagged_total_phosphorus) / self.max_phosphorus_lag\n\n    # Calculate coefficients\n    tempfcn = (\n        (self.tank.storage[\"temperature\"]) / 20 * (temp_10_day - temp_20_day) / 5\n    )\n    if (total_phos_365_day - self.limpppar + self.hsatTP) &gt; 0:\n        totalphosfcn = (total_phos_365_day - self.limpppar) / (\n            total_phos_365_day - self.limpppar + self.hsatTP\n        )\n    else:\n        totalphosfcn = 0\n\n    # Mineralisation/production TODO this feels like it could be much tidier\n    minprodN = (\n        self.prodNpar * totalphosfcn * tempfcn * self.area * self.current_depth\n    )  # [kg N/day]\n    minprodP = (\n        self.prodPpar\n        * totalphosfcn\n        * tempfcn\n        * self.area\n        * self.current_depth\n        * self.uptake_PNratio\n    )  # [kg N/day]\n    if minprodN &gt; 0:\n        # production (inorg -&gt; org)\n        minprodN = min(\n            0.5 * din, minprodN\n        )  # only half pool can be used for production\n        minprodP = min(\n            0.5 * self.tank.storage[\"phosphate\"], minprodP\n        )  # only half pool can be used for production\n\n        # Update mass balance\n        out_[\"phosphate\"] = minprodP\n        self.tank.storage[\"phosphate\"] -= minprodP\n        in_[\"org-phosphorus\"] = minprodP\n        self.tank.storage[\"org-phosphorus\"] += minprodP\n        if din &gt; 0:\n            for pol in self.din_components:\n                loss = minprodN * self.tank.storage[pol] / din\n                out_[pol] += loss\n                self.tank.storage[pol] -= loss\n\n        in_[\"org-nitrogen\"] = minprodN\n        self.tank.storage[\"org-nitrogen\"] += minprodN\n\n    else:\n        # mineralisation (org -&gt; inorg)\n        minprodN = min(0.5 * self.tank.storage[\"org-nitrogen\"], -minprodN)\n        minprodP = min(0.5 * self.tank.storage[\"org-phosphorus\"], -minprodP)\n\n        # Update mass balance\n        in_[\"phosphate\"] = minprodP\n        self.tank.storage[\"phosphate\"] += minprodP\n        out_[\"org-phosphorus\"] = minprodP\n        self.tank.storage[\"org-phosphorus\"] -= minprodP\n        if din &gt; 0:\n            for pol in self.din_components:\n                gain = minprodN * self.tank.storage[pol] / din\n                in_[pol] += gain\n                self.tank.storage[pol] += gain\n\n        out_[\"org-nitrogen\"] = minprodN\n        self.tank.storage[\"org-nitrogen\"] -= minprodN\n\n    din = self.get_din_pool()\n\n    # macrophyte uptake temperature dependence factor\n    tempfcn1 = (max(0, self.tank.storage[\"temperature\"]) / 20) ** 0.3\n    tempfcn2 = (self.tank.storage[\"temperature\"] - temp_20_day) / 5\n    tempfcn = max(0, tempfcn1 * tempfcn2)\n\n    macrouptN = self.muptNpar * tempfcn * self.area  # [kg/day]\n    macrophyte_uptake_N = min(0.5 * din, macrouptN)\n    if din &gt; 0:\n        for pol in self.din_components:\n            loss = macrophyte_uptake_N * self.tank.storage[pol] / din\n            out_[pol] += loss\n            self.tank.storage[pol] -= loss\n\n    macrouptP = (\n        self.muptPpar * tempfcn * max(0, totalphosfcn) * self.area\n    )  # [kg/day]\n    macrophyte_uptake_P = min(0.5 * self.tank.storage[\"phosphate\"], macrouptP)\n    out_[\"phosphate\"] += macrophyte_uptake_P\n    self.tank.storage[\"phosphate\"] -= macrophyte_uptake_P\n\n    # TODO source/sink for benthos sediment P suspension/resuspension\n    return in_, out_\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.calculate_discharge","title":"<code>calculate_discharge()</code>","text":"Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def calculate_discharge(self):\n    \"\"\"\"\"\"\n    if \"nitrate\" in constants.POLLUTANTS:\n        # TODO clumsy Run biochemical processes\n        in_, out_ = self.biochemical_processes()\n        # Mass balance\n        self.bio_in = in_\n        self.bio_out = out_\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.distribute","title":"<code>distribute()</code>","text":"<p>Run biochemical processes, track mass balance, and distribute water.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def distribute(self):\n    \"\"\"Run biochemical processes, track mass balance, and distribute water.\"\"\"\n    # self.calculate_discharge() Get outflow\n    outflow = self.tank.pull_storage(\n        {\"volume\": self.tank.storage[\"volume\"] * self.get_riverrc()}\n    )\n    # Distribute outflow\n    reply = self.push_distributed(outflow, of_type=[\"River\", \"Node\", \"Waste\"])\n    _ = self.tank.push_storage(reply, force=True)\n    if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"river cant push: {0}\".format(reply[\"volume\"]))\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.end_timestep_","title":"<code>end_timestep_()</code>","text":"<p>Update state variables.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def end_timestep_(self):\n    \"\"\"Update state variables.\"\"\"\n    self.tank.end_timestep()\n    self.bio_in = self.empty_vqip()\n    self.bio_out = self.empty_vqip()\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.get_din_pool","title":"<code>get_din_pool()</code>","text":"<p>Get total dissolved inorganic nitrogen from tank storage.</p> <p>Returns:</p> Type Description <code>float</code> <p>total din</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def get_din_pool(self):\n    \"\"\"Get total dissolved inorganic nitrogen from tank storage.\n\n    Returns:\n        (float): total din\n    \"\"\"\n    return sum(\n        [self.tank.storage[x] for x in self.din_components]\n    )  # TODO + self.tank.storage['nitrite'] but nitrite might not be modelled...\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.get_riverrc","title":"<code>get_riverrc()</code>","text":"<p>Get river outflow coefficient (i.e., how much water leaves the tank in this timestep).</p> <p>Returns:</p> Name Type Description <code>riverrc</code> <code>float</code> <p>outflow coeffficient</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def get_riverrc(self):\n    \"\"\"Get river outflow coefficient (i.e., how much water leaves the tank in this\n    timestep).\n\n    Returns:\n        riverrc (float): outflow coeffficient\n    \"\"\"\n    # Calculate travel time\n    total_time = self.length / self.velocity\n    # Apply damp\n    kt = self.damp * total_time  # [day]\n    if kt != 0:\n        riverrc = 1 - kt + kt * exp(-1 / kt)  # [-]\n    else:\n        riverrc = 1\n    return riverrc\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.pull_check_fp","title":"<code>pull_check_fp(vqip=None)</code>","text":"<p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>None</code> <p>Returns:</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def pull_check_fp(self, vqip=None):\n    \"\"\"\n\n    Args:\n        vqip:\n\n    Returns:\n\n    \"\"\"\n    # TODO Pull checking for riparian buffer, needs updating update river depth\n    self.update_depth()\n    return self.current_depth, self.area, self.width, self.river_tank.storage\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.pull_check_river","title":"<code>pull_check_river(vqip=None)</code>","text":"<p>Check amount of water that can be pulled from river tank and upstream.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>Maximum water required (only 'volume' is used)</p> <code>None</code> <p>Returns:</p> Name Type Description <code>avail</code> <code>dict</code> <p>A VQIP amount that can be pulled</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def pull_check_river(self, vqip=None):\n    \"\"\"Check amount of water that can be pulled from river tank and upstream.\n\n    Args:\n        vqip (dict, optional): Maximum water required (only 'volume' is used)\n\n    Returns:\n        avail (dict): A VQIP amount that can be pulled\n    \"\"\"\n    # Get storage\n    avail = self.tank.get_avail()\n\n    # Check incoming\n    upstream = self.get_connected(direction=\"pull\", of_type=[\"River\", \"Node\"])\n    avail[\"volume\"] += upstream[\"avail\"]\n\n    # convert mrf from volume/timestep to discrete value\n    mrf = self.mrf / self.get_riverrc()\n\n    # Apply mrf\n    avail_vol = max(avail[\"volume\"] - mrf, 0)\n    if vqip is None:\n        avail = self.v_change_vqip(avail, avail_vol)\n    else:\n        avail = self.v_change_vqip(avail, min(avail_vol, vqip[\"volume\"]))\n\n    return avail\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.pull_set_river","title":"<code>pull_set_river(vqip)</code>","text":"<p>Pull from river tank and upstream, acknowledging MRF with pull_check.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to pull (only volume key used)</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount that was pulled</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def pull_set_river(self, vqip):\n    \"\"\"Pull from river tank and upstream, acknowledging MRF with pull_check.\n\n    Args:\n        vqip (dict): A VQIP amount to pull (only volume key used)\n\n    Returns:\n        (dict): A VQIP amount that was pulled\n    \"\"\"\n    # Calculate available pull\n    avail = self.pull_check_river(vqip)\n\n    # Take first from tank\n    pulled = self.tank.pull_storage(avail)\n\n    # Take remaining from upstream\n    to_pull = {\"volume\": avail[\"volume\"] - pulled[\"volume\"]}\n    pulled_ = self.pull_distributed(to_pull, of_type=[\"River\", \"Node\"])\n\n    reply = self.sum_vqip(pulled, pulled_)\n\n    return reply\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.push_set_river","title":"<code>push_set_river(vqip)</code>","text":"<p>Push to river tank, currently forced.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to push</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount that was not successfully received</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def push_set_river(self, vqip):\n    \"\"\"Push to river tank, currently forced.\n\n    Args:\n        vqip (dict): A VQIP amount to push\n\n    Returns:\n        (dict): A VQIP amount that was not successfully received\n    \"\"\"\n    _ = self.tank.push_storage(vqip, force=True)\n    return self.empty_vqip()\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.River.update_depth","title":"<code>update_depth()</code>","text":"<p>Recalculate depth.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def update_depth(self):\n    \"\"\"Recalculate depth.\"\"\"\n    self.current_depth = self.tank.storage[\"volume\"] / self.area\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir","title":"<code>RiverReservoir</code>","text":"<p>               Bases: <code>Reservoir</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class RiverReservoir(Reservoir):\n    \"\"\"\"\"\"\n\n    def __init__(self, environmental_flow=0, **kwargs):\n        \"\"\"A reservoir with a natural river inflow, includes an environmental downstream\n        flow to satisfy.\n\n        Args:\n            environmental_flow (float, optional): Downstream environmental flow.\n                Defaults to 0.\n\n        Functions intended to call in orchestration:\n                make_abstractions (if any)\n\n                satisfy_environmental (before river routing.. possibly before\n                    downstream river abstractions depending on licence)\n\n        Key assumptions:\n            - Conceptualised as a `Tank`.\n            - Recharged via pumped abstractions and receives water from\n                inflowing arcs.\n            - Reservoir aims to satisfy a static `environmental_flow`.\n            - If tank capacity is exceeded, reservoir spills downstream\n                towards `nodes.py/Node`, `storage.py/River` or `waste.py/Waste` nodes.\n                Spill counts towards `environmental_flow`.\n            - Evaporation/precipitation onto surface area currently ignored.\n            - Currently, if a reservoir satisfies a pull from a downstream\n                node, it does __not__ count towards `environmental_flow`.\n            - If `decays` are provided to model water quality transformations,\n                see `core.py/DecayObj`.\n\n        Input data and parameter requirements:\n            - Tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n            - `environmental_flow`\n                _Units_: cubic metres/timestep\n            - Optional dictionary of decays with pollutants as keys and decay\n                parameters (a constant and a temperature sensitivity exponent) as\n                values. _Units_: -\n        \"\"\"\n        # Parameters\n        self.environmental_flow = environmental_flow\n        super().__init__(**kwargs)\n\n        # State variables\n        self.total_environmental_satisfied = 0\n\n        self.push_set_handler[\"default\"] = self.push_set_river_reservoir\n        self.push_check_handler[\"default\"] = self.push_check_river_reservoir\n        self.end_timestep = self.end_timestep_\n\n        self.__class__.__name__ = \"Reservoir\"\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        environmental_flow.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.environmental_flow = overrides.pop(\n            \"environmental_flow\", self.environmental_flow\n        )\n        super().apply_overrides(overrides)\n\n    def push_set_river_reservoir(self, vqip):\n        \"\"\"Receive water.\n\n        Args:\n            vqip (dict): A VQIP amount to be received\n\n        Returns:\n            reply (dict): A VQIP amount that was not successfully received\n        \"\"\"\n        # Apply normal reservoir storage We do this under the assumption that spill is\n        # mixed in with the reservoir If the reservoir can't spill everything you'll get\n        # some weird numbers in reply, but if your reservoir can't spill as much as you\n        # like then you should probably be pushing the right amount through\n        # push_check_river_reservoir Some cunning could probably avoid this by checking\n        # vqip, but this is a serious edge case\n        _ = self.tank.push_storage(vqip, force=True)\n        spill = self.tank.pull_ponded()\n\n        # Send spill downstream\n        reply = self.push_distributed(spill, of_type=[\"Node\", \"River\", \"Waste\"])\n\n        # Use spill to satisfy downstream flow\n        self.total_environmental_satisfied += spill[\"volume\"] - reply[\"volume\"]\n\n        return reply\n\n    def push_check_river_reservoir(self, vqip=None):\n        \"\"\"A push check to receive water, assumes spill may occur and checks downstream\n        capacity.\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            excess (dict): A VQIP amount of water that cannot be received\n        \"\"\"\n        # Check downstream capacity (i.e., that would be spilled)\n        downstream_availability = self.get_connected(\n            direction=\"push\", of_type=[\"Node\", \"River\", \"Waste\"]\n        )[\"avail\"]\n        # Check excess capacity in the reservoir\n        excess = self.tank.get_excess()\n        # Combine excess and downstream in response\n        new_v = excess[\"volume\"] + downstream_availability\n        if vqip is not None:\n            new_v = min(vqip[\"volume\"], new_v)\n        # Update to vqip\n        excess = self.v_change_vqip(excess, new_v)\n\n        return excess\n\n    def satisfy_environmental(self):\n        \"\"\"Satisfy environmental flow downstream.\"\"\"\n        # Calculate how much environmental flow is yet to satisfy #(some may have been\n        # already if pull-and-take abstractions have taken place)\n        to_satisfy = max(\n            self.environmental_flow - self.total_environmental_satisfied, 0\n        )\n        # Pull from tank\n        environmental = self.tank.pull_storage({\"volume\": to_satisfy})\n        # Send downstream\n        reply = self.push_distributed(environmental)\n        _ = self.tank.push_storage(reply, force=True)\n        if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"warning: environmental not able to push\")\n\n        # Update satisfaction\n        self.total_environmental_satisfied += environmental[\"volume\"]\n\n    def end_timestep_(self):\n        \"\"\"Udpate state varibles.\"\"\"\n        self.tank.end_timestep()\n        self.total_environmental_satisfied = 0\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.__init__","title":"<code>__init__(environmental_flow=0, **kwargs)</code>","text":"<p>A reservoir with a natural river inflow, includes an environmental downstream flow to satisfy.</p> <p>Parameters:</p> Name Type Description Default <code>environmental_flow</code> <code>float</code> <p>Downstream environmental flow. Defaults to 0.</p> <code>0</code> Functions intended to call in orchestration <p>make_abstractions (if any)</p> <p>satisfy_environmental (before river routing.. possibly before     downstream river abstractions depending on licence)</p> Key assumptions <ul> <li>Conceptualised as a <code>Tank</code>.</li> <li>Recharged via pumped abstractions and receives water from     inflowing arcs.</li> <li>Reservoir aims to satisfy a static <code>environmental_flow</code>.</li> <li>If tank capacity is exceeded, reservoir spills downstream     towards <code>nodes.py/Node</code>, <code>storage.py/River</code> or <code>waste.py/Waste</code> nodes.     Spill counts towards <code>environmental_flow</code>.</li> <li>Evaporation/precipitation onto surface area currently ignored.</li> <li>Currently, if a reservoir satisfies a pull from a downstream     node, it does not count towards <code>environmental_flow</code>.</li> <li>If <code>decays</code> are provided to model water quality transformations,     see <code>core.py/DecayObj</code>.</li> </ul> Input data and parameter requirements <ul> <li>Tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> <li><code>environmental_flow</code> Units: cubic metres/timestep</li> <li>Optional dictionary of decays with pollutants as keys and decay     parameters (a constant and a temperature sensitivity exponent) as     values. Units: -</li> </ul> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def __init__(self, environmental_flow=0, **kwargs):\n    \"\"\"A reservoir with a natural river inflow, includes an environmental downstream\n    flow to satisfy.\n\n    Args:\n        environmental_flow (float, optional): Downstream environmental flow.\n            Defaults to 0.\n\n    Functions intended to call in orchestration:\n            make_abstractions (if any)\n\n            satisfy_environmental (before river routing.. possibly before\n                downstream river abstractions depending on licence)\n\n    Key assumptions:\n        - Conceptualised as a `Tank`.\n        - Recharged via pumped abstractions and receives water from\n            inflowing arcs.\n        - Reservoir aims to satisfy a static `environmental_flow`.\n        - If tank capacity is exceeded, reservoir spills downstream\n            towards `nodes.py/Node`, `storage.py/River` or `waste.py/Waste` nodes.\n            Spill counts towards `environmental_flow`.\n        - Evaporation/precipitation onto surface area currently ignored.\n        - Currently, if a reservoir satisfies a pull from a downstream\n            node, it does __not__ count towards `environmental_flow`.\n        - If `decays` are provided to model water quality transformations,\n            see `core.py/DecayObj`.\n\n    Input data and parameter requirements:\n        - Tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n        - `environmental_flow`\n            _Units_: cubic metres/timestep\n        - Optional dictionary of decays with pollutants as keys and decay\n            parameters (a constant and a temperature sensitivity exponent) as\n            values. _Units_: -\n    \"\"\"\n    # Parameters\n    self.environmental_flow = environmental_flow\n    super().__init__(**kwargs)\n\n    # State variables\n    self.total_environmental_satisfied = 0\n\n    self.push_set_handler[\"default\"] = self.push_set_river_reservoir\n    self.push_check_handler[\"default\"] = self.push_check_river_reservoir\n    self.end_timestep = self.end_timestep_\n\n    self.__class__.__name__ = \"Reservoir\"\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: environmental_flow.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    environmental_flow.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.environmental_flow = overrides.pop(\n        \"environmental_flow\", self.environmental_flow\n    )\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.end_timestep_","title":"<code>end_timestep_()</code>","text":"<p>Udpate state varibles.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def end_timestep_(self):\n    \"\"\"Udpate state varibles.\"\"\"\n    self.tank.end_timestep()\n    self.total_environmental_satisfied = 0\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.push_check_river_reservoir","title":"<code>push_check_river_reservoir(vqip=None)</code>","text":"<p>A push check to receive water, assumes spill may occur and checks downstream capacity.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>excess</code> <code>dict</code> <p>A VQIP amount of water that cannot be received</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def push_check_river_reservoir(self, vqip=None):\n    \"\"\"A push check to receive water, assumes spill may occur and checks downstream\n    capacity.\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        excess (dict): A VQIP amount of water that cannot be received\n    \"\"\"\n    # Check downstream capacity (i.e., that would be spilled)\n    downstream_availability = self.get_connected(\n        direction=\"push\", of_type=[\"Node\", \"River\", \"Waste\"]\n    )[\"avail\"]\n    # Check excess capacity in the reservoir\n    excess = self.tank.get_excess()\n    # Combine excess and downstream in response\n    new_v = excess[\"volume\"] + downstream_availability\n    if vqip is not None:\n        new_v = min(vqip[\"volume\"], new_v)\n    # Update to vqip\n    excess = self.v_change_vqip(excess, new_v)\n\n    return excess\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.push_set_river_reservoir","title":"<code>push_set_river_reservoir(vqip)</code>","text":"<p>Receive water.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be received</p> required <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>A VQIP amount that was not successfully received</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def push_set_river_reservoir(self, vqip):\n    \"\"\"Receive water.\n\n    Args:\n        vqip (dict): A VQIP amount to be received\n\n    Returns:\n        reply (dict): A VQIP amount that was not successfully received\n    \"\"\"\n    # Apply normal reservoir storage We do this under the assumption that spill is\n    # mixed in with the reservoir If the reservoir can't spill everything you'll get\n    # some weird numbers in reply, but if your reservoir can't spill as much as you\n    # like then you should probably be pushing the right amount through\n    # push_check_river_reservoir Some cunning could probably avoid this by checking\n    # vqip, but this is a serious edge case\n    _ = self.tank.push_storage(vqip, force=True)\n    spill = self.tank.pull_ponded()\n\n    # Send spill downstream\n    reply = self.push_distributed(spill, of_type=[\"Node\", \"River\", \"Waste\"])\n\n    # Use spill to satisfy downstream flow\n    self.total_environmental_satisfied += spill[\"volume\"] - reply[\"volume\"]\n\n    return reply\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.RiverReservoir.satisfy_environmental","title":"<code>satisfy_environmental()</code>","text":"<p>Satisfy environmental flow downstream.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def satisfy_environmental(self):\n    \"\"\"Satisfy environmental flow downstream.\"\"\"\n    # Calculate how much environmental flow is yet to satisfy #(some may have been\n    # already if pull-and-take abstractions have taken place)\n    to_satisfy = max(\n        self.environmental_flow - self.total_environmental_satisfied, 0\n    )\n    # Pull from tank\n    environmental = self.tank.pull_storage({\"volume\": to_satisfy})\n    # Send downstream\n    reply = self.push_distributed(environmental)\n    _ = self.tank.push_storage(reply, force=True)\n    if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"warning: environmental not able to push\")\n\n    # Update satisfaction\n    self.total_environmental_satisfied += environmental[\"volume\"]\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage","title":"<code>Storage</code>","text":"<p>               Bases: <code>Node</code></p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>class Storage(Node):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        name,\n        capacity=0,\n        area=0,\n        datum=0,\n        decays=None,\n        initial_storage=0,\n        **kwargs,\n    ):\n        \"\"\"A Node wrapper for a Tank or DecayTank.\n\n        Args:\n            name (str): node name capacity (float, optional): Tank capacity (see\n            nodes.py/Tank). Defaults to 0. area (float, optional): Tank area (see\n            nodes.py/Tank). Defaults to 0. datum (float, optional): Tank datum (see\n            nodes.py/Tank). Defaults to 0. decays (dict, optional): Tank decays if\n            needed, (see nodes.py/DecayTank). Defaults to None. initial_storage (float\n            or dict, optional): Initial storage (see nodes.py/Tank). Defaults to 0.\n\n        Functions intended to call in orchestration:\n            distribute (optional, depends on subclass)\n        \"\"\"\n        # Set parameters\n        self.initial_storage = initial_storage\n        self.capacity = capacity\n        self.area = area\n        self.datum = datum\n        self.decays = decays\n        super().__init__(name, **kwargs)\n\n        # Create tank\n        if \"initial_storage\" not in dir(self):\n            self.initial_storage = self.empty_vqip()\n\n        if self.decays is None:\n            self.tank = Tank(\n                capacity=self.capacity,\n                area=self.area,\n                datum=self.datum,\n                initial_storage=self.initial_storage,\n            )\n        else:\n            self.tank = DecayTank(\n                capacity=self.capacity,\n                area=self.area,\n                datum=self.datum,\n                initial_storage=self.initial_storage,\n                decays=self.decays,\n                parent=self,\n            )\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_storage\n        self.push_check_handler[\"default\"] = self.tank.get_excess\n        self.pull_set_handler[\"default\"] = lambda vol: self.tank.pull_storage(vol)\n        self.pull_check_handler[\"default\"] = self.tank.get_avail\n\n        # Mass balance\n        self.mass_balance_ds.append(lambda: self.tank.ds())\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        capacity, area, datum, decays.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        # not using pop as these items need to stay\n        # in the overrides to be fed into the tank overrides\n        if \"capacity\" in overrides.keys():\n            self.capacity = overrides[\"capacity\"]\n        if \"area\" in overrides.keys():\n            self.area = overrides[\"area\"]\n        if \"datum\" in overrides.keys():\n            self.datum = overrides[\"datum\"]\n        if \"decays\" in overrides.keys():\n            if self.decays is None:\n                raise ValueError(\n                    \"Attempting to override decays on a node initialised without decays\"\n                )\n            self.decays.update(overrides[\"decays\"])\n        # apply tank overrides\n        self.tank.apply_overrides(overrides)\n        super().apply_overrides(overrides)\n\n    def push_set_storage(self, vqip):\n        \"\"\"A node wrapper for the tank push_storage.\n\n        Args:\n            vqip (dict): A VQIP amount to push to the tank\n\n        Returns:\n            reply (dict): A VQIP amount that was not successfully pushed\n        \"\"\"\n        # Update tank\n        reply = self.tank.push_storage(vqip)\n\n        return reply\n\n    def distribute(self):\n        \"\"\"Optional function that discharges all tank storage with push_distributed.\"\"\"\n        # Distribute any active storage\n        storage = self.tank.pull_storage(self.tank.get_avail())\n        retained = self.push_distributed(storage)\n        _ = self.tank.push_storage(retained, force=True)\n        if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"Storage unable to push\")\n\n    def get_percent(self):\n        \"\"\"Function that returns the volume in the storage tank expressed as a percent\n        of capacity.\"\"\"\n        return self.tank.storage[\"volume\"] / self.tank.capacity\n\n    def end_timestep(self):\n        \"\"\"Update tank states.\"\"\"\n        self.tank.end_timestep()\n\n    def reinit(self):\n        \"\"\"Call tank reinit.\"\"\"\n        # TODO Automate this better\n        self.tank.reinit()\n        self.tank.storage[\"volume\"] = self.initial_storage\n        self.tank.storage_[\"volume\"] = self.initial_storage\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.__init__","title":"<code>__init__(name, capacity=0, area=0, datum=0, decays=None, initial_storage=0, **kwargs)</code>","text":"<p>A Node wrapper for a Tank or DecayTank.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>node name capacity (float, optional): Tank capacity (see</p> required <code>nodes.py/Tank). Defaults to 0. area</code> <code>float</code> <p>Tank area (see</p> required <code>nodes.py/Tank). Defaults to 0. datum</code> <code>float</code> <p>Tank datum (see</p> required <code>nodes.py/Tank). Defaults to 0. decays</code> <code>dict</code> <p>Tank decays if</p> required <code>or dict, optional)</code> <p>Initial storage (see nodes.py/Tank). Defaults to 0.</p> required Functions intended to call in orchestration <p>distribute (optional, depends on subclass)</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def __init__(\n    self,\n    name,\n    capacity=0,\n    area=0,\n    datum=0,\n    decays=None,\n    initial_storage=0,\n    **kwargs,\n):\n    \"\"\"A Node wrapper for a Tank or DecayTank.\n\n    Args:\n        name (str): node name capacity (float, optional): Tank capacity (see\n        nodes.py/Tank). Defaults to 0. area (float, optional): Tank area (see\n        nodes.py/Tank). Defaults to 0. datum (float, optional): Tank datum (see\n        nodes.py/Tank). Defaults to 0. decays (dict, optional): Tank decays if\n        needed, (see nodes.py/DecayTank). Defaults to None. initial_storage (float\n        or dict, optional): Initial storage (see nodes.py/Tank). Defaults to 0.\n\n    Functions intended to call in orchestration:\n        distribute (optional, depends on subclass)\n    \"\"\"\n    # Set parameters\n    self.initial_storage = initial_storage\n    self.capacity = capacity\n    self.area = area\n    self.datum = datum\n    self.decays = decays\n    super().__init__(name, **kwargs)\n\n    # Create tank\n    if \"initial_storage\" not in dir(self):\n        self.initial_storage = self.empty_vqip()\n\n    if self.decays is None:\n        self.tank = Tank(\n            capacity=self.capacity,\n            area=self.area,\n            datum=self.datum,\n            initial_storage=self.initial_storage,\n        )\n    else:\n        self.tank = DecayTank(\n            capacity=self.capacity,\n            area=self.area,\n            datum=self.datum,\n            initial_storage=self.initial_storage,\n            decays=self.decays,\n            parent=self,\n        )\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_storage\n    self.push_check_handler[\"default\"] = self.tank.get_excess\n    self.pull_set_handler[\"default\"] = lambda vol: self.tank.pull_storage(vol)\n    self.pull_check_handler[\"default\"] = self.tank.get_avail\n\n    # Mass balance\n    self.mass_balance_ds.append(lambda: self.tank.ds())\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: capacity, area, datum, decays.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    capacity, area, datum, decays.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    # not using pop as these items need to stay\n    # in the overrides to be fed into the tank overrides\n    if \"capacity\" in overrides.keys():\n        self.capacity = overrides[\"capacity\"]\n    if \"area\" in overrides.keys():\n        self.area = overrides[\"area\"]\n    if \"datum\" in overrides.keys():\n        self.datum = overrides[\"datum\"]\n    if \"decays\" in overrides.keys():\n        if self.decays is None:\n            raise ValueError(\n                \"Attempting to override decays on a node initialised without decays\"\n            )\n        self.decays.update(overrides[\"decays\"])\n    # apply tank overrides\n    self.tank.apply_overrides(overrides)\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.distribute","title":"<code>distribute()</code>","text":"<p>Optional function that discharges all tank storage with push_distributed.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def distribute(self):\n    \"\"\"Optional function that discharges all tank storage with push_distributed.\"\"\"\n    # Distribute any active storage\n    storage = self.tank.pull_storage(self.tank.get_avail())\n    retained = self.push_distributed(storage)\n    _ = self.tank.push_storage(retained, force=True)\n    if retained[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"Storage unable to push\")\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.end_timestep","title":"<code>end_timestep()</code>","text":"<p>Update tank states.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def end_timestep(self):\n    \"\"\"Update tank states.\"\"\"\n    self.tank.end_timestep()\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.get_percent","title":"<code>get_percent()</code>","text":"<p>Function that returns the volume in the storage tank expressed as a percent of capacity.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def get_percent(self):\n    \"\"\"Function that returns the volume in the storage tank expressed as a percent\n    of capacity.\"\"\"\n    return self.tank.storage[\"volume\"] / self.tank.capacity\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.push_set_storage","title":"<code>push_set_storage(vqip)</code>","text":"<p>A node wrapper for the tank push_storage.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to push to the tank</p> required <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>A VQIP amount that was not successfully pushed</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def push_set_storage(self, vqip):\n    \"\"\"A node wrapper for the tank push_storage.\n\n    Args:\n        vqip (dict): A VQIP amount to push to the tank\n\n    Returns:\n        reply (dict): A VQIP amount that was not successfully pushed\n    \"\"\"\n    # Update tank\n    reply = self.tank.push_storage(vqip)\n\n    return reply\n</code></pre>"},{"location":"reference-storage/#wsimod.nodes.storage.Storage.reinit","title":"<code>reinit()</code>","text":"<p>Call tank reinit.</p> Source code in <code>wsimod/nodes/storage.py</code> <pre><code>def reinit(self):\n    \"\"\"Call tank reinit.\"\"\"\n    # TODO Automate this better\n    self.tank.reinit()\n    self.tank.storage[\"volume\"] = self.initial_storage\n    self.tank.storage_[\"volume\"] = self.initial_storage\n</code></pre>"},{"location":"reference-wtw/","title":"API Reference - WTW","text":"<p>This section of the documentation provides a reference for the API of the nodes.wtw module.</p> <p>Created on Mon Nov 15 14:20:36 2021.</p> <p>@author: bdobson Converted to totals on 2022-05-03</p>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW","title":"<code>FWTW</code>","text":"<p>               Bases: <code>WTW</code></p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>class FWTW(WTW):\n    \"\"\"\"\"\"\n\n    def __init__(\n        self,\n        service_reservoir_storage_capacity=10,\n        service_reservoir_storage_area=1,\n        service_reservoir_storage_elevation=10,\n        service_reservoir_initial_storage=0,\n        data_input_dict={},\n        **kwargs,\n    ):\n        \"\"\"A freshwater treatment works wrapper for WTW. Contains service reservoirs\n        that treated water is released to and pulled from. Cannot allow deficit (thus\n        any deficit is satisfied by water entering the model 'via other means'). Liquor\n        and solids are sent to sewers.\n\n        Args:\n            service_reservoir_storage_capacity (float, optional): Capacity of service\n                reservoirs. Defaults to 10.\n            service_reservoir_storage_area (float, optional): Area of service\n                reservoirs. Defaults to 1.\n            service_reservoir_storage_elevation (float, optional): Datum of service\n                reservoirs. Defaults to 10.\n            service_reservoir_initial_storage (float or dict, optional): initial\n                storage of service reservoirs (see nodes.py/Tank for details).\n                Defaults to 0.\n            data_input_dict (dict, optional): Dictionary of data inputs relevant for\n                the node (though I don't think it is used). Defaults to {}.\n\n        Functions intended to call in orchestration:\n            treat_water\n\n        Key assumptions:\n            - See `wtw.py/WTW` for treatment.\n            - Stores treated water in a service reservoir tank, with a single tank\n                per `FWTW` node.\n            - Aims to satisfy a throughput that would top up the service reservoirs\n                until full.\n            - Currently, will not allow a deficit, thus introducing water from\n                'other measures' if pulls cannot fulfil demand. Behaviour under a\n                deficit should be determined and validated before introducing.\n\n        Input data and parameter requirements:\n            - See `wtw.py/WTW` for treatment.\n            - Service reservoir tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n        \"\"\"\n        # Default parameters\n        self.service_reservoir_storage_capacity = service_reservoir_storage_capacity\n        self.service_reservoir_storage_area = service_reservoir_storage_area\n        self.service_reservoir_storage_elevation = service_reservoir_storage_elevation\n        self.service_reservoir_initial_storage = service_reservoir_initial_storage\n        # TODO don't think data_input_dict is used\n        self.data_input_dict = data_input_dict\n\n        # Update args\n        super().__init__(**kwargs)\n        self.end_timestep = self.end_timestep_\n\n        # Update handlers\n        self.pull_set_handler[\"default\"] = self.pull_set_fwtw\n        self.pull_check_handler[\"default\"] = self.pull_check_fwtw\n\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_check_deny\n\n        # Initialise parameters\n        self.total_deficit = self.empty_vqip()\n        self.total_pulled = self.empty_vqip()\n        self.previous_pulled = self.empty_vqip()\n        self.unpushed_sludge = self.empty_vqip()\n\n        # Create tanks\n        self.service_reservoir_tank = Tank(\n            capacity=self.service_reservoir_storage_capacity,\n            area=self.service_reservoir_storage_area,\n            datum=self.service_reservoir_storage_elevation,\n            initial_storage=self.service_reservoir_initial_storage,\n        )\n        # self.service_reservoir_tank.storage['volume'] =\n        # self.service_reservoir_inital_storage\n        # self.service_reservoir_tank.storage_['volume'] =\n        # self.service_reservoir_inital_storage\n\n        # Mass balance\n        self.mass_balance_in.append(lambda: self.total_deficit)\n        self.mass_balance_ds.append(lambda: self.service_reservoir_tank.ds())\n        self.mass_balance_out.append(lambda: self.unpushed_sludge)\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Apply overrides to the service reservoir tank and FWTW.\n\n        Enables a user to override any parameter of the service reservoir tank, and\n        then calls any overrides in WTW.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.service_reservoir_storage_capacity = overrides.pop(\n            \"service_reservoir_storage_capacity\",\n            self.service_reservoir_storage_capacity,\n        )\n        self.service_reservoir_storage_area = overrides.pop(\n            \"service_reservoir_storage_area\", self.service_reservoir_storage_area\n        )\n        self.service_reservoir_storage_elevation = overrides.pop(\n            \"service_reservoir_storage_elevation\",\n            self.service_reservoir_storage_elevation,\n        )\n\n        self.service_reservoir_tank.capacity = self.service_reservoir_storage_capacity\n        self.service_reservoir_tank.area = self.service_reservoir_storage_area\n        self.service_reservoir_tank.datum = self.service_reservoir_storage_elevation\n        super().apply_overrides(overrides)\n\n    def treat_water(self):\n        \"\"\"Pulls water, aiming to fill service reservoirs, calls WTW\n        treat_current_input, avoids deficit, sends liquor and solids to sewers.\"\"\"\n        # Calculate how much water is needed\n        target_throughput = self.service_reservoir_tank.get_excess()\n        target_throughput = min(\n            target_throughput[\"volume\"], self.treatment_throughput_capacity\n        )\n\n        # Pull water\n        throughput = self.pull_distributed({\"volume\": target_throughput})\n\n        # Calculate deficit (assume is equal to difference between previous treated\n        # throughput and current throughput)\n        # TODO think about this a bit more\n        deficit = max(target_throughput - throughput[\"volume\"], 0)\n        # deficit = max(self.previous_pulled['volume'] - throughput['volume'], 0)\n        deficit = self.v_change_vqip(self.previous_pulled, deficit)\n\n        # Introduce deficit\n        self.current_input = self.sum_vqip(throughput, deficit)\n\n        # Track deficit\n        self.total_deficit = self.sum_vqip(self.total_deficit, deficit)\n\n        if self.total_deficit[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\n                \"Service reservoirs not filled at {0} on {1}\".format(self.name, self.t)\n            )\n\n        # Run treatment processes\n        self.treat_current_input()\n\n        # Discharge liquor and solids to sewers\n        push_back = self.sum_vqip(self.liquor, self.solids)\n        rejected = self.push_distributed(push_back, of_type=\"Sewer\")\n        self.unpushed_sludge = self.sum_vqip(self.unpushed_sludge, rejected)\n        if rejected[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            print(\"nowhere for sludge to go\")\n\n        # Send water to service reservoirs\n        excess = self.service_reservoir_tank.push_storage(self.treated)\n        _ = self.service_reservoir_tank.push_storage(excess, force=True)\n        if excess[\"volume\"] &gt; 0:\n            print(\"excess treated water\")\n\n    def pull_check_fwtw(self, vqip=None):\n        \"\"\"Pull checks query service reservoirs.\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            (dict): A VQIP of availability in service reservoirs\n        \"\"\"\n        return self.service_reservoir_tank.get_avail(vqip)\n\n    def pull_set_fwtw(self, vqip):\n        \"\"\"Pull treated water from service reservoirs.\n\n        Args:\n            vqip (dict): a VQIP amount to pull\n\n        Returns:\n            pulled (dict): A VQIP amount that was successfully pulled\n        \"\"\"\n        # Pull\n        pulled = self.service_reservoir_tank.pull_storage(vqip)\n        # Update total_pulled this timestep\n        self.total_pulled = self.sum_vqip(self.total_pulled, pulled)\n        return pulled\n\n    def end_timestep_(self):\n        \"\"\"Update state variables.\"\"\"\n        self.service_reservoir_tank.end_timestep()\n        self.total_deficit = self.empty_vqip()\n        self.previous_pulled = self.copy_vqip(self.total_pulled)\n        self.total_pulled = self.empty_vqip()\n        self.treated = self.empty_vqip()\n        self.unpushed_sludge = self.empty_vqip()\n\n    def reinit(self):\n        \"\"\"Call tank reinit.\"\"\"\n        self.service_reservoir_tank.reinit()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.__init__","title":"<code>__init__(service_reservoir_storage_capacity=10, service_reservoir_storage_area=1, service_reservoir_storage_elevation=10, service_reservoir_initial_storage=0, data_input_dict={}, **kwargs)</code>","text":"<p>A freshwater treatment works wrapper for WTW. Contains service reservoirs that treated water is released to and pulled from. Cannot allow deficit (thus any deficit is satisfied by water entering the model 'via other means'). Liquor and solids are sent to sewers.</p> <p>Parameters:</p> Name Type Description Default <code>service_reservoir_storage_capacity</code> <code>float</code> <p>Capacity of service reservoirs. Defaults to 10.</p> <code>10</code> <code>service_reservoir_storage_area</code> <code>float</code> <p>Area of service reservoirs. Defaults to 1.</p> <code>1</code> <code>service_reservoir_storage_elevation</code> <code>float</code> <p>Datum of service reservoirs. Defaults to 10.</p> <code>10</code> <code>service_reservoir_initial_storage</code> <code>float or dict</code> <p>initial storage of service reservoirs (see nodes.py/Tank for details). Defaults to 0.</p> <code>0</code> <code>data_input_dict</code> <code>dict</code> <p>Dictionary of data inputs relevant for the node (though I don't think it is used). Defaults to {}.</p> <code>{}</code> Functions intended to call in orchestration <p>treat_water</p> Key assumptions <ul> <li>See <code>wtw.py/WTW</code> for treatment.</li> <li>Stores treated water in a service reservoir tank, with a single tank     per <code>FWTW</code> node.</li> <li>Aims to satisfy a throughput that would top up the service reservoirs     until full.</li> <li>Currently, will not allow a deficit, thus introducing water from     'other measures' if pulls cannot fulfil demand. Behaviour under a     deficit should be determined and validated before introducing.</li> </ul> Input data and parameter requirements <ul> <li>See <code>wtw.py/WTW</code> for treatment.</li> <li>Service reservoir tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> </ul> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def __init__(\n    self,\n    service_reservoir_storage_capacity=10,\n    service_reservoir_storage_area=1,\n    service_reservoir_storage_elevation=10,\n    service_reservoir_initial_storage=0,\n    data_input_dict={},\n    **kwargs,\n):\n    \"\"\"A freshwater treatment works wrapper for WTW. Contains service reservoirs\n    that treated water is released to and pulled from. Cannot allow deficit (thus\n    any deficit is satisfied by water entering the model 'via other means'). Liquor\n    and solids are sent to sewers.\n\n    Args:\n        service_reservoir_storage_capacity (float, optional): Capacity of service\n            reservoirs. Defaults to 10.\n        service_reservoir_storage_area (float, optional): Area of service\n            reservoirs. Defaults to 1.\n        service_reservoir_storage_elevation (float, optional): Datum of service\n            reservoirs. Defaults to 10.\n        service_reservoir_initial_storage (float or dict, optional): initial\n            storage of service reservoirs (see nodes.py/Tank for details).\n            Defaults to 0.\n        data_input_dict (dict, optional): Dictionary of data inputs relevant for\n            the node (though I don't think it is used). Defaults to {}.\n\n    Functions intended to call in orchestration:\n        treat_water\n\n    Key assumptions:\n        - See `wtw.py/WTW` for treatment.\n        - Stores treated water in a service reservoir tank, with a single tank\n            per `FWTW` node.\n        - Aims to satisfy a throughput that would top up the service reservoirs\n            until full.\n        - Currently, will not allow a deficit, thus introducing water from\n            'other measures' if pulls cannot fulfil demand. Behaviour under a\n            deficit should be determined and validated before introducing.\n\n    Input data and parameter requirements:\n        - See `wtw.py/WTW` for treatment.\n        - Service reservoir tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n    \"\"\"\n    # Default parameters\n    self.service_reservoir_storage_capacity = service_reservoir_storage_capacity\n    self.service_reservoir_storage_area = service_reservoir_storage_area\n    self.service_reservoir_storage_elevation = service_reservoir_storage_elevation\n    self.service_reservoir_initial_storage = service_reservoir_initial_storage\n    # TODO don't think data_input_dict is used\n    self.data_input_dict = data_input_dict\n\n    # Update args\n    super().__init__(**kwargs)\n    self.end_timestep = self.end_timestep_\n\n    # Update handlers\n    self.pull_set_handler[\"default\"] = self.pull_set_fwtw\n    self.pull_check_handler[\"default\"] = self.pull_check_fwtw\n\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_check_deny\n\n    # Initialise parameters\n    self.total_deficit = self.empty_vqip()\n    self.total_pulled = self.empty_vqip()\n    self.previous_pulled = self.empty_vqip()\n    self.unpushed_sludge = self.empty_vqip()\n\n    # Create tanks\n    self.service_reservoir_tank = Tank(\n        capacity=self.service_reservoir_storage_capacity,\n        area=self.service_reservoir_storage_area,\n        datum=self.service_reservoir_storage_elevation,\n        initial_storage=self.service_reservoir_initial_storage,\n    )\n    # self.service_reservoir_tank.storage['volume'] =\n    # self.service_reservoir_inital_storage\n    # self.service_reservoir_tank.storage_['volume'] =\n    # self.service_reservoir_inital_storage\n\n    # Mass balance\n    self.mass_balance_in.append(lambda: self.total_deficit)\n    self.mass_balance_ds.append(lambda: self.service_reservoir_tank.ds())\n    self.mass_balance_out.append(lambda: self.unpushed_sludge)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Apply overrides to the service reservoir tank and FWTW.</p> <p>Enables a user to override any parameter of the service reservoir tank, and then calls any overrides in WTW.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Apply overrides to the service reservoir tank and FWTW.\n\n    Enables a user to override any parameter of the service reservoir tank, and\n    then calls any overrides in WTW.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.service_reservoir_storage_capacity = overrides.pop(\n        \"service_reservoir_storage_capacity\",\n        self.service_reservoir_storage_capacity,\n    )\n    self.service_reservoir_storage_area = overrides.pop(\n        \"service_reservoir_storage_area\", self.service_reservoir_storage_area\n    )\n    self.service_reservoir_storage_elevation = overrides.pop(\n        \"service_reservoir_storage_elevation\",\n        self.service_reservoir_storage_elevation,\n    )\n\n    self.service_reservoir_tank.capacity = self.service_reservoir_storage_capacity\n    self.service_reservoir_tank.area = self.service_reservoir_storage_area\n    self.service_reservoir_tank.datum = self.service_reservoir_storage_elevation\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.end_timestep_","title":"<code>end_timestep_()</code>","text":"<p>Update state variables.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def end_timestep_(self):\n    \"\"\"Update state variables.\"\"\"\n    self.service_reservoir_tank.end_timestep()\n    self.total_deficit = self.empty_vqip()\n    self.previous_pulled = self.copy_vqip(self.total_pulled)\n    self.total_pulled = self.empty_vqip()\n    self.treated = self.empty_vqip()\n    self.unpushed_sludge = self.empty_vqip()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.pull_check_fwtw","title":"<code>pull_check_fwtw(vqip=None)</code>","text":"<p>Pull checks query service reservoirs.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP of availability in service reservoirs</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def pull_check_fwtw(self, vqip=None):\n    \"\"\"Pull checks query service reservoirs.\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        (dict): A VQIP of availability in service reservoirs\n    \"\"\"\n    return self.service_reservoir_tank.get_avail(vqip)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.pull_set_fwtw","title":"<code>pull_set_fwtw(vqip)</code>","text":"<p>Pull treated water from service reservoirs.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>a VQIP amount to pull</p> required <p>Returns:</p> Name Type Description <code>pulled</code> <code>dict</code> <p>A VQIP amount that was successfully pulled</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def pull_set_fwtw(self, vqip):\n    \"\"\"Pull treated water from service reservoirs.\n\n    Args:\n        vqip (dict): a VQIP amount to pull\n\n    Returns:\n        pulled (dict): A VQIP amount that was successfully pulled\n    \"\"\"\n    # Pull\n    pulled = self.service_reservoir_tank.pull_storage(vqip)\n    # Update total_pulled this timestep\n    self.total_pulled = self.sum_vqip(self.total_pulled, pulled)\n    return pulled\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.reinit","title":"<code>reinit()</code>","text":"<p>Call tank reinit.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def reinit(self):\n    \"\"\"Call tank reinit.\"\"\"\n    self.service_reservoir_tank.reinit()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.FWTW.treat_water","title":"<code>treat_water()</code>","text":"<p>Pulls water, aiming to fill service reservoirs, calls WTW treat_current_input, avoids deficit, sends liquor and solids to sewers.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def treat_water(self):\n    \"\"\"Pulls water, aiming to fill service reservoirs, calls WTW\n    treat_current_input, avoids deficit, sends liquor and solids to sewers.\"\"\"\n    # Calculate how much water is needed\n    target_throughput = self.service_reservoir_tank.get_excess()\n    target_throughput = min(\n        target_throughput[\"volume\"], self.treatment_throughput_capacity\n    )\n\n    # Pull water\n    throughput = self.pull_distributed({\"volume\": target_throughput})\n\n    # Calculate deficit (assume is equal to difference between previous treated\n    # throughput and current throughput)\n    # TODO think about this a bit more\n    deficit = max(target_throughput - throughput[\"volume\"], 0)\n    # deficit = max(self.previous_pulled['volume'] - throughput['volume'], 0)\n    deficit = self.v_change_vqip(self.previous_pulled, deficit)\n\n    # Introduce deficit\n    self.current_input = self.sum_vqip(throughput, deficit)\n\n    # Track deficit\n    self.total_deficit = self.sum_vqip(self.total_deficit, deficit)\n\n    if self.total_deficit[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\n            \"Service reservoirs not filled at {0} on {1}\".format(self.name, self.t)\n        )\n\n    # Run treatment processes\n    self.treat_current_input()\n\n    # Discharge liquor and solids to sewers\n    push_back = self.sum_vqip(self.liquor, self.solids)\n    rejected = self.push_distributed(push_back, of_type=\"Sewer\")\n    self.unpushed_sludge = self.sum_vqip(self.unpushed_sludge, rejected)\n    if rejected[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        print(\"nowhere for sludge to go\")\n\n    # Send water to service reservoirs\n    excess = self.service_reservoir_tank.push_storage(self.treated)\n    _ = self.service_reservoir_tank.push_storage(excess, force=True)\n    if excess[\"volume\"] &gt; 0:\n        print(\"excess treated water\")\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW","title":"<code>WTW</code>","text":"<p>               Bases: <code>Node</code></p> <p>A generic Water Treatment Works (WTW) node.</p> <p>This class is a generic water treatment works node. It is intended to be subclassed into freshwater and wastewater treatment works (FWTW and WWTW respectively).</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>class WTW(Node):\n    \"\"\"A generic Water Treatment Works (WTW) node.\n\n    This class is a generic water treatment works node. It is intended to be\n    subclassed into freshwater and wastewater treatment works (FWTW and WWTW\n    respectively).\n    \"\"\"\n\n    def __init__(\n        self,\n        name,\n        treatment_throughput_capacity=10,\n        process_parameters={},\n        liquor_multiplier={},\n        percent_solids=0.0002,\n    ):\n        \"\"\"Generic treatment processes that apply temperature a sensitive transform of\n        pollutants into liquor and solids (behaviour depends on subclass). Push requests\n        are stored in the current_input state variable, but treatment must be triggered\n        with treat_current_input. This treated water is stored in the discharge_holder\n        state variable, which will be sent different depending on FWTW/WWTW.\n\n        Args:\n            name (str): Node name\n            treatment_throughput_capacity (float, optional): Amount of volume per\n                timestep of water that can be treated. Defaults to 10.\n            process_parameters (dict, optional): Dict of dicts for each pollutant.\n                Top level key describes pollutant. Next level key describes the\n                constant portion of the transform and the temperature sensitive\n                exponent portion (see core.py/DecayObj for more detailed\n                explanation). Defaults to {}.\n            liquor_multiplier (dict, optional): Keys for each pollutant that\n                describes how much influent becomes liquor. Defaults to {}.\n            percent_solids (float, optional): Proportion of volume that becomes solids.\n                All pollutants that do not become effluent or liquor become solids.\n                Defaults to 0.0002.\n\n        Functions intended to call in orchestration:\n            None (use FWTW or WWTW subclass)\n\n        Key assumptions:\n            - Throughput can be modelled entirely with a set capacity.\n            - Pollutant reduction for the entire treatment process can be modelled\n                primarily with a single (temperature sensitive) transformation for\n                each pollutant.\n            - Liquor and solids are tracked and calculated with proportional\n                multiplier parameters.\n\n        Input data and parameter requirements:\n            - `treatment_throughput_capacity`\n                _Units_: cubic metres/timestep\n            - `process_parameters` contains the constant (non temperature\n                sensitive) and exponent (temperature sensitive) transformations\n                applied to treated water for each pollutant.\n                _Units_: -\n            - `liquor_multiplier` and `percent_solids` describe the proportion of\n                throughput that goes to liquor/solids.\n        \"\"\"\n        # Set/Default parameters\n        self.treatment_throughput_capacity = treatment_throughput_capacity\n        if len(process_parameters) &gt; 0:\n            self.process_parameters = process_parameters\n        else:\n            self.process_parameters = {\n                x: {\"constant\": 0.01, \"exponent\": 1.001}\n                for x in constants.ADDITIVE_POLLUTANTS\n            }\n        if len(liquor_multiplier) &gt; 0:\n            self._liquor_multiplier = liquor_multiplier\n        else:\n            self._liquor_multiplier = {x: 0.7 for x in constants.ADDITIVE_POLLUTANTS}\n            self._liquor_multiplier[\"volume\"] = 0.03\n\n        self._percent_solids = percent_solids\n\n        # Update args\n        super().__init__(name)\n\n        self.process_parameters[\"volume\"] = {\"constant\": self.calculate_volume()}\n\n        # Update handlers\n        self.push_set_handler[\"default\"] = self.push_set_deny\n        self.push_check_handler[\"default\"] = self.push_check_deny\n\n        # Initialise parameters\n        self.current_input = self.empty_vqip()\n        self.treated = self.empty_vqip()\n        self.liquor = self.empty_vqip()\n        self.solids = self.empty_vqip()\n\n    def calculate_volume(self):\n        \"\"\"Calculate the volume proportion of treated water.\n\n        Returns:\n            (float): Volume of treated water\n        \"\"\"\n        return 1 - self._percent_solids - self._liquor_multiplier[\"volume\"]\n\n    @property\n    def percent_solids(self):\n        return self._percent_solids\n\n    @percent_solids.setter\n    def percent_solids(self, value):\n        self._percent_solids = value\n        self.process_parameters[\"volume\"][\"constant\"] = self.calculate_volume()\n\n    @property\n    def liquor_multiplier(self):\n        return self._liquor_multiplier\n\n    @liquor_multiplier.setter\n    def liquor_multiplier(self, value):\n        self._liquor_multiplier.update(value)\n        self.process_parameters[\"volume\"][\"constant\"] = self.calculate_volume()\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Override parameters.\n\n        Enables a user to override any of the following parameters:\n        percent_solids, treatment_throughput_capacity, process_parameters (the\n        entire dict does not need to be redefined, only changed values need to\n        be included), liquor_multiplier (as with process_parameters).\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.percent_solids = overrides.pop(\"percent_solids\", self._percent_solids)\n        self.liquor_multiplier = overrides.pop(\n            \"liquor_multiplier\", self._liquor_multiplier\n        )\n        process_parameters = overrides.pop(\"process_parameters\", {})\n        for key, value in process_parameters.items():\n            self.process_parameters[key].update(value)\n\n        self.treatment_throughput_capacity = overrides.pop(\n            \"treatment_throughput_capacity\", self.treatment_throughput_capacity\n        )\n        super().apply_overrides(overrides)\n\n    def get_excess_throughput(self):\n        \"\"\"How much excess treatment capacity is there.\n\n        Returns:\n            (float): Amount of volume that can still be treated this timestep\n        \"\"\"\n        return max(self.treatment_throughput_capacity - self.current_input[\"volume\"], 0)\n\n    def treat_current_input(self):\n        \"\"\"Run treatment processes this timestep, including temperature sensitive\n        transforms, liquoring, solids.\"\"\"\n        # Treat current input\n        influent = self.copy_vqip(self.current_input)\n\n        # Calculate effluent, liquor and solids\n        discharge_holder = self.empty_vqip()\n\n        # Assume non-additive pollutants are unchanged in discharge and are\n        # proportionately mixed in liquor\n        for key in constants.NON_ADDITIVE_POLLUTANTS:\n            discharge_holder[key] = influent[key]\n            self.liquor[key] = (\n                self.liquor[key] * self.liquor[\"volume\"]\n                + influent[key] * influent[\"volume\"] * self.liquor_multiplier[\"volume\"]\n            ) / (\n                self.liquor[\"volume\"]\n                + influent[\"volume\"] * self.liquor_multiplier[\"volume\"]\n            )\n\n        # TODO this should probably just be for process_parameters.keys() to avoid\n        # having to declare non changing parameters\n        # TODO should the liquoring be temperature sensitive too? As it is the solids\n        # will take the brunt of the temperature variability which maybe isn't sensible\n        for key in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n            if key != \"volume\":\n                # Temperature sensitive transform\n                temp_factor = self.process_parameters[key][\"exponent\"] ** (\n                    constants.DECAY_REFERENCE_TEMPERATURE - influent[\"temperature\"]\n                )\n            else:\n                temp_factor = 1\n            # Calculate discharge\n            discharge_holder[key] = (\n                influent[key] * self.process_parameters[key][\"constant\"] * temp_factor\n            )\n            # Calculate liquor\n            self.liquor[key] = influent[key] * self.liquor_multiplier[key]\n\n        # Calculate solids volume\n        self.solids[\"volume\"] = influent[\"volume\"] * self.percent_solids\n\n        # All remaining pollutants go to solids\n        for key in constants.ADDITIVE_POLLUTANTS:\n            self.solids[key] = influent[key] - discharge_holder[key] - self.liquor[key]\n\n        # Blend with any existing discharge\n        self.treated = self.sum_vqip(self.treated, discharge_holder)\n\n        if self.treated[\"volume\"] &gt; self.current_input[\"volume\"]:\n            print(\"more treated than input\")\n\n    def end_timestep(self):\n        \"\"\"\"\"\"\n        # Reset state variables\n        self.current_input = self.empty_vqip()\n        self.treated = self.empty_vqip()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.__init__","title":"<code>__init__(name, treatment_throughput_capacity=10, process_parameters={}, liquor_multiplier={}, percent_solids=0.0002)</code>","text":"<p>Generic treatment processes that apply temperature a sensitive transform of pollutants into liquor and solids (behaviour depends on subclass). Push requests are stored in the current_input state variable, but treatment must be triggered with treat_current_input. This treated water is stored in the discharge_holder state variable, which will be sent different depending on FWTW/WWTW.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Node name</p> required <code>treatment_throughput_capacity</code> <code>float</code> <p>Amount of volume per timestep of water that can be treated. Defaults to 10.</p> <code>10</code> <code>process_parameters</code> <code>dict</code> <p>Dict of dicts for each pollutant. Top level key describes pollutant. Next level key describes the constant portion of the transform and the temperature sensitive exponent portion (see core.py/DecayObj for more detailed explanation). Defaults to {}.</p> <code>{}</code> <code>liquor_multiplier</code> <code>dict</code> <p>Keys for each pollutant that describes how much influent becomes liquor. Defaults to {}.</p> <code>{}</code> <code>percent_solids</code> <code>float</code> <p>Proportion of volume that becomes solids. All pollutants that do not become effluent or liquor become solids. Defaults to 0.0002.</p> <code>0.0002</code> Functions intended to call in orchestration <p>None (use FWTW or WWTW subclass)</p> Key assumptions <ul> <li>Throughput can be modelled entirely with a set capacity.</li> <li>Pollutant reduction for the entire treatment process can be modelled     primarily with a single (temperature sensitive) transformation for     each pollutant.</li> <li>Liquor and solids are tracked and calculated with proportional     multiplier parameters.</li> </ul> Input data and parameter requirements <ul> <li><code>treatment_throughput_capacity</code> Units: cubic metres/timestep</li> <li><code>process_parameters</code> contains the constant (non temperature     sensitive) and exponent (temperature sensitive) transformations     applied to treated water for each pollutant.     Units: -</li> <li><code>liquor_multiplier</code> and <code>percent_solids</code> describe the proportion of     throughput that goes to liquor/solids.</li> </ul> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def __init__(\n    self,\n    name,\n    treatment_throughput_capacity=10,\n    process_parameters={},\n    liquor_multiplier={},\n    percent_solids=0.0002,\n):\n    \"\"\"Generic treatment processes that apply temperature a sensitive transform of\n    pollutants into liquor and solids (behaviour depends on subclass). Push requests\n    are stored in the current_input state variable, but treatment must be triggered\n    with treat_current_input. This treated water is stored in the discharge_holder\n    state variable, which will be sent different depending on FWTW/WWTW.\n\n    Args:\n        name (str): Node name\n        treatment_throughput_capacity (float, optional): Amount of volume per\n            timestep of water that can be treated. Defaults to 10.\n        process_parameters (dict, optional): Dict of dicts for each pollutant.\n            Top level key describes pollutant. Next level key describes the\n            constant portion of the transform and the temperature sensitive\n            exponent portion (see core.py/DecayObj for more detailed\n            explanation). Defaults to {}.\n        liquor_multiplier (dict, optional): Keys for each pollutant that\n            describes how much influent becomes liquor. Defaults to {}.\n        percent_solids (float, optional): Proportion of volume that becomes solids.\n            All pollutants that do not become effluent or liquor become solids.\n            Defaults to 0.0002.\n\n    Functions intended to call in orchestration:\n        None (use FWTW or WWTW subclass)\n\n    Key assumptions:\n        - Throughput can be modelled entirely with a set capacity.\n        - Pollutant reduction for the entire treatment process can be modelled\n            primarily with a single (temperature sensitive) transformation for\n            each pollutant.\n        - Liquor and solids are tracked and calculated with proportional\n            multiplier parameters.\n\n    Input data and parameter requirements:\n        - `treatment_throughput_capacity`\n            _Units_: cubic metres/timestep\n        - `process_parameters` contains the constant (non temperature\n            sensitive) and exponent (temperature sensitive) transformations\n            applied to treated water for each pollutant.\n            _Units_: -\n        - `liquor_multiplier` and `percent_solids` describe the proportion of\n            throughput that goes to liquor/solids.\n    \"\"\"\n    # Set/Default parameters\n    self.treatment_throughput_capacity = treatment_throughput_capacity\n    if len(process_parameters) &gt; 0:\n        self.process_parameters = process_parameters\n    else:\n        self.process_parameters = {\n            x: {\"constant\": 0.01, \"exponent\": 1.001}\n            for x in constants.ADDITIVE_POLLUTANTS\n        }\n    if len(liquor_multiplier) &gt; 0:\n        self._liquor_multiplier = liquor_multiplier\n    else:\n        self._liquor_multiplier = {x: 0.7 for x in constants.ADDITIVE_POLLUTANTS}\n        self._liquor_multiplier[\"volume\"] = 0.03\n\n    self._percent_solids = percent_solids\n\n    # Update args\n    super().__init__(name)\n\n    self.process_parameters[\"volume\"] = {\"constant\": self.calculate_volume()}\n\n    # Update handlers\n    self.push_set_handler[\"default\"] = self.push_set_deny\n    self.push_check_handler[\"default\"] = self.push_check_deny\n\n    # Initialise parameters\n    self.current_input = self.empty_vqip()\n    self.treated = self.empty_vqip()\n    self.liquor = self.empty_vqip()\n    self.solids = self.empty_vqip()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Override parameters.</p> <p>Enables a user to override any of the following parameters: percent_solids, treatment_throughput_capacity, process_parameters (the entire dict does not need to be redefined, only changed values need to be included), liquor_multiplier (as with process_parameters).</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Override parameters.\n\n    Enables a user to override any of the following parameters:\n    percent_solids, treatment_throughput_capacity, process_parameters (the\n    entire dict does not need to be redefined, only changed values need to\n    be included), liquor_multiplier (as with process_parameters).\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.percent_solids = overrides.pop(\"percent_solids\", self._percent_solids)\n    self.liquor_multiplier = overrides.pop(\n        \"liquor_multiplier\", self._liquor_multiplier\n    )\n    process_parameters = overrides.pop(\"process_parameters\", {})\n    for key, value in process_parameters.items():\n        self.process_parameters[key].update(value)\n\n    self.treatment_throughput_capacity = overrides.pop(\n        \"treatment_throughput_capacity\", self.treatment_throughput_capacity\n    )\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.calculate_volume","title":"<code>calculate_volume()</code>","text":"<p>Calculate the volume proportion of treated water.</p> <p>Returns:</p> Type Description <code>float</code> <p>Volume of treated water</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def calculate_volume(self):\n    \"\"\"Calculate the volume proportion of treated water.\n\n    Returns:\n        (float): Volume of treated water\n    \"\"\"\n    return 1 - self._percent_solids - self._liquor_multiplier[\"volume\"]\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.end_timestep","title":"<code>end_timestep()</code>","text":"Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def end_timestep(self):\n    \"\"\"\"\"\"\n    # Reset state variables\n    self.current_input = self.empty_vqip()\n    self.treated = self.empty_vqip()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.get_excess_throughput","title":"<code>get_excess_throughput()</code>","text":"<p>How much excess treatment capacity is there.</p> <p>Returns:</p> Type Description <code>float</code> <p>Amount of volume that can still be treated this timestep</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def get_excess_throughput(self):\n    \"\"\"How much excess treatment capacity is there.\n\n    Returns:\n        (float): Amount of volume that can still be treated this timestep\n    \"\"\"\n    return max(self.treatment_throughput_capacity - self.current_input[\"volume\"], 0)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WTW.treat_current_input","title":"<code>treat_current_input()</code>","text":"<p>Run treatment processes this timestep, including temperature sensitive transforms, liquoring, solids.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def treat_current_input(self):\n    \"\"\"Run treatment processes this timestep, including temperature sensitive\n    transforms, liquoring, solids.\"\"\"\n    # Treat current input\n    influent = self.copy_vqip(self.current_input)\n\n    # Calculate effluent, liquor and solids\n    discharge_holder = self.empty_vqip()\n\n    # Assume non-additive pollutants are unchanged in discharge and are\n    # proportionately mixed in liquor\n    for key in constants.NON_ADDITIVE_POLLUTANTS:\n        discharge_holder[key] = influent[key]\n        self.liquor[key] = (\n            self.liquor[key] * self.liquor[\"volume\"]\n            + influent[key] * influent[\"volume\"] * self.liquor_multiplier[\"volume\"]\n        ) / (\n            self.liquor[\"volume\"]\n            + influent[\"volume\"] * self.liquor_multiplier[\"volume\"]\n        )\n\n    # TODO this should probably just be for process_parameters.keys() to avoid\n    # having to declare non changing parameters\n    # TODO should the liquoring be temperature sensitive too? As it is the solids\n    # will take the brunt of the temperature variability which maybe isn't sensible\n    for key in constants.ADDITIVE_POLLUTANTS + [\"volume\"]:\n        if key != \"volume\":\n            # Temperature sensitive transform\n            temp_factor = self.process_parameters[key][\"exponent\"] ** (\n                constants.DECAY_REFERENCE_TEMPERATURE - influent[\"temperature\"]\n            )\n        else:\n            temp_factor = 1\n        # Calculate discharge\n        discharge_holder[key] = (\n            influent[key] * self.process_parameters[key][\"constant\"] * temp_factor\n        )\n        # Calculate liquor\n        self.liquor[key] = influent[key] * self.liquor_multiplier[key]\n\n    # Calculate solids volume\n    self.solids[\"volume\"] = influent[\"volume\"] * self.percent_solids\n\n    # All remaining pollutants go to solids\n    for key in constants.ADDITIVE_POLLUTANTS:\n        self.solids[key] = influent[key] - discharge_holder[key] - self.liquor[key]\n\n    # Blend with any existing discharge\n    self.treated = self.sum_vqip(self.treated, discharge_holder)\n\n    if self.treated[\"volume\"] &gt; self.current_input[\"volume\"]:\n        print(\"more treated than input\")\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW","title":"<code>WWTW</code>","text":"<p>               Bases: <code>WTW</code></p> <p>Wastewater Treatment Works (WWTW) node.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>class WWTW(WTW):\n    \"\"\"Wastewater Treatment Works (WWTW) node.\"\"\"\n\n    def __init__(\n        self,\n        stormwater_storage_capacity=10,\n        stormwater_storage_area=1,\n        stormwater_storage_elevation=10,\n        **kwargs,\n    ):\n        \"\"\"A wastewater treatment works wrapper for WTW. Contains a temporary stormwater\n        storage tank. Liquor is combined with current_effluent and re- treated while\n        solids leave the model.\n\n        Args:\n            stormwater_storage_capacity (float, optional): Capacity of stormwater tank.\n                Defaults to 10.\n            stormwater_storage_area (float, optional): Area of stormwater tank.\n                Defaults to 1.\n            stormwater_storage_elevation (float, optional): Datum of stormwater tank.\n                Defaults to 10.\n\n        Functions intended to call in orchestration:\n            calculate_discharge\n\n            make_discharge\n\n        Key assumptions:\n            - See `wtw.py/WTW` for treatment.\n            - When `treatment_throughput_capacity` is exceeded, water is first sent\n                to a stormwater storage tank before denying pushes. Leftover water\n                in this tank aims to be treated in subsequent timesteps.\n            - Can be pulled from to simulate active wastewater effluent use.\n\n        Input data and parameter requirements:\n            - See `wtw.py/WTW` for treatment.\n            - Stormwater tank `capacity`, `area`, and `datum`.\n                _Units_: cubic metres, squared metres, metres\n        \"\"\"\n        # Set parameters\n        self.stormwater_storage_capacity = stormwater_storage_capacity\n        self.stormwater_storage_area = stormwater_storage_area\n        self.stormwater_storage_elevation = stormwater_storage_elevation\n\n        # Update args\n        super().__init__(**kwargs)\n\n        self.end_timestep = self.end_timestep_\n\n        # Update handlers\n        self.pull_set_handler[\"default\"] = self.pull_set_reuse\n        self.pull_check_handler[\"default\"] = self.pull_check_reuse\n        self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n        self.push_check_handler[\"Sewer\"] = self.push_check_sewer\n        self.push_check_handler[\"default\"] = self.push_check_sewer\n        self.push_set_handler[\"default\"] = self.push_set_sewer\n\n        # Create tank\n        self.stormwater_tank = Tank(\n            capacity=self.stormwater_storage_capacity,\n            area=self.stormwater_storage_area,\n            datum=self.stormwater_storage_elevation,\n        )\n\n        # Initialise states\n        self.liquor_ = self.empty_vqip()\n        self.previous_input = self.empty_vqip()\n        self.current_input = self.empty_vqip()  # TODO is this not done in WTW?\n\n        # Mass balance\n        self.mass_balance_out.append(lambda: self.solids)  # Assume these go to landfill\n        self.mass_balance_ds.append(lambda: self.stormwater_tank.ds())\n        self.mass_balance_ds.append(\n            lambda: self.ds_vqip(self.liquor, self.liquor_)\n        )  # Change in liquor\n\n    def apply_overrides(self, overrides=Dict[str, Any]):\n        \"\"\"Apply overrides to the stormwater tank and WWTW.\n\n        Enables a user to override any parameter of the stormwater tank, and\n        then calls any overrides in WTW.\n\n        Args:\n            overrides (Dict[str, Any]): Dict describing which parameters should\n                be overridden (keys) and new values (values). Defaults to {}.\n        \"\"\"\n        self.stormwater_storage_capacity = overrides.pop(\n            \"stormwater_storage_capacity\", self.stormwater_storage_capacity\n        )\n        self.stormwater_storage_area = overrides.pop(\n            \"stormwater_storage_area\", self.stormwater_storage_area\n        )\n        self.stormwater_storage_elevation = overrides.pop(\n            \"stormwater_storage_elevation\", self.stormwater_storage_elevation\n        )\n        self.stormwater_tank.area = self.stormwater_storage_area\n        self.stormwater_tank.capacity = self.stormwater_storage_capacity\n        self.stormwater_tank.datum = self.stormwater_storage_elevation\n        super().apply_overrides(overrides)\n\n    def calculate_discharge(self):\n        \"\"\"Clear stormwater tank if possible, and call treat_current_input.\"\"\"\n        # Run WWTW model\n\n        # Try to clear stormwater\n        # TODO (probably more tidy to use push_set_sewer? though maybe less\n        # computationally efficient)\n        excess = self.get_excess_throughput()\n        if (self.stormwater_tank.get_avail()[\"volume\"] &gt; constants.FLOAT_ACCURACY) &amp; (\n            excess &gt; constants.FLOAT_ACCURACY\n        ):\n            to_pull = min(excess, self.stormwater_tank.get_avail()[\"volume\"])\n            to_pull = self.v_change_vqip(self.stormwater_tank.storage, to_pull)\n            cleared_stormwater = self.stormwater_tank.pull_storage(to_pull)\n            self.current_input = self.sum_vqip(self.current_input, cleared_stormwater)\n\n        # Run processes\n        self.current_input = self.sum_vqip(self.current_input, self.liquor)\n        self.treat_current_input()\n\n    def make_discharge(self):\n        \"\"\"Discharge treated effluent.\"\"\"\n        reply = self.push_distributed(self.treated)\n        self.treated = self.empty_vqip()\n        if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n            _ = self.stormwater_tank.push_storage(reply, force=True)\n            print(\"WWTW couldnt push\")\n\n    def push_check_sewer(self, vqip=None):\n        \"\"\"Check throughput and stormwater tank capacity.\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            (dict): excess\n        \"\"\"\n        # Get excess\n        excess_throughput = self.get_excess_throughput()\n        excess_tank = self.stormwater_tank.get_excess()\n        # Combine tank and throughput\n        vol = excess_tank[\"volume\"] + excess_throughput\n        # Update volume\n        if vqip is None:\n            vqip = self.empty_vqip()\n        else:\n            vol = min(vol, vqip[\"volume\"])\n\n        return self.v_change_vqip(vqip, vol)\n\n    def push_set_sewer(self, vqip):\n        \"\"\"Receive water, first try to update current_input, and then stormwater tank.\n\n        Args:\n            vqip (dict): A VQIP amount to be treated and then stored\n\n        Returns:\n            (dict): A VQIP amount of water that was not treated\n        \"\"\"\n        # Receive water from sewers\n        vqip = self.copy_vqip(vqip)\n        # Check if can directly be treated\n        sent_direct = self.get_excess_throughput()\n\n        sent_direct = min(sent_direct, vqip[\"volume\"])\n\n        sent_direct = self.v_change_vqip(vqip, sent_direct)\n\n        self.current_input = self.sum_vqip(self.current_input, sent_direct)\n\n        if sent_direct[\"volume\"] == vqip[\"volume\"]:\n            # If all added to input, no problem\n            return self.empty_vqip()\n\n        # Next try temporary storage\n        vqip = self.v_change_vqip(vqip, vqip[\"volume\"] - sent_direct[\"volume\"])\n\n        vqip = self.stormwater_tank.push_storage(vqip)\n\n        if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n            return self.empty_vqip()\n        else:\n            # TODO what to do here ???\n            return vqip\n\n    def pull_set_reuse(self, vqip):\n        \"\"\"Enables WWTW to receive pulls of the treated water (i.e., for wastewater\n        reuse or satisfaction of environmental flows). Intended to be called in between\n        calculate_discharge and make_discharge.\n\n        Args:\n            vqip (dict): A VQIP amount to be pulled (only 'volume' key is used)\n\n        Returns:\n            reply (dict): Amount of water that has been pulled\n        \"\"\"\n        # Satisfy request with treated (volume)\n        reply_vol = min(vqip[\"volume\"], self.treated[\"volume\"])\n        # Update pollutants\n        reply = self.v_change_vqip(self.treated, reply_vol)\n        # Update treated\n        self.treated = self.v_change_vqip(\n            self.treated, self.treated[\"volume\"] - reply_vol\n        )\n        return reply\n\n    def pull_check_reuse(self, vqip=None):\n        \"\"\"Pull check available water. Simply returns the previous timestep's treated\n        throughput. This is of course inaccurate (which may lead to slightly longer\n        calulcations), but it is much more flexible. This hasn't been recently tested so\n        it might be that returning treated would be fine (and more accurate!).\n\n        Args:\n            vqip (dict, optional): A VQIP that can be used to limit the volume in\n                the return value (only volume key is used). Defaults to None.\n\n        Returns:\n            (dict): A VQIP amount of water available. Currently just the previous\n                timestep's treated throughput\n        \"\"\"\n        # Respond to request of water for reuse/MRF\n        return self.copy_vqip(self.treated)\n\n    def end_timestep_(self):\n        \"\"\"End timestep function to update state variables.\"\"\"\n        self.liquor_ = self.copy_vqip(self.liquor)\n        self.previous_input = self.copy_vqip(self.current_input)\n        self.current_input = self.empty_vqip()\n        self.solids = self.empty_vqip()\n        self.stormwater_tank.end_timestep()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.__init__","title":"<code>__init__(stormwater_storage_capacity=10, stormwater_storage_area=1, stormwater_storage_elevation=10, **kwargs)</code>","text":"<p>A wastewater treatment works wrapper for WTW. Contains a temporary stormwater storage tank. Liquor is combined with current_effluent and re- treated while solids leave the model.</p> <p>Parameters:</p> Name Type Description Default <code>stormwater_storage_capacity</code> <code>float</code> <p>Capacity of stormwater tank. Defaults to 10.</p> <code>10</code> <code>stormwater_storage_area</code> <code>float</code> <p>Area of stormwater tank. Defaults to 1.</p> <code>1</code> <code>stormwater_storage_elevation</code> <code>float</code> <p>Datum of stormwater tank. Defaults to 10.</p> <code>10</code> Functions intended to call in orchestration <p>calculate_discharge</p> <p>make_discharge</p> Key assumptions <ul> <li>See <code>wtw.py/WTW</code> for treatment.</li> <li>When <code>treatment_throughput_capacity</code> is exceeded, water is first sent     to a stormwater storage tank before denying pushes. Leftover water     in this tank aims to be treated in subsequent timesteps.</li> <li>Can be pulled from to simulate active wastewater effluent use.</li> </ul> Input data and parameter requirements <ul> <li>See <code>wtw.py/WTW</code> for treatment.</li> <li>Stormwater tank <code>capacity</code>, <code>area</code>, and <code>datum</code>.     Units: cubic metres, squared metres, metres</li> </ul> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def __init__(\n    self,\n    stormwater_storage_capacity=10,\n    stormwater_storage_area=1,\n    stormwater_storage_elevation=10,\n    **kwargs,\n):\n    \"\"\"A wastewater treatment works wrapper for WTW. Contains a temporary stormwater\n    storage tank. Liquor is combined with current_effluent and re- treated while\n    solids leave the model.\n\n    Args:\n        stormwater_storage_capacity (float, optional): Capacity of stormwater tank.\n            Defaults to 10.\n        stormwater_storage_area (float, optional): Area of stormwater tank.\n            Defaults to 1.\n        stormwater_storage_elevation (float, optional): Datum of stormwater tank.\n            Defaults to 10.\n\n    Functions intended to call in orchestration:\n        calculate_discharge\n\n        make_discharge\n\n    Key assumptions:\n        - See `wtw.py/WTW` for treatment.\n        - When `treatment_throughput_capacity` is exceeded, water is first sent\n            to a stormwater storage tank before denying pushes. Leftover water\n            in this tank aims to be treated in subsequent timesteps.\n        - Can be pulled from to simulate active wastewater effluent use.\n\n    Input data and parameter requirements:\n        - See `wtw.py/WTW` for treatment.\n        - Stormwater tank `capacity`, `area`, and `datum`.\n            _Units_: cubic metres, squared metres, metres\n    \"\"\"\n    # Set parameters\n    self.stormwater_storage_capacity = stormwater_storage_capacity\n    self.stormwater_storage_area = stormwater_storage_area\n    self.stormwater_storage_elevation = stormwater_storage_elevation\n\n    # Update args\n    super().__init__(**kwargs)\n\n    self.end_timestep = self.end_timestep_\n\n    # Update handlers\n    self.pull_set_handler[\"default\"] = self.pull_set_reuse\n    self.pull_check_handler[\"default\"] = self.pull_check_reuse\n    self.push_set_handler[\"Sewer\"] = self.push_set_sewer\n    self.push_check_handler[\"Sewer\"] = self.push_check_sewer\n    self.push_check_handler[\"default\"] = self.push_check_sewer\n    self.push_set_handler[\"default\"] = self.push_set_sewer\n\n    # Create tank\n    self.stormwater_tank = Tank(\n        capacity=self.stormwater_storage_capacity,\n        area=self.stormwater_storage_area,\n        datum=self.stormwater_storage_elevation,\n    )\n\n    # Initialise states\n    self.liquor_ = self.empty_vqip()\n    self.previous_input = self.empty_vqip()\n    self.current_input = self.empty_vqip()  # TODO is this not done in WTW?\n\n    # Mass balance\n    self.mass_balance_out.append(lambda: self.solids)  # Assume these go to landfill\n    self.mass_balance_ds.append(lambda: self.stormwater_tank.ds())\n    self.mass_balance_ds.append(\n        lambda: self.ds_vqip(self.liquor, self.liquor_)\n    )  # Change in liquor\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.apply_overrides","title":"<code>apply_overrides(overrides=Dict[str, Any])</code>","text":"<p>Apply overrides to the stormwater tank and WWTW.</p> <p>Enables a user to override any parameter of the stormwater tank, and then calls any overrides in WTW.</p> <p>Parameters:</p> Name Type Description Default <code>overrides</code> <code>Dict[str, Any]</code> <p>Dict describing which parameters should be overridden (keys) and new values (values). Defaults to {}.</p> <code>Dict[str, Any]</code> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def apply_overrides(self, overrides=Dict[str, Any]):\n    \"\"\"Apply overrides to the stormwater tank and WWTW.\n\n    Enables a user to override any parameter of the stormwater tank, and\n    then calls any overrides in WTW.\n\n    Args:\n        overrides (Dict[str, Any]): Dict describing which parameters should\n            be overridden (keys) and new values (values). Defaults to {}.\n    \"\"\"\n    self.stormwater_storage_capacity = overrides.pop(\n        \"stormwater_storage_capacity\", self.stormwater_storage_capacity\n    )\n    self.stormwater_storage_area = overrides.pop(\n        \"stormwater_storage_area\", self.stormwater_storage_area\n    )\n    self.stormwater_storage_elevation = overrides.pop(\n        \"stormwater_storage_elevation\", self.stormwater_storage_elevation\n    )\n    self.stormwater_tank.area = self.stormwater_storage_area\n    self.stormwater_tank.capacity = self.stormwater_storage_capacity\n    self.stormwater_tank.datum = self.stormwater_storage_elevation\n    super().apply_overrides(overrides)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.calculate_discharge","title":"<code>calculate_discharge()</code>","text":"<p>Clear stormwater tank if possible, and call treat_current_input.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def calculate_discharge(self):\n    \"\"\"Clear stormwater tank if possible, and call treat_current_input.\"\"\"\n    # Run WWTW model\n\n    # Try to clear stormwater\n    # TODO (probably more tidy to use push_set_sewer? though maybe less\n    # computationally efficient)\n    excess = self.get_excess_throughput()\n    if (self.stormwater_tank.get_avail()[\"volume\"] &gt; constants.FLOAT_ACCURACY) &amp; (\n        excess &gt; constants.FLOAT_ACCURACY\n    ):\n        to_pull = min(excess, self.stormwater_tank.get_avail()[\"volume\"])\n        to_pull = self.v_change_vqip(self.stormwater_tank.storage, to_pull)\n        cleared_stormwater = self.stormwater_tank.pull_storage(to_pull)\n        self.current_input = self.sum_vqip(self.current_input, cleared_stormwater)\n\n    # Run processes\n    self.current_input = self.sum_vqip(self.current_input, self.liquor)\n    self.treat_current_input()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.end_timestep_","title":"<code>end_timestep_()</code>","text":"<p>End timestep function to update state variables.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def end_timestep_(self):\n    \"\"\"End timestep function to update state variables.\"\"\"\n    self.liquor_ = self.copy_vqip(self.liquor)\n    self.previous_input = self.copy_vqip(self.current_input)\n    self.current_input = self.empty_vqip()\n    self.solids = self.empty_vqip()\n    self.stormwater_tank.end_timestep()\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.make_discharge","title":"<code>make_discharge()</code>","text":"<p>Discharge treated effluent.</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def make_discharge(self):\n    \"\"\"Discharge treated effluent.\"\"\"\n    reply = self.push_distributed(self.treated)\n    self.treated = self.empty_vqip()\n    if reply[\"volume\"] &gt; constants.FLOAT_ACCURACY:\n        _ = self.stormwater_tank.push_storage(reply, force=True)\n        print(\"WWTW couldnt push\")\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.pull_check_reuse","title":"<code>pull_check_reuse(vqip=None)</code>","text":"<p>Pull check available water. Simply returns the previous timestep's treated throughput. This is of course inaccurate (which may lead to slightly longer calulcations), but it is much more flexible. This hasn't been recently tested so it might be that returning treated would be fine (and more accurate!).</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water available. Currently just the previous timestep's treated throughput</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def pull_check_reuse(self, vqip=None):\n    \"\"\"Pull check available water. Simply returns the previous timestep's treated\n    throughput. This is of course inaccurate (which may lead to slightly longer\n    calulcations), but it is much more flexible. This hasn't been recently tested so\n    it might be that returning treated would be fine (and more accurate!).\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        (dict): A VQIP amount of water available. Currently just the previous\n            timestep's treated throughput\n    \"\"\"\n    # Respond to request of water for reuse/MRF\n    return self.copy_vqip(self.treated)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.pull_set_reuse","title":"<code>pull_set_reuse(vqip)</code>","text":"<p>Enables WWTW to receive pulls of the treated water (i.e., for wastewater reuse or satisfaction of environmental flows). Intended to be called in between calculate_discharge and make_discharge.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be pulled (only 'volume' key is used)</p> required <p>Returns:</p> Name Type Description <code>reply</code> <code>dict</code> <p>Amount of water that has been pulled</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def pull_set_reuse(self, vqip):\n    \"\"\"Enables WWTW to receive pulls of the treated water (i.e., for wastewater\n    reuse or satisfaction of environmental flows). Intended to be called in between\n    calculate_discharge and make_discharge.\n\n    Args:\n        vqip (dict): A VQIP amount to be pulled (only 'volume' key is used)\n\n    Returns:\n        reply (dict): Amount of water that has been pulled\n    \"\"\"\n    # Satisfy request with treated (volume)\n    reply_vol = min(vqip[\"volume\"], self.treated[\"volume\"])\n    # Update pollutants\n    reply = self.v_change_vqip(self.treated, reply_vol)\n    # Update treated\n    self.treated = self.v_change_vqip(\n        self.treated, self.treated[\"volume\"] - reply_vol\n    )\n    return reply\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.push_check_sewer","title":"<code>push_check_sewer(vqip=None)</code>","text":"<p>Check throughput and stormwater tank capacity.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP that can be used to limit the volume in the return value (only volume key is used). Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>dict</code> <p>excess</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def push_check_sewer(self, vqip=None):\n    \"\"\"Check throughput and stormwater tank capacity.\n\n    Args:\n        vqip (dict, optional): A VQIP that can be used to limit the volume in\n            the return value (only volume key is used). Defaults to None.\n\n    Returns:\n        (dict): excess\n    \"\"\"\n    # Get excess\n    excess_throughput = self.get_excess_throughput()\n    excess_tank = self.stormwater_tank.get_excess()\n    # Combine tank and throughput\n    vol = excess_tank[\"volume\"] + excess_throughput\n    # Update volume\n    if vqip is None:\n        vqip = self.empty_vqip()\n    else:\n        vol = min(vol, vqip[\"volume\"])\n\n    return self.v_change_vqip(vqip, vol)\n</code></pre>"},{"location":"reference-wtw/#wsimod.nodes.wtw.WWTW.push_set_sewer","title":"<code>push_set_sewer(vqip)</code>","text":"<p>Receive water, first try to update current_input, and then stormwater tank.</p> <p>Parameters:</p> Name Type Description Default <code>vqip</code> <code>dict</code> <p>A VQIP amount to be treated and then stored</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A VQIP amount of water that was not treated</p> Source code in <code>wsimod/nodes/wtw.py</code> <pre><code>def push_set_sewer(self, vqip):\n    \"\"\"Receive water, first try to update current_input, and then stormwater tank.\n\n    Args:\n        vqip (dict): A VQIP amount to be treated and then stored\n\n    Returns:\n        (dict): A VQIP amount of water that was not treated\n    \"\"\"\n    # Receive water from sewers\n    vqip = self.copy_vqip(vqip)\n    # Check if can directly be treated\n    sent_direct = self.get_excess_throughput()\n\n    sent_direct = min(sent_direct, vqip[\"volume\"])\n\n    sent_direct = self.v_change_vqip(vqip, sent_direct)\n\n    self.current_input = self.sum_vqip(self.current_input, sent_direct)\n\n    if sent_direct[\"volume\"] == vqip[\"volume\"]:\n        # If all added to input, no problem\n        return self.empty_vqip()\n\n    # Next try temporary storage\n    vqip = self.v_change_vqip(vqip, vqip[\"volume\"] - sent_direct[\"volume\"])\n\n    vqip = self.stormwater_tank.push_storage(vqip)\n\n    if vqip[\"volume\"] &lt; constants.FLOAT_ACCURACY:\n        return self.empty_vqip()\n    else:\n        # TODO what to do here ???\n        return vqip\n</code></pre>"},{"location":"reference/","title":"Reference","text":"<p>Different API sections are documented separately.</p> <ol> <li>API reference - arc</li> <li>API reference - core</li> <li>API reference - land</li> <li>API reference - nodes</li> <li>API reference - sewer</li> <li>API reference - storage (reservoir, river, groundwater)</li> <li>API reference - wtw</li> <li>API reference - other components</li> <li>API reference - model</li> <li>API reference - extensions</li> </ol>"},{"location":"tutorials/","title":"Tutorials","text":"<ol> <li>Quickstart</li> <li>WSIMOD model demonstration - Oxford</li> <li>Land nodes - hydrology and agriculture</li> <li>Model object - WSIMOD models</li> </ol>"},{"location":"wsimod-cli/","title":"WSIMOD Command Line Interface","text":"<p>WSIMOD can be run from the command line using an input config file (and any other data file required). This is convenient as it removes the need of any knowledge of Python, for example.</p>"},{"location":"wsimod-cli/#syntax","title":"Syntax","text":"<p>The syntax for running WSIMOD from the command line is as follows:</p> <pre><code>usage: WSIMOD [-h] [--inputs INPUTS] [--outputs OUTPUTS] settings\n\npositional arguments:\n  settings              Path to the WSIMOD input file, in YAML format.\n\noptions:\n  -h, --help            show this help message and exit\n  --inputs INPUTS, -i INPUTS\n                        Base directory for all input files. If present, overwrites value in the settings file.\n  --outputs OUTPUTS, -o OUTPUTS\n                        Base directory for all output files. If present, overwrites value in the settings file.\n</code></pre> <p>Only the <code>settings</code> argument is mandatory. All the others can be obtained from this one.</p>"},{"location":"wsimod-cli/#types-of-input-files","title":"Types of input files","text":"<p>WSIMOD command line interface (CLI) supports two types of input settings files:</p>"},{"location":"wsimod-cli/#saved-model-file","title":"Saved model file","text":"<p>Created with <code>Model.save</code>, as described in the WSIMOD models section, in <code>yaml</code> format. As <code>save</code> creates extra data files to store the required tabular data, those files also need to be present and in the right location (typically, alongside the config file). As this file has been created out of a fully constructed model, it tends to be verbose including all the default values for the different arguments used by WSIMOD.</p>"},{"location":"wsimod-cli/#custom-model-file","title":"Custom model file","text":"<p>This is a manually created <code>yaml</code> file with the definition of the model. It is identical to the previous file except that:</p> <ul> <li>Is less verbose, as it only includes the options that need customisation and not all the defaults.</li> <li>Can include an <code>inputs</code> and an <code>outputs</code> keys to indicate the location of the inputs and outputs, identical in purpose to the CLI arguments.</li> <li>Can include a <code>data</code> key where instructions for the pre-processing of the input files can be included.</li> </ul> <p>The last option is the most fundamental difference and it gives the second approach greater flexibility. In this case, the relevant input that should be a dataset is replaced with <code>data:some_instructions</code>, and an entry in the <code>data</code> section of the file is included to explain what those instructions are.</p> <p>For example, the quickstart demo has two parameters that are datasets, the <code>dates</code> and the <code>land_inputs</code> of the <code>land</code> node. Both of these come from the same input file, <code>timeseries_data.csv</code>.</p> <p>For the <code>dates</code>, the way to indicate them in the settings file would be:</p> <pre><code>data:\n  dates_data:\n    filename: timeseries_data.csv\n    options: usecols=['date'],parse_dates=['date']\n\ndates: data:dates_data\n</code></pre> <p>We are indicating that the <code>dates</code> should be taken from a specific column of the CSV file and that the column should be parsed as dates. The arguments included in <code>options</code> are passed to the underlaying <code>pandas.read_csv</code> function, and therefore it is possible to have a high degree of customisation when loading files. The main caveat is that only simple python types are allowed in the options (strings, lists, etc.) so the more complex processing options that are possible in <code>read_csv</code> might not be available.</p> <p>The <code>land_inputs</code> requires more manipulation:</p> <pre><code>data:\n  my_land_data:\n    filename: timeseries_data.csv\n    filter:\n      - where: site\n        is: oxford_land\n    scaling:\n      - where: variable\n        is: precipitation\n        variable: value\n        factor: \"MM_TO_M\"\n    format: dict\n    index: ['variable', 'date']\n    output: 'value'\n    options: parse_dates=['date']\n\n- type_: Land\n  data_input_dict: data:my_land_data\n  ... # Other arguments\n</code></pre> <p>In this case, we are using the same input file, but we are processing it in a different way. We are still parsing the <code>date</code> column as dates, but then, after reading the CSV we are doing the following maniputlations in exactly this order:</p> <ul> <li>We are selecting only entries where the <code>site</code> is <code>oxford_land</code>. Several filters can be applied sequentially, applied to different columns.</li> <li>We are scaling the values of the variable <code>precipitation</code> to match the correct units. A number or a units conversion factor can be used, and multiple scalings can be applied sequentially to different columns.</li> <li>The index is set to the chosen variables, so the records can be selected based on that. In this case, records will be selected based on a couple of (<code>variable</code>, <code>date</code>).</li> <li>The relevant column will be selected as <code>output</code>. In this case, the column is <code>value</code>.</li> <li>Finally, the format of the data that will be ingested by the WSIMOD model is chosen. In this case, we choose a <code>dict</code> format, which is what WSIMOD requires in nodes and arcs. Note that we did not do this conversion for the dates above.</li> </ul> <p>As it can be seen, while this manipulation is somewhat limited in the grand scheme of things, it already offers a lot of flexibility. For example, if we want to repeat the very same analysis but with <code>thames</code> instead of <code>oxford_land</code>, we just need to replace that argument in the input and everythig else is kept the same.</p>"},{"location":"wsimod-cli/#output-files","title":"Output files","text":"<p>As a result of a WSIMOD simulation, there will always be 3 CSV files created:</p> <ul> <li><code>flows.csv</code></li> <li><code>surfaces.csv</code></li> <li><code>tanks.csv</code></li> </ul> <p>See the output of <code>Model.run</code> in the documentaiton for a description of the contents of these files.</p>"},{"location":"wsimod_models/","title":"WSIMOD models","text":"<ol> <li> <p>Introduction</p> </li> <li> <p>What data do you need</p> </li> <li> <p>WSIMOD model</p> <p>3.1. Nodes</p> <p>3.2. Arcs</p> <p>3.3. Model properties</p> </li> <li> <p>Input data</p> </li> <li> <p>Limitations</p> </li> </ol>"},{"location":"wsimod_models/#introduction","title":"Introduction","text":"<p>In other tutorials, we generally create nodes and arcs in a dictionary format to best explain how to understand what is going on in WSIMOD. However, this is not a streamlined way to setup or use a model in practice. Instead, we provide a structured format that a model can be loaded from and the ability to save models to this format. In this tutorial we will describe the format, and give examples.</p>"},{"location":"wsimod_models/#what-data-do-you-need","title":"What data do you need?","text":"<p>WSIMOD combines a variety of different models into different types of node/component. Our goal is a highly flexible approach to representing a wide variety of water systems. The result is that your data requirements will be highly specific to your project, the systems that you want to include, and the questions you want to ask of your model. To understand what model components you should include, and what data requirements these have, we recommend familiarising yourself with the WSIMOD approach through completing the tutorials and viewing the API. Ultimately though, all nodes and arcs can be resolved in terms of dictionaries that determine their parameters/input data, which makes them ideal to be structured using the PyYAML data langauge.</p>"},{"location":"wsimod_models/#wsimod-model","title":"WSIMOD model","text":"<p>As demonstrated in the tutorials, a model object is a helpful way to contain your nodes/arcs and orchestrate your simulation. From the model object, you can <code>save</code> or <code>load</code> data by providing a data directory. Critically, these functions interact with a <code>config.yml</code> file that contains all of the information to describe your model. Below, we will explain this file using examples from quickstart demo, highlighting the key features of this config file. You can create this yourself by running the demo and appending the following command:</p> <pre><code>my_model.save(&lt;directory_address_on_your_filesystem&gt;)\n</code></pre> <p>The top level entries of the <code>config.yml</code> file created in the provided directorty are:</p> <pre><code>nodes\narcs\npollutants\nadditive_pollutants\nnon_additive_pollutants\nfloat_accuracy\ndates\n</code></pre> <p>, which cover all of the properties needed to describe a model object.</p> <p>To load a model, we to initialise a model object and call the <code>load</code> function:</p> <pre><code>my_model = Model()\nmy_model.load(&lt;directory_address_on_your_filesystem&gt;)\n</code></pre>"},{"location":"wsimod_models/#nodes","title":"Nodes","text":"<p>The <code>nodes</code> entry of <code>config.yml</code> will contain the information required to initialise all of the components in your model. Below are a sewer node and default node.</p> <pre><code>nodes:\n  my_sewer:\n    chamber_area: 1\n    name: my_sewer\n    pipe_time: 0\n    chamber_floor: 10\n    capacity: 0.04\n    pipe_timearea:\n      0: 1\n    type_: Sewer\n    node_type_override: Sewer\n  my_river:\n    name: my_river\n    type_: Node\n    node_type_override: Node\n</code></pre> <p>By inspecting the <code>Sewer</code> API, we can see that this entry contains the parameters required to initiliase a <code>Sewer</code> object, however the <code>capacity</code> and <code>name</code> fields have been updated to the values that they are set as in the quickstart demo.</p> <p>We see two additional fields of <code>type_</code> and <code>node_type_override</code>. If only <code>type_</code> is provided, then this will specify the object that is created which should match an object in WSIMOD. It also specifies how other nodes view it, for example, a <code>Sewer</code> node receives water differently from <code>Land</code> nodes than it does from <code>Demand</code> nodes. However, there are a variety of subclasses of <code>Demand</code> node, so to ensure the <code>Sewer</code> object treats all <code>Demand</code> subclasses the same, we overwrite the <code>__class__.__name__</code> property in each subclass so that the model treats (e.g.,) <code>ResidentialDemand</code> as a <code>Demand</code> object. In cases such as these, to ensure WSIMOD creates a <code>ResidentialDemand</code> object that is treated like a <code>Demand</code> object, we specify the <code>type_</code> as <code>Demand</code> but the <code>node_type_override</code> as <code>ResidentialDemand</code>.</p>"},{"location":"wsimod_models/#arcs","title":"Arcs","text":"<p>The <code>arcs</code> entry of <code>config.yml</code> contains the initialisation fields of the <code>Arc</code> object. If we inspect the quickstart demo, we will see that the <code>storm_outflow</code> arc was not initiliased with any values for the <code>preference</code> or <code>capacity</code> parameter. They are saved by the <code>Model.save()</code> function because, upon initialisation, if they are not provided, the arc receives a default unbounded capacity and a neutral preference of 1.</p> <pre><code>arcs:\n  storm_outflow:\n    capacity: 1000000000000000.0\n    name: storm_outflow\n    preference: 1\n    type_: Arc\n    in_port: my_sewer\n    out_port: my_river\n</code></pre>"},{"location":"wsimod_models/#model-properties","title":"Model properties","text":"<p>The <code>pollutants</code> entries are used to tell the model which pollutants should be simulated, which are additive (i.e., mass based), and which are non-additive (e.g., temperature).</p> <p>The <code>float_accuracy</code> entry provides a number used in mass balance checking. Common sense is suggested in interpreting mass balance errors.</p> <p>The <code>dates</code> entry is written if the model object has a <code>dates</code> property and is a list of <code>dates</code> for which the model will run for if the <code>Model.run()</code> function is called. It is assumed that the <code>dates</code> are compatible with the dates provided in the input data.</p>"},{"location":"wsimod_models/#input-data","title":"Input data","text":"<p>While the <code>config.yml</code> file contains information to parameterise and initialise WSIMOD objects, timeseries input data is stored separately to create a more manageable model directory. As established through the tutorials, any node timeseries input data must be provided as a dictionary where the keys are tuples containing the variable and time, and stored in the <code>data_input_dict</code> property. For example, using the <code>Catchment</code> node, which is primarily a data reader:</p> <pre><code># Imports\nfrom wsimod.core import constants\nfrom wsimod.nodes.catchment import Catchment\nfrom wsimod.orchestration.model import to_datetime\n\n# Model only temperature and phosphate\nconstants.set_simple_pollutants()\n\n# Create input data dictionary\ndate = to_datetime('2000-01-01')\nforcing_data = {('flow', date) : 2,\n                    ('phosphate', date) : 0.2,\n                    ('temperature', date) : 10}\n\n# Create Catchment object\nmy_catch = Catchment(name = 'my_catchment', data_input_dict = forcing_data)\n\n# Assign date\nmy_catch.t = date\n\n# Get flows\nprint(my_catch.get_flow())\n{'volume': 2, 'phosphate': 0.4, 'temperature': 10}\n</code></pre> <p>We note that dates can take any hashable format, however some components require the date to have properties such as <code>dayofyear</code>, and so recommend using <code>datetime</code> like objects, we provide a simple <code>datetime</code> wrapper in <code>model.to_datetime</code>.</p> <p>When we call <code>Model.save()</code> it will convert each node's <code>data_input_dict</code> into a separate <code>.csv</code> (or <code>.csv.gz</code> if the <code>compress</code> option is specified), and create an entry called <code>filename</code> for the node in the <code>config.yml</code> file.</p> <p>For example,</p> <pre><code>import os\nfrom wsimod.orchestration.model import Model\n\nmy_model = Model()\nmy_model.add_instantiated_nodes([my_catch])\nmy_model.save(os.getcwd())\n</code></pre> <p>Which will create a <code>config.yml</code> file containing the <code>nodes</code> entry of:</p> <pre><code>nodes:\n  my_catchment:\n    name: my_catchment\n    type_: Catchment\n    node_type_override: Catchment\n    filename: my_catchment-inputs.csv\n</code></pre> <p>and a file in the current directory named <code>my_catchment-inputs.csv</code> containing:</p> <pre><code>node,variable,time,value\nmy_catchment,flow,2000-01-01,2\nmy_catchment,phosphate,2000-01-01,0.2\nmy_catchment,temperature,2000-01-01,10\n</code></pre>"},{"location":"wsimod_models/#limitations","title":"Limitations","text":"<p>It is important that there are key limitations to model saving/loading. To avoid overly complicated <code>config.yml</code> files that are easy for a user to edit, we opted to only save the properties of a node/arc required to initialise that object. This means that state variables, user-added properties, or method overriding are not preserved when the model is saved. Thus, when the model is loaded, its objects are initialised as if new. However, if a user wishes to achieve this then the <code>Model/save_pickle</code> and <code>Model/load_pickle</code> functions can help to achieve it, though these create binary files that are not user readable.</p>"},{"location":"demo/scripts/custom_distribution_handler/","title":"Custom distribution handler","text":"In\u00a0[1]: Copied! <pre>from wsimod.extensions import register_node_patch\n</pre> from wsimod.extensions import register_node_patch In\u00a0[2]: Copied! <pre>@register_node_patch(\"my_dist\", \"push_check_handler\", item=\"Node\")\ndef custom_handler_function(self, vqip, *args, **kwargs):\n    \"\"\"A custom `push_check_handler` function.\n\n    Call the default handler for the \"Node\" item.\n    \"\"\"\n    print(\"I reached a custom handler\")\n    return self.push_check_handler[\"default\"](vqip)\n</pre> @register_node_patch(\"my_dist\", \"push_check_handler\", item=\"Node\") def custom_handler_function(self, vqip, *args, **kwargs):     \"\"\"A custom `push_check_handler` function.      Call the default handler for the \"Node\" item.     \"\"\"     print(\"I reached a custom handler\")     return self.push_check_handler[\"default\"](vqip)"},{"location":"demo/scripts/custom_fwtw_pull/","title":"Custom fwtw pull","text":"In\u00a0[1]: Copied! <pre>from wsimod.extensions import register_node_patch\n</pre> from wsimod.extensions import register_node_patch In\u00a0[2]: Copied! <pre>@register_node_patch(\"my_fwtw\", \"pull_distributed\")\ndef custom_pull_distributed(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_distributed` function.\n\n    Call `pull_distributed` with the tag \"FWTW\".\n    \"\"\"\n    return self._patched_pull_distributed(vqip, tag=\"FWTW\")\n</pre> @register_node_patch(\"my_fwtw\", \"pull_distributed\") def custom_pull_distributed(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_distributed` function.      Call `pull_distributed` with the tag \"FWTW\".     \"\"\"     return self._patched_pull_distributed(vqip, tag=\"FWTW\")"},{"location":"demo/scripts/custom_reservoir_handler/","title":"Custom reservoir handler","text":"In\u00a0[1]: Copied! <pre>from wsimod.extensions import register_node_patch\n</pre> from wsimod.extensions import register_node_patch In\u00a0[2]: Copied! <pre>@register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"FWTW\")\ndef custom_pulls_fwtw(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_set_handler` function.\n\n    Pull from the storage when pulled with the tag \"FWTW\".\n    \"\"\"\n    return self.tank.pull_storage(vqip)\n</pre> @register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"FWTW\") def custom_pulls_fwtw(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_set_handler` function.      Pull from the storage when pulled with the tag \"FWTW\".     \"\"\"     return self.tank.pull_storage(vqip) In\u00a0[3]: Copied! <pre>@register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"FWTW\")\ndef custom_pullc_fwtw(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_check_handler` function.\n\n    Return available storage when pulled with the tag \"FWTW\".\n    \"\"\"\n    return self.tank.get_avail()\n</pre> @register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"FWTW\") def custom_pullc_fwtw(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_check_handler` function.      Return available storage when pulled with the tag \"FWTW\".     \"\"\"     return self.tank.get_avail() In\u00a0[4]: Copied! <pre>@register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"default\")\ndef custom_pulls_default(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_set_handler` function.\n\n    Deny pull sets by default.\n    \"\"\"\n    return self.pull_set_deny(vqip)\n</pre> @register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"default\") def custom_pulls_default(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_set_handler` function.      Deny pull sets by default.     \"\"\"     return self.pull_set_deny(vqip) In\u00a0[5]: Copied! <pre>@register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"default\")\ndef custom_pullc_default(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_check_handler` function.\n\n    Deny pull checks by default.\n    \"\"\"\n    return self.pull_check_deny()\n</pre> @register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"default\") def custom_pullc_default(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_check_handler` function.      Deny pull checks by default.     \"\"\"     return self.pull_check_deny()"},{"location":"demo/scripts/customise_an_arc/","title":"Customise an arc (.py)","text":"<p>:warning: Warning: this code does not represent best practice for customisation. Instead we recommend use of decorators to overwrite behaviour. Users can see examples of decorators in the customise_interactions and customise_riverreservoir guides. This guide may still be useful for WSIMOD code examples, and it will still work in many cases.</p> <p>There is currently a GitHub (issue)[https://github.com/barneydobson/wsi/issues/11] to revise this guide.</p> In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom wsimod.demo.create_oxford import create_oxford_model_mrf\n</pre> import os  import pandas as pd from matplotlib import pyplot as plt  from wsimod.demo.create_oxford import create_oxford_model_mrf <p>The model can be automatically created using the data_folder</p> In\u00a0[2]: Copied! <pre># Select the root path for the data folder. Use the appropriate value for your case.\ndata_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")\n\nbaseline_model = create_oxford_model_mrf(data_folder)\n</pre> # Select the root path for the data folder. Use the appropriate value for your case. data_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")  baseline_model = create_oxford_model_mrf(data_folder) <pre>/home/runner/work/wsi/wsi/wsimod/demo/create_oxford.py:166: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n</pre> <p>Simulate baseline flows</p> In\u00a0[3]: Copied! <pre>baseline_flows, baseline_tanks, _, _ = baseline_model.run()\nbaseline_flows = pd.DataFrame(baseline_flows)\nbaseline_tanks = pd.DataFrame(baseline_tanks)\n</pre> baseline_flows, baseline_tanks, _, _ = baseline_model.run() baseline_flows = pd.DataFrame(baseline_flows) baseline_tanks = pd.DataFrame(baseline_tanks) <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r  2%|\u258f         | 31/1456 [00:00&lt;00:04, 301.11it/s]</pre> <pre>\r  4%|\u258d         | 62/1456 [00:00&lt;00:04, 304.24it/s]</pre> <pre>\r  6%|\u258b         | 93/1456 [00:00&lt;00:04, 305.05it/s]</pre> <pre>\r  9%|\u258a         | 124/1456 [00:00&lt;00:04, 306.90it/s]</pre> <pre>\r 11%|\u2588         | 155/1456 [00:00&lt;00:04, 304.82it/s]</pre> <pre>\r 13%|\u2588\u258e        | 186/1456 [00:00&lt;00:04, 305.99it/s]</pre> <pre>\r 15%|\u2588\u258d        | 218/1456 [00:00&lt;00:04, 308.76it/s]</pre> <pre>\r 17%|\u2588\u258b        | 249/1456 [00:00&lt;00:03, 309.01it/s]</pre> <pre>\r 19%|\u2588\u2589        | 280/1456 [00:00&lt;00:03, 304.36it/s]</pre> <pre>\r 21%|\u2588\u2588\u258f       | 311/1456 [00:01&lt;00:03, 303.80it/s]</pre> <pre>\r 23%|\u2588\u2588\u258e       | 342/1456 [00:01&lt;00:03, 302.90it/s]</pre> <pre>\r 26%|\u2588\u2588\u258c       | 373/1456 [00:01&lt;00:03, 303.84it/s]</pre> <pre>\r 28%|\u2588\u2588\u258a       | 404/1456 [00:01&lt;00:03, 303.94it/s]</pre> <pre>\r 30%|\u2588\u2588\u2589       | 435/1456 [00:01&lt;00:03, 302.29it/s]</pre> <pre>\r 32%|\u2588\u2588\u2588\u258f      | 466/1456 [00:01&lt;00:03, 303.58it/s]</pre> <pre>\r 34%|\u2588\u2588\u2588\u258d      | 497/1456 [00:01&lt;00:03, 304.93it/s]</pre> <pre>\r 36%|\u2588\u2588\u2588\u258b      | 530/1456 [00:01&lt;00:02, 309.43it/s]</pre> <pre>\r 39%|\u2588\u2588\u2588\u258a      | 561/1456 [00:01&lt;00:02, 308.63it/s]</pre> <pre>\r 41%|\u2588\u2588\u2588\u2588      | 593/1456 [00:01&lt;00:02, 309.46it/s]</pre> <pre>\r 43%|\u2588\u2588\u2588\u2588\u258e     | 624/1456 [00:02&lt;00:02, 308.56it/s]</pre> <pre>\r 45%|\u2588\u2588\u2588\u2588\u258d     | 655/1456 [00:02&lt;00:02, 308.77it/s]</pre> <pre>\r 47%|\u2588\u2588\u2588\u2588\u258b     | 686/1456 [00:02&lt;00:02, 307.91it/s]</pre> <pre>\r 49%|\u2588\u2588\u2588\u2588\u2589     | 717/1456 [00:02&lt;00:02, 305.47it/s]</pre> <pre>\r 51%|\u2588\u2588\u2588\u2588\u2588\u258f    | 748/1456 [00:02&lt;00:02, 305.85it/s]</pre> <pre>\r 54%|\u2588\u2588\u2588\u2588\u2588\u258e    | 779/1456 [00:02&lt;00:02, 306.54it/s]</pre> <pre>\r 56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 810/1456 [00:02&lt;00:02, 306.78it/s]</pre> <pre>\r 58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 842/1456 [00:02&lt;00:01, 308.56it/s]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 874/1456 [00:02&lt;00:01, 311.49it/s]</pre> <pre>\r 62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 907/1456 [00:02&lt;00:01, 314.32it/s]</pre> <pre>\r 65%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 940/1456 [00:03&lt;00:01, 316.98it/s]</pre> <pre>\r 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 972/1456 [00:03&lt;00:01, 316.08it/s]</pre> <pre>\r 69%|\u2588\u2588\u2588\u2588\u2588\u2588\u2589   | 1004/1456 [00:03&lt;00:01, 313.74it/s]</pre> <pre>\r 71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1036/1456 [00:03&lt;00:01, 311.29it/s]</pre> <pre>\r 73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1068/1456 [00:03&lt;00:01, 303.77it/s]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1099/1456 [00:03&lt;00:01, 304.40it/s]</pre> <pre>\r 78%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a  | 1130/1456 [00:03&lt;00:01, 305.70it/s]</pre> <pre>\r 80%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1161/1456 [00:03&lt;00:00, 303.53it/s]</pre> <pre>\r 82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1192/1456 [00:03&lt;00:00, 303.87it/s]</pre> <pre>\r 84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1223/1456 [00:03&lt;00:00, 303.13it/s]</pre> <pre>\r 86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1254/1456 [00:04&lt;00:00, 300.83it/s]</pre> <pre>\r 88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1285/1456 [00:04&lt;00:00, 301.77it/s]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1316/1456 [00:04&lt;00:00, 302.85it/s]</pre> <pre>\r 93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1347/1456 [00:04&lt;00:00, 303.34it/s]</pre> <pre>\r 95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1378/1456 [00:04&lt;00:00, 303.76it/s]</pre> <pre>\r 97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1409/1456 [00:04&lt;00:00, 303.43it/s]</pre> <pre>\r 99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1440/1456 [00:04&lt;00:00, 304.38it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:04&lt;00:00, 306.21it/s]</pre> <pre>\n</pre> <p>When we plot the results, we see some alarmingly low reservoir levels - I am sure that Thames Water would not be happy about this</p> In\u00a0[4]: Copied! <pre>f, axs = plt.subplots(3, 1, figsize=(6, 6))\nbaseline_flows.groupby(\"arc\").get_group(\"farmoor_to_mixer\").set_index(\"time\")[\n    [\"flow\"]\n].plot(ax=axs[0], title=\"River flow downstream of abstractions\")\naxs[0].set_yscale(\"symlog\")\naxs[0].set_ylim([10e3, 10e7])\nbaseline_flows.groupby(\"arc\").get_group(\"abstraction_to_farmoor\").set_index(\"time\")[\n    [\"flow\"]\n].plot(ax=axs[1], title=\"Abstraction\")\naxs[1].legend()\n\nbaseline_tanks.groupby(\"node\").get_group(\"farmoor\").set_index(\"time\")[[\"storage\"]].plot(\n    ax=axs[2], title=\"Reservoir storage\"\n)\naxs[2].legend()\nf.tight_layout()\n</pre> f, axs = plt.subplots(3, 1, figsize=(6, 6)) baseline_flows.groupby(\"arc\").get_group(\"farmoor_to_mixer\").set_index(\"time\")[     [\"flow\"] ].plot(ax=axs[0], title=\"River flow downstream of abstractions\") axs[0].set_yscale(\"symlog\") axs[0].set_ylim([10e3, 10e7]) baseline_flows.groupby(\"arc\").get_group(\"abstraction_to_farmoor\").set_index(\"time\")[     [\"flow\"] ].plot(ax=axs[1], title=\"Abstraction\") axs[1].legend()  baseline_tanks.groupby(\"node\").get_group(\"farmoor\").set_index(\"time\")[[\"storage\"]].plot(     ax=axs[2], title=\"Reservoir storage\" ) axs[2].legend() f.tight_layout() In\u00a0[5]: Copied! <pre>levels = {\n    1: 0.7,\n    2: 0.8,\n    3: 0.9,\n    4: 0.95,\n    5: 0.95,\n    6: 0.95,\n    7: 0.95,\n    8: 0.9,\n    9: 0.8,\n    10: 0.7,\n    11: 0.7,\n    12: 0.7,\n}\n</pre>  levels = {     1: 0.7,     2: 0.8,     3: 0.9,     4: 0.95,     5: 0.95,     6: 0.95,     7: 0.95,     8: 0.9,     9: 0.8,     10: 0.7,     11: 0.7,     12: 0.7, } <p>We also need to determine what the new abstraction capacity will be, we will choose a simple multiplier on the existing capacity</p> In\u00a0[6]: Copied! <pre>capacity_multiplier = 1.25\n</pre> capacity_multiplier = 1.25 <p>We can now redefine the <code>get_excess</code> function. We can start with a trimmed down version of the original <code>get_excess</code> function:</p> <pre><code>def get_excess(self, direction, vqip = None, tag = 'default'):\n    pipe_excess = self.capacity - self.flow_in\n    node_excess = self.in_port.pull_check(vqip, tag)\n    excess = min(pipe_excess, node_excess['volume'])\n    return self.v_change_vqip(node_excess, excess)\n</code></pre> <p>This shows only the bits of the function that are relevant for pulls. In order to implement the new variable capacity, we will need to:</p> <p>-identify the month</p> <p>-identify the reservoir volume expressed as a percent</p> <p>-adjust the capacity to reflect possibility of increased abstractions</p> In\u00a0[7]: Copied! <pre>def get_excess_new(arc, direction, vqip=None, tag=\"default\"):\n    \"\"\"\n\n    Args:\n        arc:\n        direction:\n        vqip:\n        tag:\n\n    Returns:\n\n    \"\"\"\n    # All nodes have access to the 't' parameter, which is a datetime object\n    # that can return the month\n    month = arc.out_port.t.month\n\n    # Get percent full\n    pct = arc.out_port.get_percent()\n\n    # Adjust capacity\n    if arc.levels[month] &gt; pct:\n        capacity = arc.capacity * arc.capacity_multiplier\n    else:\n        capacity = arc.capacity\n\n    # Proceed with get_excess function as normal\n    pipe_excess = capacity - arc.flow_in\n    node_excess = arc.in_port.pull_check(vqip, tag)\n    excess = min(pipe_excess, node_excess[\"volume\"])\n    return arc.v_change_vqip(node_excess, excess)\n</pre> def get_excess_new(arc, direction, vqip=None, tag=\"default\"):     \"\"\"      Args:         arc:         direction:         vqip:         tag:      Returns:      \"\"\"     # All nodes have access to the 't' parameter, which is a datetime object     # that can return the month     month = arc.out_port.t.month      # Get percent full     pct = arc.out_port.get_percent()      # Adjust capacity     if arc.levels[month] &gt; pct:         capacity = arc.capacity * arc.capacity_multiplier     else:         capacity = arc.capacity      # Proceed with get_excess function as normal     pipe_excess = capacity - arc.flow_in     node_excess = arc.in_port.pull_check(vqip, tag)     excess = min(pipe_excess, node_excess[\"volume\"])     return arc.v_change_vqip(node_excess, excess) <p>Finally we need a wrapper to assign the new function and the associated parameters</p> In\u00a0[8]: Copied! <pre>def apply_variable_capacity(arc, levels, multiplier):\n    \"\"\"\n\n    Args:\n        arc:\n        levels:\n        multiplier:\n    \"\"\"\n    # Assign parameters\n    arc.levels = levels\n    arc.capacity_multiplier = multiplier\n\n    # Change get_excess function to new one above\n    arc.get_excess = lambda **x: get_excess_new(arc, **x)\n</pre> def apply_variable_capacity(arc, levels, multiplier):     \"\"\"      Args:         arc:         levels:         multiplier:     \"\"\"     # Assign parameters     arc.levels = levels     arc.capacity_multiplier = multiplier      # Change get_excess function to new one above     arc.get_excess = lambda **x: get_excess_new(arc, **x) <p>Now we can create a new model</p> In\u00a0[9]: Copied! <pre>customised_model = create_oxford_model_mrf(data_folder)\n</pre> customised_model = create_oxford_model_mrf(data_folder) <pre>/home/runner/work/wsi/wsi/wsimod/demo/create_oxford.py:166: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n</pre> <p>.. and assign the new variable capacity</p> In\u00a0[10]: Copied! <pre>apply_variable_capacity(\n    customised_model.arcs[\"abstraction_to_farmoor\"], levels, capacity_multiplier\n)\n</pre> apply_variable_capacity(     customised_model.arcs[\"abstraction_to_farmoor\"], levels, capacity_multiplier ) In\u00a0[11]: Copied! <pre>flows_var_cap, tanks_var_cap, _, _ = customised_model.run()\n\nflows_var_cap = pd.DataFrame(flows_var_cap)\ntanks_var_cap = pd.DataFrame(tanks_var_cap)\n</pre>  flows_var_cap, tanks_var_cap, _, _ = customised_model.run()  flows_var_cap = pd.DataFrame(flows_var_cap) tanks_var_cap = pd.DataFrame(tanks_var_cap) <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r  2%|\u258f         | 27/1456 [00:00&lt;00:05, 260.90it/s]</pre> <pre>\r  4%|\u258e         | 54/1456 [00:00&lt;00:05, 258.27it/s]</pre> <pre>\r  5%|\u258c         | 80/1456 [00:00&lt;00:05, 256.93it/s]</pre> <pre>\r  7%|\u258b         | 106/1456 [00:00&lt;00:05, 256.72it/s]</pre> <pre>\r  9%|\u2589         | 134/1456 [00:00&lt;00:04, 264.92it/s]</pre> <pre>\r 11%|\u2588         | 161/1456 [00:00&lt;00:04, 264.64it/s]</pre> <pre>\r 13%|\u2588\u258e        | 188/1456 [00:00&lt;00:04, 262.49it/s]</pre> <pre>\r 15%|\u2588\u258d        | 216/1456 [00:00&lt;00:04, 267.37it/s]</pre> <pre>\r 17%|\u2588\u258b        | 246/1456 [00:00&lt;00:04, 275.74it/s]</pre> <pre>\r 19%|\u2588\u2589        | 274/1456 [00:01&lt;00:04, 275.58it/s]</pre> <pre>\r 21%|\u2588\u2588        | 302/1456 [00:01&lt;00:04, 275.87it/s]</pre> <pre>\r 23%|\u2588\u2588\u258e       | 330/1456 [00:01&lt;00:04, 267.61it/s]</pre> <pre>\r 25%|\u2588\u2588\u258d       | 357/1456 [00:01&lt;00:04, 262.98it/s]</pre> <pre>\r 26%|\u2588\u2588\u258b       | 384/1456 [00:01&lt;00:04, 261.08it/s]</pre> <pre>\r 28%|\u2588\u2588\u258a       | 411/1456 [00:01&lt;00:04, 259.71it/s]</pre> <pre>\r 30%|\u2588\u2588\u2588       | 438/1456 [00:01&lt;00:03, 259.88it/s]</pre> <pre>\r 32%|\u2588\u2588\u2588\u258f      | 465/1456 [00:01&lt;00:03, 259.72it/s]</pre> <pre>\r 34%|\u2588\u2588\u2588\u258d      | 492/1456 [00:01&lt;00:03, 260.26it/s]</pre> <pre>\r 36%|\u2588\u2588\u2588\u258c      | 521/1456 [00:01&lt;00:03, 268.04it/s]</pre> <pre>\r 38%|\u2588\u2588\u2588\u258a      | 550/1456 [00:02&lt;00:03, 273.05it/s]</pre> <pre>\r 40%|\u2588\u2588\u2588\u2589      | 579/1456 [00:02&lt;00:03, 277.78it/s]</pre> <pre>\r 42%|\u2588\u2588\u2588\u2588\u258f     | 607/1456 [00:02&lt;00:03, 277.42it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258e     | 635/1456 [00:02&lt;00:02, 274.13it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258c     | 663/1456 [00:02&lt;00:02, 269.45it/s]</pre> <pre>\r 47%|\u2588\u2588\u2588\u2588\u258b     | 690/1456 [00:02&lt;00:03, 250.70it/s]</pre> <pre>\r 49%|\u2588\u2588\u2588\u2588\u2589     | 716/1456 [00:02&lt;00:03, 246.25it/s]</pre> <pre>\r 51%|\u2588\u2588\u2588\u2588\u2588     | 741/1456 [00:02&lt;00:02, 244.04it/s]</pre> <pre>\r 53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 766/1456 [00:02&lt;00:02, 241.31it/s]</pre> <pre>\r 54%|\u2588\u2588\u2588\u2588\u2588\u258d    | 792/1456 [00:03&lt;00:02, 244.82it/s]</pre> <pre>\r 56%|\u2588\u2588\u2588\u2588\u2588\u258c    | 818/1456 [00:03&lt;00:02, 248.16it/s]</pre> <pre>\r 58%|\u2588\u2588\u2588\u2588\u2588\u258a    | 847/1456 [00:03&lt;00:02, 257.93it/s]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 877/1456 [00:03&lt;00:02, 270.01it/s]</pre> <pre>\r 62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 908/1456 [00:03&lt;00:01, 279.43it/s]</pre> <pre>\r 64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 938/1456 [00:03&lt;00:01, 284.15it/s]</pre> <pre>\r 67%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 969/1456 [00:03&lt;00:01, 290.21it/s]</pre> <pre>\r 69%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 1000/1456 [00:03&lt;00:01, 294.35it/s]</pre> <pre>\r 71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1030/1456 [00:03&lt;00:01, 290.41it/s]</pre> <pre>\r 73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1060/1456 [00:03&lt;00:01, 286.72it/s]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d  | 1089/1456 [00:04&lt;00:01, 284.70it/s]</pre> <pre>\r 77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1118/1456 [00:04&lt;00:01, 282.22it/s]</pre> <pre>\r 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1147/1456 [00:04&lt;00:01, 280.25it/s]</pre> <pre>\r 81%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588  | 1176/1456 [00:04&lt;00:01, 277.64it/s]</pre> <pre>\r 83%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e | 1204/1456 [00:04&lt;00:00, 274.19it/s]</pre> <pre>\r 85%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1232/1456 [00:04&lt;00:00, 268.46it/s]</pre> <pre>\r 86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b | 1259/1456 [00:04&lt;00:00, 265.13it/s]</pre> <pre>\r 88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1286/1456 [00:04&lt;00:00, 261.51it/s]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1313/1456 [00:04&lt;00:00, 260.71it/s]</pre> <pre>\r 92%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f| 1340/1456 [00:05&lt;00:00, 259.78it/s]</pre> <pre>\r 94%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1366/1456 [00:05&lt;00:00, 257.88it/s]</pre> <pre>\r 96%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c| 1392/1456 [00:05&lt;00:00, 254.63it/s]</pre> <pre>\r 97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1418/1456 [00:05&lt;00:00, 255.06it/s]</pre> <pre>\r 99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1444/1456 [00:05&lt;00:00, 254.99it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:05&lt;00:00, 266.01it/s]</pre> <pre>\n</pre> <p>We can see that the reservoir storage is able to recharge much more quickly from the lowest point because of the increased abstractions. We also see negligible change in river flow because the increased abstractions are mainly occurring when the flow is quite high. This is still unlikely to be a preferred option in practice because the lowest reservoir storage is unchanged. This happens because the increased capacity available is not helpful when the flows are so low that the minimum required flow is active. Better luck next time Thames Water!</p> In\u00a0[12]: Copied! <pre>f, axs = plt.subplots(3, 1, figsize=(6, 6))\nplot_flows1 = pd.concat(\n    [\n        baseline_flows.groupby(\"arc\")\n        .get_group(\"farmoor_to_mixer\")\n        .set_index(\"time\")\n        .flow.rename(\"Baseline\"),\n        flows_var_cap.groupby(\"arc\")\n        .get_group(\"farmoor_to_mixer\")\n        .set_index(\"time\")\n        .flow.rename(\"Customised\"),\n    ],\n    axis=1,\n)\nplot_flows1.plot(ax=axs[0], title=\"River flow downstream of abstractions\")\naxs[0].set_yscale(\"symlog\")\naxs[0].set_ylim([10e3, 10e7])\n\nplot_flows2 = pd.concat(\n    [\n        baseline_flows.groupby(\"arc\")\n        .get_group(\"abstraction_to_farmoor\")\n        .set_index(\"time\")\n        .flow.rename(\"Baseline\"),\n        flows_var_cap.groupby(\"arc\")\n        .get_group(\"abstraction_to_farmoor\")\n        .set_index(\"time\")\n        .flow.rename(\"Customised\"),\n    ],\n    axis=1,\n)\nplot_flows2.plot(ax=axs[1], title=\"Abstraction\")\naxs[1].legend()\n\nplot_tanks = pd.concat(\n    [\n        baseline_tanks.groupby(\"node\")\n        .get_group(\"farmoor\")\n        .set_index(\"time\")\n        .storage.rename(\"Baseline\"),\n        tanks_var_cap.groupby(\"node\")\n        .get_group(\"farmoor\")\n        .set_index(\"time\")\n        .storage.rename(\"Customised\"),\n    ],\n    axis=1,\n)\nplot_tanks.plot(ax=axs[2], title=\"Reservoir storage\")\naxs[2].legend()\nf.tight_layout()\n</pre>  f, axs = plt.subplots(3, 1, figsize=(6, 6)) plot_flows1 = pd.concat(     [         baseline_flows.groupby(\"arc\")         .get_group(\"farmoor_to_mixer\")         .set_index(\"time\")         .flow.rename(\"Baseline\"),         flows_var_cap.groupby(\"arc\")         .get_group(\"farmoor_to_mixer\")         .set_index(\"time\")         .flow.rename(\"Customised\"),     ],     axis=1, ) plot_flows1.plot(ax=axs[0], title=\"River flow downstream of abstractions\") axs[0].set_yscale(\"symlog\") axs[0].set_ylim([10e3, 10e7])  plot_flows2 = pd.concat(     [         baseline_flows.groupby(\"arc\")         .get_group(\"abstraction_to_farmoor\")         .set_index(\"time\")         .flow.rename(\"Baseline\"),         flows_var_cap.groupby(\"arc\")         .get_group(\"abstraction_to_farmoor\")         .set_index(\"time\")         .flow.rename(\"Customised\"),     ],     axis=1, ) plot_flows2.plot(ax=axs[1], title=\"Abstraction\") axs[1].legend()  plot_tanks = pd.concat(     [         baseline_tanks.groupby(\"node\")         .get_group(\"farmoor\")         .set_index(\"time\")         .storage.rename(\"Baseline\"),         tanks_var_cap.groupby(\"node\")         .get_group(\"farmoor\")         .set_index(\"time\")         .storage.rename(\"Customised\"),     ],     axis=1, ) plot_tanks.plot(ax=axs[2], title=\"Reservoir storage\") axs[2].legend() f.tight_layout()"},{"location":"demo/scripts/customise_an_arc/#customise-an-arc-py","title":"Customise an arc (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Create baseline</p> </li> <li><p>Customise arc</p> </li> <li><p>Inspect results</p> </li> </ol>"},{"location":"demo/scripts/customise_an_arc/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial we will demonstrate how to customise an arc on-the-fly. If you are creating a new type of arc that is a generic physical object (e.g., a weir), then you should probably create a new subclass of existing classes. However, if you are aiming to alter the behaviour of an arc that already has a class to fit some super specific behaviour, then it may be more suitable to customise on-the-fly. In addition, customising on-the-fly is very similar to creating a subclass, so the skills demonstrated here are likely to be transferrable.</p> <p>We will use the Oxford demo as our base model, and build off it by assigning a varying capacity to the river abstraction depending on reservoir storage</p>"},{"location":"demo/scripts/customise_an_arc/#create-baseline","title":"Create baseline\u00b6","text":"<p>We will first create and simulate the Oxford model to formulate baseline results. We use a version of the model with the minimum required flow from the node customisation demo.</p> <p>Start by importing packages.</p>"},{"location":"demo/scripts/customise_an_arc/#customise-arc","title":"Customise arc\u00b6","text":"<p>The easiest way to customise an arc is by changing its <code>get_excess</code> function. This is the function that determines how much capacity there is in the arc when called.</p> <p>In reality it is common for operational constraints to be seasonal, so we will define monthly amounts that, when reservoir levels are below them, the abstraction capacity can be increased. These amounts have the month as the key and the percentage that the reservoir is full as values.</p>"},{"location":"demo/scripts/customise_an_arc/#inspect-results","title":"Inspect results\u00b6","text":"<p>Let us rerun and view the results to see if it has worked.</p>"},{"location":"demo/scripts/customise_interactions/","title":"Customise interactions (.py)","text":"In\u00a0[1]: Copied! <pre>from pprint import pprint as print\n\nfrom wsimod.nodes.sewer import Sewer\n\n\nmy_sewer = Sewer(name=\"mr_sewer\")\nprint(my_sewer.push_set_handler)\n</pre> from pprint import pprint as print  from wsimod.nodes.sewer import Sewer   my_sewer = Sewer(name=\"mr_sewer\") print(my_sewer.push_set_handler) <pre>{'Demand': &lt;bound method Sewer.push_set_land of &lt;wsimod.nodes.sewer.Sewer object at 0x7f8aa84afb10&gt;&gt;,\n 'Land': &lt;bound method Sewer.push_set_land of &lt;wsimod.nodes.sewer.Sewer object at 0x7f8aa84afb10&gt;&gt;,\n 'Sewer': &lt;bound method Sewer.push_set_sewer of &lt;wsimod.nodes.sewer.Sewer object at 0x7f8aa84afb10&gt;&gt;,\n 'default': &lt;bound method Sewer.push_set_sewer of &lt;wsimod.nodes.sewer.Sewer object at 0x7f8aa84afb10&gt;&gt;}\n</pre> <p>We can see that <code>my_sewer</code> has two different functions (<code>push_set_land</code> and <code>push_set_sewer</code>) stored in its <code>push_set_handler</code> dictionary. There are four different entries in the handler (<code>Demand</code>, <code>Land</code>, <code>Sewer</code>, <code>default</code>). This means that the <code>Sewer</code> node can respond to these four different tags. Tags can take any value, but by convention they specify a WSIMOD node type, or a tuple containing a node type and a specific type of interaction (e.g., <code>('Demand','Garden')</code> in the land node). All nodes must have the dictionaries: <code>push_set_handler</code>, <code>push_check_handler</code>, <code>pull_set_handler</code>, <code>pull_check_handler</code>, and at least one <code>default</code> key in each (see the Node class for defaults). If you do not want to define behaviour for a certain kind of interaction, e.g., maybe you can never pull from this type of node, then you can use, e.g., the <code>pull_set_deny</code> and <code>pull_check_deny</code> functions for the <code>default</code> tag.</p> <p>It is important to note that unless a tag is specified in the request, the <code>default</code> tag is used.</p> In\u00a0[2]: Copied! <pre># Import packages\nimport os\nimport tempfile\n\nfrom wsimod.arcs.arcs import Arc\nfrom wsimod.core import constants\nfrom wsimod.nodes import Distribution, Node\nfrom wsimod.orchestration.model import Model, to_datetime\n\n# Identify the location of the scripts folder\nscripts_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"scripts\")\n\n# Create temporary directory\ntemp_dir = tempfile.TemporaryDirectory()\n\n# Set simple pollutants (i.e., temperature and phosphate only)\nconstants.set_simple_pollutants()\n\n# Create objects\nmy_node = Node(name=\"my_node\")\nmy_dist = Distribution(name=\"my_dist\")\nmy_arc = Arc(name=\"my_arc\", in_port=my_node, out_port=my_dist)\n\n# Wrap in a model for convenience\nmy_model = Model()\nmy_model.add_instantiated_nodes([my_node, my_dist])\nmy_model.add_instantiated_arcs([my_arc])\n\n# Inspect push_check_handler for distribution\nprint(my_model.nodes[\"my_dist\"].push_check_handler)\n</pre> # Import packages import os import tempfile  from wsimod.arcs.arcs import Arc from wsimod.core import constants from wsimod.nodes import Distribution, Node from wsimod.orchestration.model import Model, to_datetime  # Identify the location of the scripts folder scripts_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"scripts\")  # Create temporary directory temp_dir = tempfile.TemporaryDirectory()  # Set simple pollutants (i.e., temperature and phosphate only) constants.set_simple_pollutants()  # Create objects my_node = Node(name=\"my_node\") my_dist = Distribution(name=\"my_dist\") my_arc = Arc(name=\"my_arc\", in_port=my_node, out_port=my_dist)  # Wrap in a model for convenience my_model = Model() my_model.add_instantiated_nodes([my_node, my_dist]) my_model.add_instantiated_arcs([my_arc])  # Inspect push_check_handler for distribution print(my_model.nodes[\"my_dist\"].push_check_handler) <pre>{'default': &lt;bound method Node.push_check_deny of &lt;wsimod.nodes.distribution.Distribution object at 0x7f8a6afdc990&gt;&gt;}\n</pre> <p>We have created a <code>Node</code> that is connected to a <code>Distribution</code>, and we can see by inspecting its <code>push_check_handler</code> that the <code>Distribution</code> object has a denial behaviour for push checks (i.e., it says it cannot be pushed to). We can verify this by sending a <code>push_check</code>.</p> <p>Remember that a <code>push_check</code> requires sending a VQIP (a dictionary with a key for 'volume' and each pollutant simulated).</p> In\u00a0[3]: Copied! <pre>reply = my_model.arcs[\"my_arc\"].send_push_check(\n    {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10}\n)\nprint(reply)\n</pre> reply = my_model.arcs[\"my_arc\"].send_push_check(     {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10} ) print(reply) <pre>Attempted push check to deny\n{'phosphate': 0, 'temperature': 0, 'volume': 0}\n</pre> <p>The <code>Distribution</code> node replied that it can accept 0 water.</p> <p>But we might try and customise the <code>my_dist</code> object so that it calls some function before carrying on with its default push check.</p> <p>Let's have a look at what code we need to store in our extension module, which we have saved in a file called <code>custom_distribution_handler.py</code>. We will reproduce the function below, which will cause a warning when we load our model because the patch is registered twice.</p> In\u00a0[4]: Copied! <pre>from wsimod.extensions import register_node_patch\n\n\n@register_node_patch(\"my_dist\", \"push_check_handler\", item=\"Node\")\ndef custom_handler_function(self, vqip, *args, **kwargs):\n    \"\"\"A custom `push_check_handler` function.\n\n    Call the default handler for the \"Node\" item.\n    \"\"\"\n    print(\"I reached a custom handler\")\n    return self.push_check_handler[\"default\"](vqip)\n</pre> from wsimod.extensions import register_node_patch   @register_node_patch(\"my_dist\", \"push_check_handler\", item=\"Node\") def custom_handler_function(self, vqip, *args, **kwargs):     \"\"\"A custom `push_check_handler` function.      Call the default handler for the \"Node\" item.     \"\"\"     print(\"I reached a custom handler\")     return self.push_check_handler[\"default\"](vqip) <p>We can customise our model with this handler by specifying it under the <code>extensions</code> attribute and reloading the model to apply the extension.</p> In\u00a0[5]: Copied! <pre>my_model.extensions = [os.path.join(scripts_folder, \"custom_distribution_handler.py\")]\n\nmy_model.save(temp_dir.name)\nmy_model.load(temp_dir.name)\n\nprint(my_model.nodes[\"my_dist\"].push_check_handler)\n</pre> my_model.extensions = [os.path.join(scripts_folder, \"custom_distribution_handler.py\")]  my_model.save(temp_dir.name) my_model.load(temp_dir.name)  print(my_model.nodes[\"my_dist\"].push_check_handler) <pre>{'Node': &lt;bound method custom_handler_function of &lt;wsimod.nodes.distribution.Distribution object at 0x7f8a6a14ded0&gt;&gt;,\n 'default': &lt;bound method Node.push_check_deny of &lt;wsimod.nodes.distribution.Distribution object at 0x7f8a6a14ded0&gt;&gt;}\n</pre> <pre>/home/runner/work/wsi/wsi/wsimod/extensions.py:85: UserWarning: Patch for push_check_handler already registered.\n  warnings.warn(f\"Patch for {target} already registered.\")\n</pre> <p>We have added a new custom function for the <code>Node</code> tag! It includes a print statement so we should be able to see if it is triggered.</p> <p>Let's see what happens when we call that node via it's connected arc. Note, this is an example of how custom handlers do not work!</p> In\u00a0[6]: Copied! <pre>reply = my_model.arcs[\"my_arc\"].send_push_check(\n    {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10}\n)\nprint(reply)\n</pre> reply = my_model.arcs[\"my_arc\"].send_push_check(     {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10} ) print(reply) <pre>Attempted push check to deny\n{'phosphate': 0, 'temperature': 0, 'volume': 0}\n</pre> <p>Even though <code>my_arc</code> starts at a <code>Node</code> object, the custom handler wasn't used. That is because, as explained earlier, if the tag is not specified, the <code>default</code> tag will always be used, no matter what node type the push check is originating from. Let us instead specify a tag. Note, this is an example of how custom handlers do work!</p> In\u00a0[7]: Copied! <pre>reply = my_model.arcs[\"my_arc\"].send_push_check(\n    {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10}, tag=\"Node\"\n)\nprint(reply)\n</pre> reply = my_model.arcs[\"my_arc\"].send_push_check(     {\"volume\": 10, \"phosphate\": 1, \"temperature\": 10}, tag=\"Node\" ) print(reply) <pre>I reached a custom handler\nAttempted push check to deny\n{'phosphate': 0, 'temperature': 0, 'volume': 0}\n</pre> <p>Great - we have successfully customised a handler and used it properly.</p> In\u00a0[8]: Copied! <pre>from wsimod.nodes.storage import Reservoir\n\nmy_reservoir = Reservoir(name=\"my_reservoir\", capacity=10, initial_storage=9)\nprint(my_reservoir.pull_set_handler)\n</pre> from wsimod.nodes.storage import Reservoir  my_reservoir = Reservoir(name=\"my_reservoir\", capacity=10, initial_storage=9) print(my_reservoir.pull_set_handler) <pre>{'default': &lt;function Storage.__init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f8a6a154b80&gt;}\n</pre> <p>We see in the <code>pull_set_handler</code> that all pull requests are channeled through the <code>default</code> tag function, which presumably updates the reservoir storage. Let's just verify that:</p> In\u00a0[9]: Copied! <pre># Inspect initial conditions\nprint(\"Initial storage: {0}\".format(my_reservoir.tank.storage))\n\n# Send a pull request\nreply = my_reservoir.pull_set_handler[\"default\"]({\"volume\": 1})\n\n# Inspect new conditions\nprint(\"Amount pulled: {0}\".format(reply))\nprint(\"Remaining storage: {0}\".format(my_reservoir.tank.storage))\n</pre> # Inspect initial conditions print(\"Initial storage: {0}\".format(my_reservoir.tank.storage))  # Send a pull request reply = my_reservoir.pull_set_handler[\"default\"]({\"volume\": 1})  # Inspect new conditions print(\"Amount pulled: {0}\".format(reply)) print(\"Remaining storage: {0}\".format(my_reservoir.tank.storage)) <pre>\"Initial storage: {'phosphate': 0, 'temperature': 0, 'volume': 9}\"\n\"Amount pulled: {'phosphate': 0.0, 'temperature': 0, 'volume': 1.0}\"\n\"Remaining storage: {'phosphate': 0.0, 'temperature': 0, 'volume': 8.0}\"\n</pre> <p>Behaviour as expected, but this might be a problem. Especially if this reservoir is intended only as a raw water supply, we may want to customise its handlers such that only the <code>FWTW</code> object can pull from it.</p> <p>Well if we want to do this we will have to take some steps to implement this:</p> <ol> <li>Create a simple model to test this behaviour.</li> <li>Update the reservoir's <code>pull_set_handler</code> and <code>pull_check_handler</code>.</li> <li>Ensure that the <code>FWTW</code> pulls from a <code>Reservoir</code> with the <code>FWTW</code> tag.</li> </ol> In\u00a0[10]: Copied! <pre># We will use the previous reservoir\n\n# Create a FWTW\nfrom wsimod.nodes.wtw import FWTW\n\nmy_fwtw = FWTW(\n    name=\"my_fwtw\",\n    service_reservoir_storage_capacity=2,\n)\n\n# Create another object to pull from the reservoir, e.g., a demand node\nfrom wsimod.nodes.demand import Demand\n\nmy_demand = Demand(name=\"my_demand\", constant_demand=1.5)\n\n# Link both objects to the reservoir\nreservoir_to_fwtw = Arc(\n    name=\"reservoir_to_fwtw\", in_port=my_reservoir, out_port=my_fwtw\n)\nreservoir_to_demand = Arc(\n    name=\"reservoir_to_demand\", in_port=my_reservoir, out_port=my_demand\n)\n\n# Store everything to a model\nmy_model = Model()\nmy_model.add_instantiated_nodes([my_reservoir, my_fwtw, my_demand])\nmy_model.add_instantiated_arcs([reservoir_to_fwtw, reservoir_to_demand])\n</pre> # We will use the previous reservoir  # Create a FWTW from wsimod.nodes.wtw import FWTW  my_fwtw = FWTW(     name=\"my_fwtw\",     service_reservoir_storage_capacity=2, )  # Create another object to pull from the reservoir, e.g., a demand node from wsimod.nodes.demand import Demand  my_demand = Demand(name=\"my_demand\", constant_demand=1.5)  # Link both objects to the reservoir reservoir_to_fwtw = Arc(     name=\"reservoir_to_fwtw\", in_port=my_reservoir, out_port=my_fwtw ) reservoir_to_demand = Arc(     name=\"reservoir_to_demand\", in_port=my_reservoir, out_port=my_demand )  # Store everything to a model my_model = Model() my_model.add_instantiated_nodes([my_reservoir, my_fwtw, my_demand]) my_model.add_instantiated_arcs([reservoir_to_fwtw, reservoir_to_demand]) <p>By inspecting their documentation, we see that the <code>create_demand</code> function pulls water for a <code>Demand</code> node, while the <code>treat_water</code> does so for a <code>FWTW</code> node.</p> In\u00a0[11]: Copied! <pre># Inspect initial conditions\nprint(\"Initial storage: {0}\".format(my_reservoir.tank.storage))\nprint(\n    \"Initial service reservoir storage: {0}\".format(\n        my_fwtw.service_reservoir_tank.storage\n    )\n)\n\n# Run model for a timestep\nresults = my_model.run(dates=[to_datetime(\"2000-01-01\")])\n\n# Inspect new conditions\nprint(\"Remaining reservoir storage: {0}\".format(my_reservoir.tank.storage))\nprint(\n    \"New service reservoir storage: {0}\".format(my_fwtw.service_reservoir_tank.storage)\n)\n\n# View arc flows\nprint(results[0])\n</pre> # Inspect initial conditions print(\"Initial storage: {0}\".format(my_reservoir.tank.storage)) print(     \"Initial service reservoir storage: {0}\".format(         my_fwtw.service_reservoir_tank.storage     ) )  # Run model for a timestep results = my_model.run(dates=[to_datetime(\"2000-01-01\")])  # Inspect new conditions print(\"Remaining reservoir storage: {0}\".format(my_reservoir.tank.storage)) print(     \"New service reservoir storage: {0}\".format(my_fwtw.service_reservoir_tank.storage) )  # View arc flows print(results[0]) <pre>\"Initial storage: {'phosphate': 0.0, 'temperature': 0, 'volume': 8.0}\"\n(\"Initial service reservoir storage: {'phosphate': 0, 'temperature': 0, \"\n \"'volume': 0}\")\n</pre> <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 878.39it/s]</pre> <pre>nowhere for sludge to go\nDemand not able to push\nmass balance error for volume of 1.0 in my_reservoir\n(\"Remaining reservoir storage: {'phosphate': 0.0, 'temperature': 0.0, \"\n \"'volume': 4.5}\")\n(\"New service reservoir storage: {'phosphate': 0.0, 'temperature': 0.0, \"\n \"'volume': 1.9396}\")\n[{'arc': 'reservoir_to_fwtw',\n  'flow': 2.0,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'reservoir_to_demand',\n  'flow': 1.5,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> <p>We see some complaint from the <code>my_fwtw</code> about sludge (which are also explaining the small losses and why the new service reservoir volume is not quite 2), because it is anticipated to be connected to a sewer, but by inspecting the reservoir volumes we see that the <code>FWTW</code> has correctly pulled from the <code>Reservoir</code>.</p> <p>Again, a complaint that <code>my_demand</code> had nowhere to send its sewage, but we can see that it has successfully pulled water from <code>my_reservoir</code>. Now we will update <code>my_reservoir</code> so that it denies pulls unless they have the tag <code>FWTW</code>.</p> In\u00a0[12]: Copied! <pre>@register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"FWTW\")\ndef custom_pulls_fwtw(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_set_handler` function.\n\n    Pull from the storage when pulled with the tag \"FWTW\".\n    \"\"\"\n    return self.tank.pull_storage(vqip)\n\n\n@register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"FWTW\")\ndef custom_pullc_fwtw(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_check_handler` function.\n\n    Return available storage when pulled with the tag \"FWTW\".\n    \"\"\"\n    return self.tank.get_avail()\n\n\n@register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"default\")\ndef custom_pulls_default(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_set_handler` function.\n\n    Deny pull sets by default.\n    \"\"\"\n    return self.pull_set_deny(vqip)\n\n\n@register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"default\")\ndef custom_pullc_default(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_check_handler` function.\n\n    Deny pull checks by default.\n    \"\"\"\n    return self.pull_check_deny()\n</pre> @register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"FWTW\") def custom_pulls_fwtw(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_set_handler` function.      Pull from the storage when pulled with the tag \"FWTW\".     \"\"\"     return self.tank.pull_storage(vqip)   @register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"FWTW\") def custom_pullc_fwtw(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_check_handler` function.      Return available storage when pulled with the tag \"FWTW\".     \"\"\"     return self.tank.get_avail()   @register_node_patch(\"my_reservoir\", \"pull_set_handler\", item=\"default\") def custom_pulls_default(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_set_handler` function.      Deny pull sets by default.     \"\"\"     return self.pull_set_deny(vqip)   @register_node_patch(\"my_reservoir\", \"pull_check_handler\", item=\"default\") def custom_pullc_default(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_check_handler` function.      Deny pull checks by default.     \"\"\"     return self.pull_check_deny() <p>Lets add this extension to the model and reload it to apply the extension, verifying that the handler functions have changed.</p> In\u00a0[13]: Copied! <pre># Inspect original handlers\nprint(\n    \"Original set handler: {0}\".format(my_model.nodes[\"my_reservoir\"].pull_set_handler)\n)\nprint(\n    \"Original check handler: {0}\".format(\n        my_model.nodes[\"my_reservoir\"].pull_check_handler\n    )\n)\n\n# Clear the extensions registry (otherwise it will try and apply the earlier extension to `my_dist`)\nfrom wsimod.extensions import extensions_registry\n\nextensions_registry.clear()\n\n# Reload to apply the extensions\nmy_model.extensions = [os.path.join(scripts_folder, \"custom_reservoir_handler.py\")]\nmy_model.save(temp_dir.name)\nmy_model.load(temp_dir.name)\n\n# Inspect new handlers\nprint(\n    \"Overwritten set handler: {0}\".format(\n        my_model.nodes[\"my_reservoir\"].pull_set_handler\n    )\n)\nprint(\n    \"Overwritten set handler: {0}\".format(\n        my_model.nodes[\"my_reservoir\"].pull_check_handler\n    )\n)\n</pre> # Inspect original handlers print(     \"Original set handler: {0}\".format(my_model.nodes[\"my_reservoir\"].pull_set_handler) ) print(     \"Original check handler: {0}\".format(         my_model.nodes[\"my_reservoir\"].pull_check_handler     ) )  # Clear the extensions registry (otherwise it will try and apply the earlier extension to `my_dist`) from wsimod.extensions import extensions_registry  extensions_registry.clear()  # Reload to apply the extensions my_model.extensions = [os.path.join(scripts_folder, \"custom_reservoir_handler.py\")] my_model.save(temp_dir.name) my_model.load(temp_dir.name)  # Inspect new handlers print(     \"Overwritten set handler: {0}\".format(         my_model.nodes[\"my_reservoir\"].pull_set_handler     ) ) print(     \"Overwritten set handler: {0}\".format(         my_model.nodes[\"my_reservoir\"].pull_check_handler     ) ) <pre>(\"Original set handler: {'default': &lt;function \"\n 'Storage.__init__.&lt;locals&gt;.&lt;lambda&gt; at 0x7f8a6a154b80&gt;}')\n(\"Original check handler: {'default': &lt;bound method Tank.get_avail of \"\n '&lt;wsimod.nodes.tanks.Tank object at 0x7f8aa8368b50&gt;&gt;}')\n(\"Overwritten set handler: {'default': &lt;bound method custom_pulls_default of \"\n \"&lt;wsimod.nodes.storage.Reservoir object at 0x7f8a69f98050&gt;&gt;, 'FWTW': &lt;bound \"\n 'method custom_pulls_fwtw of &lt;wsimod.nodes.storage.Reservoir object at '\n '0x7f8a69f98050&gt;&gt;}')\n(\"Overwritten set handler: {'default': &lt;bound method custom_pullc_default of \"\n \"&lt;wsimod.nodes.storage.Reservoir object at 0x7f8a69f98050&gt;&gt;, 'FWTW': &lt;bound \"\n 'method custom_pullc_fwtw of &lt;wsimod.nodes.storage.Reservoir object at '\n '0x7f8a69f98050&gt;&gt;}')\n</pre> <p>It appears that we have successfully overwritten the handlers.</p> <p>Let's verify this behaviour by ensuring that <code>my_demand</code> cannot pull from the reservoir</p> In\u00a0[14]: Copied! <pre># Inspect initial conditions\nprint(\"Initial storage: {0}\".format(my_model.nodes[\"my_reservoir\"].tank.storage))\nprint(\n    f\"Initial storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\"\n)\n\n# Call function to trigger pulls\nresults = my_model.run(dates=[to_datetime(\"2000-01-01\")])\n\n# Inspect new conditions\nprint(\n    \"Remaining reservoir storage: {0}\".format(\n        my_model.nodes[\"my_reservoir\"].tank.storage\n    )\n)\nprint(\n    f\"New storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\"\n)\n\n# View arc flows\nprint(results[0])\n</pre> # Inspect initial conditions print(\"Initial storage: {0}\".format(my_model.nodes[\"my_reservoir\"].tank.storage)) print(     f\"Initial storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\" )  # Call function to trigger pulls results = my_model.run(dates=[to_datetime(\"2000-01-01\")])  # Inspect new conditions print(     \"Remaining reservoir storage: {0}\".format(         my_model.nodes[\"my_reservoir\"].tank.storage     ) ) print(     f\"New storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\" )  # View arc flows print(results[0]) <pre>\"Initial storage: {'phosphate': 0, 'temperature': 0, 'volume': 9}\"\n(\"Initial storage in service reservoirs: {'phosphate': 0, 'temperature': 0, \"\n \"'volume': 0}\")\n</pre> <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 1720.39it/s]</pre> <pre>Attempted pull check from deny\nAttempted pull set from deny\nService reservoirs not filled at my_fwtw on 2000-01-01\nnowhere for sludge to go\nAttempted pull check from deny\nAttempted pull set from deny\ndemand deficit of 1.5 at my_demand on 2000-01-01\nDemand not able to push\n\"Remaining reservoir storage: {'phosphate': 0, 'temperature': 0.0, 'volume': 9}\"\n(\"New storage in service reservoirs: {'phosphate': 0.0, 'temperature': 0.0, \"\n \"'volume': 1.9396}\")\n[{'arc': 'reservoir_to_fwtw',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01},\n {'arc': 'reservoir_to_demand',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> <p>Fantastic - now we see that <code>my_demand</code> is not able to pull from <code>my_reservoir</code>, triggering a bunch of warning messages that occur when trying to pull from a node with denial behaviour.</p> <p>However, we also find that now <code>my_fwtw</code> cannot pull from <code>my_reservoir</code>! As we have explained above, this is because when <code>my_fwtw</code> makes a pull, it sends the <code>default</code> tag by default, not the <code>FWTW</code> tag.</p> <p>Note that we see that the service_reservoir volume has increased, this is because of the assumption that FWTW deficits will be met by other measures</p> In\u00a0[15]: Copied! <pre>@register_node_patch(\"my_fwtw\", \"pull_distributed\")\ndef custom_pull_distributed(self, vqip, *args, **kwargs):\n    \"\"\"A custom `pull_distributed` function.\n\n    Call `pull_distributed` with the tag \"FWTW\".\n    \"\"\"\n    return self._patched_pull_distributed(vqip, tag=\"FWTW\")\n</pre>   @register_node_patch(\"my_fwtw\", \"pull_distributed\") def custom_pull_distributed(self, vqip, *args, **kwargs):     \"\"\"A custom `pull_distributed` function.      Call `pull_distributed` with the tag \"FWTW\".     \"\"\"     return self._patched_pull_distributed(vqip, tag=\"FWTW\") <p>Again, we will add this extension to the model and reload it to apply the extension, verifying that the handler function has been applied and is working.</p> In\u00a0[16]: Copied! <pre># Add the extension to the model\nmy_model.extensions.append(os.path.join(scripts_folder, \"custom_fwtw_pull.py\"))\n\n# Reload to apply the extensions\nextensions_registry.clear()\nmy_model.save(temp_dir.name)\nmy_model.load(temp_dir.name)\n\n# Run the model\nresults = my_model.run(dates=[to_datetime(\"2000-01-01\")])\n\n# Inspect new conditions\nprint(\n    \"Remaining reservoir storage: {0}\".format(\n        my_model.nodes[\"my_reservoir\"].tank.storage\n    )\n)\nprint(\n    f\"New storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\"\n)\n\n# View arc flows\nprint(results[0])\n</pre> # Add the extension to the model my_model.extensions.append(os.path.join(scripts_folder, \"custom_fwtw_pull.py\"))  # Reload to apply the extensions extensions_registry.clear() my_model.save(temp_dir.name) my_model.load(temp_dir.name)  # Run the model results = my_model.run(dates=[to_datetime(\"2000-01-01\")])  # Inspect new conditions print(     \"Remaining reservoir storage: {0}\".format(         my_model.nodes[\"my_reservoir\"].tank.storage     ) ) print(     f\"New storage in service reservoirs: {my_model.nodes['my_fwtw'].service_reservoir_tank.storage}\" )  # View arc flows print(results[0]) <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 1688.53it/s]</pre> <pre>nowhere for sludge to go\nAttempted pull check from deny\nAttempted pull set from deny\ndemand deficit of 1.5 at my_demand on 2000-01-01\nDemand not able to push\n(\"Remaining reservoir storage: {'phosphate': 0.0, 'temperature': 0.0, \"\n \"'volume': 7.0}\")\n(\"New storage in service reservoirs: {'phosphate': 0.0, 'temperature': 0.0, \"\n \"'volume': 1.9396}\")\n[{'arc': 'reservoir_to_fwtw',\n  'flow': 2.0,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'reservoir_to_demand',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> <p>Fantastic, we've got the results we wanted and have now customised a handler!</p> In\u00a0[17]: Copied! <pre># Close the temporary directory\ntemp_dir.cleanup()\n</pre> # Close the temporary directory temp_dir.cleanup()"},{"location":"demo/scripts/customise_interactions/#customise-interactions-py","title":"Customise interactions (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Illustration</p> </li> <li><p>More realistic example</p> </li> <li><p>What next</p> </li> </ol>"},{"location":"demo/scripts/customise_interactions/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial we will demonstrate how to customise interactions between nodes using the handler functionality. Custom handlers are to be used when you want for a node to respond differently to one type of node than another. An example of custom handlers can be found in the sewer node where you can see that the sewer uses different functions to respond to differently tagged push requests. We highlight the <code>push_set_handler</code> customisations below for a sewer object below.</p> <p>Following the [extensions release] the most efficient way to customise anything within WSIMOD is to store your customisations in separate modules which are registered and applied when the model is initialised. Thus, to incrementally build up the example we will store each customisation separately in its own module. However, in practice one would contain these in a single module.</p> <p>But first...</p>"},{"location":"demo/scripts/customise_interactions/#what-are-handlers","title":"What are handlers?\u00b6","text":""},{"location":"demo/scripts/customise_interactions/#illustration","title":"Illustration\u00b6","text":"<p>We can illustrate the behaviour of handlers by creating a simple model. We will create a temporary directory to save our model files in for the purpose of this tutorial.</p>"},{"location":"demo/scripts/customise_interactions/#more-realistic-example","title":"More realistic example\u00b6","text":"<p>A typical kind of behaviour we might be keen to introduce through handlers would be customising how the <code>Reservoir</code> object responds to pulls. By default, any node can pull from a reservoir:</p>"},{"location":"demo/scripts/customise_interactions/#1-create-a-test-model","title":"1. Create a test model\u00b6","text":"<p>We will create two nodes that pull water, a <code>FWTW</code> and a <code>Demand</code>. And link them both to <code>my_reservoir</code>. Under the default behaviour of a <code>Reservoir</code>, it can be pulled from both of these node types, but we may decide that the water is not clean enough to go straight to <code>Demand</code>, and thus wish to customise the handler. (Of course we could more simply remove the arc between <code>my_demand</code> and <code>my_reservoir</code> - but you will have to use your imagination and decide that it is better to customise the handler).</p>"},{"location":"demo/scripts/customise_interactions/#2-update-reservoir-handlers","title":"2. Update reservoir handlers\u00b6","text":"<p>As we illustrated above, we define our new handlers in a separate module, which we will call <code>custom_reservoir_handler.py</code>.</p>"},{"location":"demo/scripts/customise_interactions/#3-update-my_fwtw-to-pull-with-fwtw-tag","title":"3. Update <code>my_fwtw</code> to pull with <code>FWTW</code> tag\u00b6","text":"<p>Now we need to ensure that <code>my_fwtw</code> includes the <code>FWTW</code> tag when it pulls from the reservoir. By inspecting the documentation, we see that <code>FWTW</code> pulls water in the <code>treat_water</code> function using the <code>pull_distributed</code> function.</p> <p>Thus, we could either overwrite the <code>treat_water</code> function or the <code>pull_distributed</code> function.</p> <p>If we choose the first option, we will essentially have to rewrite the whole function, but ensure that <code>pull_distributed</code> is called with the tag <code>FWTW</code>.</p> <p>If we chose the second option, we can just use a decorator to ensure that every time the <code>pull_distributed</code> function is called, it is called with the tag <code>FWTW</code>. Since this seems simpler, we will choose this option.</p> <p>We have the following code in a separate module, which we will call <code>custom_fwtw_pull.py</code>.</p>"},{"location":"demo/scripts/customise_interactions/#what-next","title":"What next?\u00b6","text":"<p>Surely you are an expert at WSIMOD by now! Why not check our contribution guidelines!</p>"},{"location":"demo/scripts/customise_riverreservoir/","title":"Customise a RiverReservoir node (.py)","text":"In\u00a0[1]: Copied! <pre># Import packages\nfrom pprint import pprint as print\n\nfrom wsimod.arcs.arcs import Arc\nfrom wsimod.core import constants\nfrom wsimod.nodes.storage import Groundwater, RiverReservoir\nfrom wsimod.nodes.waste import Waste\nfrom wsimod.orchestration.model import Model, to_datetime\n\n# Set simple pollutants\nconstants.set_simple_pollutants()\n</pre> # Import packages from pprint import pprint as print  from wsimod.arcs.arcs import Arc from wsimod.core import constants from wsimod.nodes.storage import Groundwater, RiverReservoir from wsimod.nodes.waste import Waste from wsimod.orchestration.model import Model, to_datetime  # Set simple pollutants constants.set_simple_pollutants() <p>We will create a simple model that includes a reservoir, a groundwater, and an outlet.</p> In\u00a0[2]: Copied! <pre># Create nodes\nmy_reservoir = RiverReservoir(\n    name=\"my_reservoir\", capacity=10, area=5, initial_storage=6, environmental_flow=1\n)\n\nmy_groundwater = Groundwater(\n    name=\"my_groundwater\", capacity=100, area=10, initial_storage=50\n)\n\nmy_outlet = Waste(name=\"my_outlet\")\n</pre> # Create nodes my_reservoir = RiverReservoir(     name=\"my_reservoir\", capacity=10, area=5, initial_storage=6, environmental_flow=1 )  my_groundwater = Groundwater(     name=\"my_groundwater\", capacity=100, area=10, initial_storage=50 )  my_outlet = Waste(name=\"my_outlet\") <p>We provide arcs for reservoir outflow (i.e., the environmental flow), the infiltration which we will later include, and a baseflow of groundwater.</p> In\u00a0[3]: Copied! <pre># Create arcs\ninfiltration_arc = Arc(\n    name=\"infiltration\", in_port=my_reservoir, out_port=my_groundwater\n)\n\nenvironmental_arc = Arc(name=\"environmental\", in_port=my_reservoir, out_port=my_outlet)\n\nbaseflow_arc = Arc(name=\"baseflow\", in_port=my_groundwater, out_port=my_outlet)\n</pre> # Create arcs infiltration_arc = Arc(     name=\"infiltration\", in_port=my_reservoir, out_port=my_groundwater )  environmental_arc = Arc(name=\"environmental\", in_port=my_reservoir, out_port=my_outlet)  baseflow_arc = Arc(name=\"baseflow\", in_port=my_groundwater, out_port=my_outlet) In\u00a0[4]: Copied! <pre># Create and populate model\nmy_model = Model()\n\nmy_model.add_instantiated_nodes([my_reservoir, my_groundwater, my_outlet])\n\nmy_model.add_instantiated_arcs([infiltration_arc, environmental_arc, baseflow_arc])\n\n# Assign a date to run model for\ndate = to_datetime(\"2000-01-01\")\n</pre> # Create and populate model my_model = Model()  my_model.add_instantiated_nodes([my_reservoir, my_groundwater, my_outlet])  my_model.add_instantiated_arcs([infiltration_arc, environmental_arc, baseflow_arc])  # Assign a date to run model for date = to_datetime(\"2000-01-01\") In\u00a0[5]: Copied! <pre># Run model\nresults = my_model.run(dates=[date])\n\n# Inspect flows\nflow = results[0]\nprint(flow)\n\nstores = results[1]\nprint(stores)\n</pre> # Run model results = my_model.run(dates=[date])  # Inspect flows flow = results[0] print(flow)  stores = results[1] print(stores) <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 1501.72it/s]</pre> <pre>[{'arc': 'infiltration',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01},\n {'arc': 'environmental',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01},\n {'arc': 'baseflow',\n  'flow': 0.25,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n[{'node': 'my_reservoir',\n  'phosphate': 0,\n  'prop': 'tank',\n  'storage': 6,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'node': 'my_groundwater',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 49.75,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> <p>We can see here that the only process that has happened is some groundwater baseflow. Neither the climate forcing, nor environmental flow, nor infiltration occur by default, despite that we have included arcs to connect them. This is because in the case of climate flow and infiltration, the behaviour is not yet defined. While, for environmental flows, we can see that a <code>satisfy_environmental</code> function is provided in the API - however it is not called in the default model orchestration.</p> <p>Thus, we will customise our node to address all of these points.</p> In\u00a0[6]: Copied! <pre># Create climate data\nclimate_data = {(\"precipitation\", date): 0.01, (\"et0\", date): 0.005}\n\n# Give reservoir node access to it\nmy_reservoir.data_input_dict = climate_data\n</pre> # Create climate data climate_data = {(\"precipitation\", date): 0.01, (\"et0\", date): 0.005}  # Give reservoir node access to it my_reservoir.data_input_dict = climate_data In\u00a0[7]: Copied! <pre># Add mass balance terms\nmy_reservoir.net_evaporation = my_reservoir.empty_vqip()\nmy_reservoir.mass_balance_out.append(lambda self=my_reservoir: self.net_evaporation)\n\nmy_reservoir.net_precipitation = my_reservoir.empty_vqip()\nmy_reservoir.mass_balance_in.append(lambda self=my_reservoir: self.net_precipitation)\n</pre> # Add mass balance terms my_reservoir.net_evaporation = my_reservoir.empty_vqip() my_reservoir.mass_balance_out.append(lambda self=my_reservoir: self.net_evaporation)  my_reservoir.net_precipitation = my_reservoir.empty_vqip() my_reservoir.mass_balance_in.append(lambda self=my_reservoir: self.net_precipitation) In\u00a0[8]: Copied! <pre># Decorate reservoir to include climate processes\ndef wrapper(node, func):\n    \"\"\"\n\n    Args:\n        node:\n        func:\n\n    Returns:\n\n    \"\"\"\n\n    def reservoir_functions_wrapper():\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        # Initialise mass balance VQIPs\n        vqip_out = node.empty_vqip()\n        vqip_in = node.empty_vqip()\n\n        # Calculate net change\n        net_in = node.get_data_input(\"precipitation\") - node.get_data_input(\"et0\")\n        net_in *= node.tank.area\n\n        if net_in &gt; 0:\n            # Add precipitation\n            vqip_in = node.v_change_vqip(node.empty_vqip(), net_in)\n            _ = node.tank.push_storage(vqip_in, force=True)\n\n        else:\n            # Remove evaporation\n            evap = node.tank.evaporate(-net_in)\n            vqip_out = node.v_change_vqip(vqip_out, evap)\n\n        # Store in mass balance states\n        my_reservoir.net_evaporation = vqip_out\n        my_reservoir.net_precipitation = vqip_in\n\n        # Call whatever else was going happen\n        return func()\n\n    return reservoir_functions_wrapper\n\n\n# Run decorator\nmy_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions)\n</pre> # Decorate reservoir to include climate processes def wrapper(node, func):     \"\"\"      Args:         node:         func:      Returns:      \"\"\"      def reservoir_functions_wrapper():         \"\"\"          Returns:          \"\"\"         # Initialise mass balance VQIPs         vqip_out = node.empty_vqip()         vqip_in = node.empty_vqip()          # Calculate net change         net_in = node.get_data_input(\"precipitation\") - node.get_data_input(\"et0\")         net_in *= node.tank.area          if net_in &gt; 0:             # Add precipitation             vqip_in = node.v_change_vqip(node.empty_vqip(), net_in)             _ = node.tank.push_storage(vqip_in, force=True)          else:             # Remove evaporation             evap = node.tank.evaporate(-net_in)             vqip_out = node.v_change_vqip(vqip_out, evap)          # Store in mass balance states         my_reservoir.net_evaporation = vqip_out         my_reservoir.net_precipitation = vqip_in          # Call whatever else was going happen         return func()      return reservoir_functions_wrapper   # Run decorator my_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions) <p>OK fantastic, there's no new flows along the arcs, though the baseflow has reduced a bit because it is based on the total groundwater storage which has decreased in our previous example.</p> <p>Most importantly we see that the reservoir volume has increased by 0.025m3, thus our new functionality seems to work. Next we will include environmental flows.</p> In\u00a0[9]: Copied! <pre># Reinspect results\nresults = my_model.run(dates=[date])\n\nflow = results[0]\nprint(flow)\n\nstores = results[1]\nprint(stores)\n</pre> # Reinspect results results = my_model.run(dates=[date])  flow = results[0] print(flow)  stores = results[1] print(stores) <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 2118.34it/s]</pre> <pre>[{'arc': 'infiltration',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01},\n {'arc': 'environmental',\n  'flow': 0,\n  'phosphate': 0,\n  'temperature': 0,\n  'time': 2000-01-01},\n {'arc': 'baseflow',\n  'flow': 0.24875,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n[{'node': 'my_reservoir',\n  'phosphate': 0,\n  'prop': 'tank',\n  'storage': 6.025,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'node': 'my_groundwater',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 49.50125,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> In\u00a0[10]: Copied! <pre># Decorate reservoir to include environmental flows\ndef wrapper(node, func):\n    \"\"\"\n\n    Args:\n        node:\n        func:\n\n    Returns:\n\n    \"\"\"\n\n    def reservoir_functions_wrapper():\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        node.satisfy_environmental()\n        return func()\n\n    return reservoir_functions_wrapper\n\n\nmy_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions)\n</pre> # Decorate reservoir to include environmental flows def wrapper(node, func):     \"\"\"      Args:         node:         func:      Returns:      \"\"\"      def reservoir_functions_wrapper():         \"\"\"          Returns:          \"\"\"         node.satisfy_environmental()         return func()      return reservoir_functions_wrapper   my_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions) <p>Notice how we were able to just pass the decorated version of the <code>make_abstractions</code> function, since that version of the function is still containing all of the new climate behaviour. In practice, this isn't very transparent and we would make one wrapper that includes all of the new functionality that we want to add, but it is fine for the demo.</p> <p>We now see that the <code>environmental_flow</code> of 1 has been satisfied along the arc from the reservoir to the outlet. We also see that the reservoir storage has decreased by this amount but increased by the precipitation amount again, which means our climate functions are still working fine.</p> <p>We also see an incredibly small amount of flow along the infiltration arc, this is because of how the <code>push_distributed</code> function called by <code>satisfy_environmental</code> works, which is behaviour for another tutorial, but can be considered negligible for this demo.</p> In\u00a0[11]: Copied! <pre># Reinspect results\nresults = my_model.run(dates=[date])\n\nflow = results[0]\n\nprint(flow)\n\nstores = results[1]\nprint(stores)\n</pre> # Reinspect results results = my_model.run(dates=[date])  flow = results[0]  print(flow)  stores = results[1] print(stores) <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 1292.54it/s]</pre> <pre>[{'arc': 'infiltration',\n  'flow': 5.074625624999742e-14,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'environmental',\n  'flow': 0.9999999999999493,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'baseflow',\n  'flow': 0.24750625,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n[{'node': 'my_reservoir',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 5.050000000000001,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'node': 'my_groundwater',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 49.25374375000005,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre> In\u00a0[12]: Copied! <pre># Decorate reservoir to include infiltration\nmy_reservoir.infiltration_rate = 0.002  # [metres per timestep]\n\n\ndef wrapper(node, func):\n    \"\"\"\n\n    Args:\n        node:\n        func:\n\n    Returns:\n\n    \"\"\"\n\n    def reservoir_functions_wrapper():\n        \"\"\"\n\n        Returns:\n\n        \"\"\"\n        # Calculate infiltration amount\n        infiltration_amount = node.infiltration_rate * node.tank.area\n\n        # Extract from reservoir tank\n        infiltration_vqip = node.tank.pull_storage({\"volume\": infiltration_amount})\n\n        # Distribute to any connected groundwater nodes\n        reply = node.push_distributed(infiltration_vqip, of_type=\"Groundwater\")\n\n        # If any was not successfully received, store this back in the reservoir\n        node.tank.push_storage(reply, force=True)\n        return func()\n\n    return reservoir_functions_wrapper\n\n\nmy_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions)\n</pre> # Decorate reservoir to include infiltration my_reservoir.infiltration_rate = 0.002  # [metres per timestep]   def wrapper(node, func):     \"\"\"      Args:         node:         func:      Returns:      \"\"\"      def reservoir_functions_wrapper():         \"\"\"          Returns:          \"\"\"         # Calculate infiltration amount         infiltration_amount = node.infiltration_rate * node.tank.area          # Extract from reservoir tank         infiltration_vqip = node.tank.pull_storage({\"volume\": infiltration_amount})          # Distribute to any connected groundwater nodes         reply = node.push_distributed(infiltration_vqip, of_type=\"Groundwater\")          # If any was not successfully received, store this back in the reservoir         node.tank.push_storage(reply, force=True)         return func()      return reservoir_functions_wrapper   my_reservoir.make_abstractions = wrapper(my_reservoir, my_reservoir.make_abstractions) <p>Sure enough, our infiltration works!</p> In\u00a0[13]: Copied! <pre># Reinspect results\nresults = my_model.run(dates=[date])\n\nflow = results[0]\n\nprint(flow)\n\nstores = results[1]\nprint(stores)\n</pre> # Reinspect results results = my_model.run(dates=[date])  flow = results[0]  print(flow)  stores = results[1] print(stores) <pre>\r  0%|          | 0/1 [00:00&lt;?, ?it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1/1 [00:00&lt;00:00, 1784.81it/s]</pre> <pre>[{'arc': 'infiltration',\n  'flow': 0.010000000000050979,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'environmental',\n  'flow': 0.999999999999949,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'arc': 'baseflow',\n  'flow': 0.24626871875000025,\n  'phosphate': 0.0,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n[{'node': 'my_reservoir',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 4.065000000000001,\n  'temperature': 0.0,\n  'time': 2000-01-01},\n {'node': 'my_groundwater',\n  'phosphate': 0.0,\n  'prop': 'tank',\n  'storage': 49.01747503125009,\n  'temperature': 0.0,\n  'time': 2000-01-01}]\n</pre> <pre>\n</pre>"},{"location":"demo/scripts/customise_riverreservoir/#customise-a-riverreservoir-node-py","title":"Customise a RiverReservoir node (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Climate inputs</p> </li> <li><p>Environmental flows</p> </li> <li><p>Infiltration</p> </li> <li><p>What next</p> </li> </ol>"},{"location":"demo/scripts/customise_riverreservoir/#introduction","title":"Introduction\u00b6","text":"<p>In this tutorial we will demonstrate how to customise a <code>RiverReservoir</code> node. This is a run-of-river reservoir, but only a minimal implementation is provided, which does not capture many of the processes that WSIMOD users are likely to require.</p> <p>Rather than customise the <code>RiverReservoir</code> node, we would prefer to equip users with the ability to customise WSIMOD behaviour to accommodate the almost infinite range of possibilities of how would you like a node to behave.</p> <p>Thus in this guide, we will customise a <code>RiverReservoir</code> node to include the following processes:</p> <ul> <li>Precipitation/evapotranspiration from the reservoir surface. This is an example of assigning input data to a node.</li> <li>Ensure that environmental flows are satisfied. This is an example of calling an additional function during the orchestration of a node.</li> <li>Infiltration to attached groundwater nodes. This is an example of adding new behaviour to a node</li> </ul>"},{"location":"demo/scripts/customise_riverreservoir/#climate-inputs","title":"Climate inputs\u00b6","text":""},{"location":"demo/scripts/customise_riverreservoir/#define-inputs","title":"Define inputs\u00b6","text":"<p>We need to define some precipitation/evapotranspiration climate data to force the reservoir with, and then store that information.</p>"},{"location":"demo/scripts/customise_riverreservoir/#mass-balance","title":"Mass balance\u00b6","text":"<p>The first thing we should always consider is how our change will impact mass balance checking, since there is nothing more annoying than our model throwing a bunch of mass balance errors.</p> <p>To do this we will create two state variables <code>net_evaporation</code> and <code>net_precipitation</code> that belong to the <code>my_reservoir</code> node. Every object in WSIMOD has three lists related to mass balance checking: <code>mass_balance_in</code>, <code>mass_balance_out</code>, and <code>mass_balance_ds</code>. You can read more about it in the API but in short, any changes we make need to be appended as functions to these lists.</p> <p>Thus, we store these state variables in a <code>lambda</code> call in the lists. Note that we have given the <code>self = my_reservoir</code> argument in the <code>lamdba</code> call to ensure that the function gets stored in the node's memory, rather than hard coded to this point in the script.</p>"},{"location":"demo/scripts/customise_riverreservoir/#add-new-behaviour","title":"Add new behaviour\u00b6","text":"<p>Now we need to add the processes by which evaporation/precipitation happens to the surface of the reservoir. Our first task is to figure out how this behaviour might be called during orchestration. If we inspect the source code in the <code>Model</code> object, we will see what functions are called during orchestration (i.e., the <code>run</code> function of the <code>Model</code>). We can see that the only function called for <code>Reservoir</code> objects is the <code>make_abstractions</code> function. Thus, the simplest way for us to add new behaviour to a <code>Reservoir</code> is to 'decorate' this function.</p> <p>Note that this is only the right solution if we are happy that these functions take place at this point of orchestration. For example, we might be happy for the climate processes to occur at any point in the timestep, but if we view the order of operations, we might be less sure that infiltration occurs after groundwater has been distributed. For the purpose of this demo though, we will assume that we are happy for all of our new reservoir behaviour to take place at the same time within a timestep.</p> <p>As mentioned, we must decorate our <code>make_abstractions</code> function. To do this we provide a wrapper for the new behaviour that also calls the original function. Then we overwrite the memory address of the original function in the object to perform this new wrapped function. Decorators can be a bit to get your head around, you can read more about them at: https://www.thecodeship.com/patterns/guide-to-python-function-decorators/.</p> <p>The equations that we need to add for this are reasonably self-explanatory, and take place inside the <code>reservoir_functions_wrapper</code>.</p>"},{"location":"demo/scripts/customise_riverreservoir/#environmental-flows","title":"Environmental flows\u00b6","text":"<p>As mentioned, the <code>RiverReservoir</code> object already has a parameter (<code>environmental_flow</code>) and a function (<code>satisfy_environmental</code>) to carry out releases for environmental flows. So all we need to do is redecorate our <code>make_abstractions</code> function to call this new function.</p>"},{"location":"demo/scripts/customise_riverreservoir/#infiltration","title":"Infiltration\u00b6","text":"<p>Our final task is to implement infiltration. We are cool hands at decorating now so should feel confident that we simply need to add some new functionality within a wrapper and decorate the <code>make_abstractions</code> function.</p>"},{"location":"demo/scripts/customise_riverreservoir/#what-next","title":"What next?\u00b6","text":"<p>If you found this a little complicated, don't worry, we were doing some quite complicated things to our nodes. In general, it is easier to customise the interactions between nodes than the nodes themselves. You can find out more about this in our <code>customise_interactions</code> guide!</p>"},{"location":"demo/scripts/land_demo/","title":"Land nodes - hydrology and agriculture (.py)","text":"<p>Import packages</p> In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom wsimod.arcs.arcs import Arc\nfrom wsimod.core import constants\nfrom wsimod.demo.create_oxford import create_timeseries\nfrom wsimod.nodes.land import Land\nfrom wsimod.nodes.nodes import Node\nfrom wsimod.nodes.storage import Groundwater\nfrom wsimod.nodes.waste import Waste\nfrom wsimod.orchestration.model import Model\n</pre>  import os  import pandas as pd from matplotlib import pyplot as plt  from wsimod.arcs.arcs import Arc from wsimod.core import constants from wsimod.demo.create_oxford import create_timeseries from wsimod.nodes.land import Land from wsimod.nodes.nodes import Node from wsimod.nodes.storage import Groundwater from wsimod.nodes.waste import Waste from wsimod.orchestration.model import Model <p>Load input data</p> In\u00a0[2]: Copied! <pre># Select the root path for the data folder. Use the appropriate value for your case.\ndata_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")\n\ninput_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\")\ninput_data = pd.read_csv(input_fid)\ninput_data.loc[input_data.variable == \"flow\", \"value\"] *= constants.M3_S_TO_M3_DT\ninput_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M\ninput_data.date = pd.to_datetime(input_data.date)\ndata_input_dict = input_data.set_index([\"variable\", \"date\"]).value.to_dict()\ndata_input_dict = (\n    input_data.groupby(\"site\")\n    .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n    .to_dict()\n)\n\ndates = input_data.date.drop_duplicates()\ndates_monthyear = input_data.date.dt.to_period(\"M\").unique()\nprint(input_data.sample(10))\n</pre>  # Select the root path for the data folder. Use the appropriate value for your case. data_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")  input_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\") input_data = pd.read_csv(input_fid) input_data.loc[input_data.variable == \"flow\", \"value\"] *= constants.M3_S_TO_M3_DT input_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M input_data.date = pd.to_datetime(input_data.date) data_input_dict = input_data.set_index([\"variable\", \"date\"]).value.to_dict() data_input_dict = (     input_data.groupby(\"site\")     .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())     .to_dict() )  dates = input_data.date.drop_duplicates() dates_monthyear = input_data.date.dt.to_period(\"M\").unique() print(input_data.sample(10)) <pre>              site       date     variable     value\n35148     cherwell 2009-09-23     nitrogen  0.005214\n40458       thames 2012-04-22     nitrogen  0.005449\n28598       thames 2011-09-23      nitrate  0.005229\n14216     evenlode 2012-03-19     fluoride  0.000130\n27002          ray 2011-05-06      nitrate  0.006997\n56049          ray 2011-02-22      calcium  0.115600\n20414          ray 2009-04-02     chloride  0.053400\n10929       thames 2011-03-10      silicon  0.005371\n78992  oxford_land 2010-03-06  temperature  6.464286\n65831     evenlode 2010-01-08        boron  0.000040\n</pre> <pre>/tmp/ipykernel_3183/1905528647.py:12: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n</pre> <p>Input data is stored in dicts</p> In\u00a0[3]: Copied! <pre>land_inputs = data_input_dict[\"oxford_land\"]\n\nexample_date = pd.to_datetime(\"2009-03-03\")\n\nprint(land_inputs[(\"precipitation\", example_date)])\nprint(land_inputs[(\"et0\", example_date)])\nprint(land_inputs[(\"temperature\", example_date)])\n</pre>  land_inputs = data_input_dict[\"oxford_land\"]  example_date = pd.to_datetime(\"2009-03-03\")  print(land_inputs[(\"precipitation\", example_date)]) print(land_inputs[(\"et0\", example_date)]) print(land_inputs[(\"temperature\", example_date)]) <pre>0.015\n0.002\n7.625\n</pre> <p>We are just using some basic pollutants for demonstration</p> In\u00a0[4]: Copied! <pre>constants.set_simple_pollutants()\n\nprint(constants.POLLUTANTS)\n</pre>  constants.set_simple_pollutants()  print(constants.POLLUTANTS) <pre>['phosphate', 'temperature']\n</pre> <p>Create a simple Land node with one basic surface. We can pass surfaces as a dictionary when creating a Land node.</p> In\u00a0[5]: Copied! <pre>surface = {\n    \"type_\": \"Surface\",\n    \"surface\": \"my_surface\",\n    \"area\": 10,\n    \"depth\": 1,\n    \"pollutant_load\": {\"phosphate\": 1e-7},\n}\n\nland = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface])\n</pre> surface = {     \"type_\": \"Surface\",     \"surface\": \"my_surface\",     \"area\": 10,     \"depth\": 1,     \"pollutant_load\": {\"phosphate\": 1e-7}, }  land = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface]) <p>Each surface object is stored in a list of surfaces within the land node.</p> In\u00a0[6]: Copied! <pre>print(land.surfaces[0])\n</pre> print(land.surfaces[0]) <pre>&lt;wsimod.nodes.land.Surface object at 0x7fddbe78de90&gt;\n</pre> <p>We can also access a specific surface by name.</p> In\u00a0[7]: Copied! <pre>print(land.get_surface(\"my_surface\"))\n</pre> print(land.get_surface(\"my_surface\")) <pre>&lt;wsimod.nodes.land.Surface object at 0x7fddbe78de90&gt;\n</pre> <p>This surface will have all the data we passed to the land node in a dict.</p> In\u00a0[8]: Copied! <pre>print(land.get_surface(\"my_surface\").area)\nprint(land.get_surface(\"my_surface\").pollutant_load)\n</pre> print(land.get_surface(\"my_surface\").area) print(land.get_surface(\"my_surface\").pollutant_load) <pre>10\n{'phosphate': 1e-07}\n</pre> <p>A surface is a generic tank, by default it is initialised as empty.</p> In\u00a0[9]: Copied! <pre>print(land.get_surface(\"my_surface\").storage)\n</pre> print(land.get_surface(\"my_surface\").storage) <pre>{'phosphate': 0, 'temperature': 0, 'volume': 0}\n</pre> <p>Let's try to run a timestep for a land node</p> In\u00a0[10]: Copied! <pre>land.t = example_date\nland.monthyear = land.t.to_period(\"M\")\nland.run()\n</pre> land.t = example_date land.monthyear = land.t.to_period(\"M\") land.run() <p>We see that a day of phosphate deposition has occured on the surface.</p> In\u00a0[11]: Copied! <pre>print(land.get_surface(\"my_surface\").storage)\n</pre> print(land.get_surface(\"my_surface\").storage) <pre>{'phosphate': 1e-06, 'temperature': 0, 'volume': 0}\n</pre> <p>The run function in land simply calls the run function in all of its surfaces.</p> In\u00a0[12]: Copied! <pre>land.get_surface(\"my_surface\").run()\n</pre>  land.get_surface(\"my_surface\").run() <p>After running the surface, we see that another day of phosphate deposition has occured.</p> In\u00a0[13]: Copied! <pre>print(land.get_surface(\"my_surface\").storage)\n</pre>  print(land.get_surface(\"my_surface\").storage) <pre>{'phosphate': 2e-06, 'temperature': 0, 'volume': 0}\n</pre> <p>However... no precipitation has occurred (no volume above), despite there being rainfall!</p> In\u00a0[14]: Copied! <pre>print(land.get_data_input(\"precipitation\"))\n</pre> print(land.get_data_input(\"precipitation\")) <pre>0.015\n</pre> <p>To understand why this is, we have to understand how the 'run' function in a surface works. Each surface has a list of functions stored in 'inflows', in 'processes', and in 'outflows'. When 'run' is called, all of the functions in inflows are executed, then processes, then outflows.</p> <p>If we print the lists of functions, we see only some simple deposition occurs on the basic surface in the inflows...</p> In\u00a0[15]: Copied! <pre>print(land.get_surface(\"my_surface\").inflows)\nprint(land.get_surface(\"my_surface\").processes)\nprint(land.get_surface(\"my_surface\").outflows)\n</pre>  print(land.get_surface(\"my_surface\").inflows) print(land.get_surface(\"my_surface\").processes) print(land.get_surface(\"my_surface\").outflows) <pre>[&lt;bound method Surface.simple_deposition of &lt;wsimod.nodes.land.Surface object at 0x7fddbe78de90&gt;&gt;]\n[]\n[]\n</pre> <p>We need a specific subclass of surface to implement more sophisticated hydrological processes!</p> <p>The pervious surface contains a simple lumped hydrological model.</p> <p>We can create the surface, again via parameters stored in a dictionary that is passed to the Land node. is passed to the Land node. Note that the subclass of surface to be created must be specified by the <code>type_</code> keyword.</p> In\u00a0[16]: Copied! <pre>surface = {\n    \"type_\": \"PerviousSurface\",\n    \"surface\": \"my_surface\",\n    \"area\": 10,\n    \"depth\": 0.5,\n    \"pollutant_load\": {\"phosphate\": 1e-7},\n    \"wilting_point\": 0.05,\n    \"field_capacity\": 0.1,\n}\n\nland = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface])\n</pre> surface = {     \"type_\": \"PerviousSurface\",     \"surface\": \"my_surface\",     \"area\": 10,     \"depth\": 0.5,     \"pollutant_load\": {\"phosphate\": 1e-7},     \"wilting_point\": 0.05,     \"field_capacity\": 0.1, }  land = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface]) <p>We have lots of functions now! You will have to look at the documentation of PerviousSurface to understand them in detail</p> <p>We note that the function 'ihacres' in the inflows is the hydrological processes representation, using equations based off the IHACRES model. If a user preferred to use a different hydrological model, they would simply need to substitute out this function in the inflows list.</p> In\u00a0[17]: Copied! <pre>print(land.get_surface(\"my_surface\").inflows)\nprint(land.get_surface(\"my_surface\").processes)\nprint(land.get_surface(\"my_surface\").outflows)\n</pre>  print(land.get_surface(\"my_surface\").inflows) print(land.get_surface(\"my_surface\").processes) print(land.get_surface(\"my_surface\").outflows) <pre>[&lt;bound method Surface.simple_deposition of &lt;wsimod.nodes.land.PerviousSurface object at 0x7fddbe0ba910&gt;&gt;, &lt;bound method PerviousSurface.ihacres of &lt;wsimod.nodes.land.PerviousSurface object at 0x7fddbe0ba910&gt;&gt;]\n[&lt;bound method PerviousSurface.calculate_soil_temperature of &lt;wsimod.nodes.land.PerviousSurface object at 0x7fddbe0ba910&gt;&gt;]\n[&lt;bound method PerviousSurface.route of &lt;wsimod.nodes.land.PerviousSurface object at 0x7fddbe0ba910&gt;&gt;]\n</pre> <p>Now when we run the model, we can see that some rain has happened, because the storage volume has increased (as well as the deposition).</p> In\u00a0[18]: Copied! <pre>land.t = example_date\nland.monthyear = land.t.to_period(\"M\")\nland.run()\nprint(land.get_surface(\"my_surface\").storage)\n</pre> land.t = example_date land.monthyear = land.t.to_period(\"M\") land.run() print(land.get_surface(\"my_surface\").storage) <pre>{'phosphate': 1e-06, 'temperature': 7.921875000000001, 'volume': 0.14248522706924713}\n</pre> <p>However, if we look at the land node, which is the parent of the surfaces that interfaces with other WSIMOD components, we see that all of its tanks are still empty.</p> In\u00a0[19]: Copied! <pre>print(land.percolation.storage)\nprint(land.subsurface_runoff.storage)\nprint(land.surface_runoff.storage)\n</pre> print(land.percolation.storage) print(land.subsurface_runoff.storage) print(land.surface_runoff.storage) <pre>{'phosphate': 0.0, 'temperature': 0, 'volume': 0.0}\n{'phosphate': 0.0, 'temperature': 0, 'volume': 0.0}\n{'phosphate': 0, 'temperature': 0, 'volume': 0.0}\n</pre> <p>This is because the IHACRES model requires soil moisture to be more than a specified amount (the field capacity) for flows to be generated.</p> <p>We can run the surface multiple times to fill it up with water.</p> In\u00a0[20]: Copied! <pre>for i in range(10):\n    land.get_surface(\"my_surface\").run()\n</pre> for i in range(10):     land.get_surface(\"my_surface\").run() <p>There's now a lot of water in the tank</p> In\u00a0[21]: Copied! <pre>print(land.get_surface(\"my_surface\").storage)\n</pre> print(land.get_surface(\"my_surface\").storage) <pre>{'phosphate': 5.734530999564807e-06, 'temperature': 7.957258511567751, 'volume': 0.7806952872182779}\n</pre> <p>Critically, we see that the moisture content is greater than 0.1 (i.e., the field capacity moisture content)</p> In\u00a0[22]: Copied! <pre>print(land.get_surface(\"my_surface\").get_smc() / land.get_surface(\"my_surface\").depth)\n</pre> print(land.get_surface(\"my_surface\").get_smc() / land.get_surface(\"my_surface\").depth) <pre>0.39034764360913893\n</pre> <p>Once soil moisture content is greater than the field capacity, flows will be generated and the land tanks will fill up.</p> In\u00a0[23]: Copied! <pre>print(land.percolation.storage)\nprint(land.subsurface_runoff.storage)\nprint(land.surface_runoff.storage)\n</pre> print(land.percolation.storage) print(land.subsurface_runoff.storage) print(land.surface_runoff.storage) <pre>{'phosphate': 3.949101750326394e-06, 'temperature': 7.903529789012976, 'volume': 0.5435991598154842}\n{'phosphate': 1.3163672501087978e-06, 'temperature': 7.903529789012975, 'volume': 0.18119971993849474}\n{'phosphate': 0, 'temperature': 7.625, 'volume': 0.03814730946073574}\n</pre> <p>These tanks represent flow from the soil layer to either rivers or groundwater. However, land nodes expect to be able to route flow onwards to other nodes.</p> <p>Since the land isn't connected to anything, these won't actually go anywhere if we run it, and they will just build up</p> In\u00a0[24]: Copied! <pre>for i in range(10):\n    land.run()\n\nprint(land.percolation.storage)\nprint(land.subsurface_runoff.storage)\nprint(land.surface_runoff.storage)\n</pre> for i in range(10):     land.run()  print(land.percolation.storage) print(land.subsurface_runoff.storage) print(land.surface_runoff.storage) <pre>{'phosphate': 1.1091929990869039e-05, 'temperature': 7.907975528908189, 'volume': 1.5050766284155752}\n{'phosphate': 3.0837386635250816e-06, 'temperature': 7.861013960531203, 'volume': 0.5016922094718587}\n{'phosphate': 6.135713334312649e-07, 'temperature': 7.848067449790649, 'volume': 0.10561941252039124}\n</pre> In\u00a0[25]: Copied! <pre>node = Node(name=\"my_river\")\ngw = Groundwater(name=\"my_groundwater\", area=10, capacity=100)\noutlet = Waste(name=\"my_outlet\")\n</pre> node = Node(name=\"my_river\") gw = Groundwater(name=\"my_groundwater\", area=10, capacity=100) outlet = Waste(name=\"my_outlet\") <p>We use arcs to join up all of the different nodes according to a standard hydrological representation.</p> In\u00a0[26]: Copied! <pre>arc1 = Arc(in_port=land, out_port=node, name=\"quickflow\")\narc2 = Arc(in_port=land, out_port=gw, name=\"percolation\")\narc3 = Arc(in_port=gw, out_port=node, name=\"baseflow\")\narc4 = Arc(in_port=node, out_port=outlet, name=\"outflow\")\n</pre> arc1 = Arc(in_port=land, out_port=node, name=\"quickflow\") arc2 = Arc(in_port=land, out_port=gw, name=\"percolation\") arc3 = Arc(in_port=gw, out_port=node, name=\"baseflow\") arc4 = Arc(in_port=node, out_port=outlet, name=\"outflow\") <p>If we run the land a few more times, we see that these tanks start to empty (though percolation by nature empties rather slowly!!!)</p> In\u00a0[27]: Copied! <pre>for i in range(10):\n    land.run()\n\nprint(land.percolation.storage)\nprint(land.subsurface_runoff.storage)\nprint(land.surface_runoff.storage)\n</pre>  for i in range(10):     land.run()  print(land.percolation.storage) print(land.subsurface_runoff.storage) print(land.surface_runoff.storage) <pre>{'phosphate': 1.569101705155093e-05, 'temperature': 7.909762826961828, 'volume': 2.1142184152368344}\n{'phosphate': 1.2131965997487093e-06, 'temperature': 7.896243556724506, 'volume': 0.1715050264585061}\n{'phosphate': 0.0, 'temperature': 7.625, 'volume': 0.0}\n</pre> In\u00a0[28]: Copied! <pre>my_model = Model()\n</pre>  my_model = Model() <p>Since we have already created our nodes/arcs, we use the add_instantiated functions</p> In\u00a0[29]: Copied! <pre>my_model.add_instantiated_nodes([land, node, gw, outlet])\nmy_model.add_instantiated_arcs([arc1, arc2, arc3, arc4])\n</pre> my_model.add_instantiated_nodes([land, node, gw, outlet]) my_model.add_instantiated_arcs([arc1, arc2, arc3, arc4]) <p>Store dates</p> In\u00a0[30]: Copied! <pre>my_model.dates = dates\n</pre> my_model.dates = dates <p>We have run the surfaces a few times, so will just set all of the model tanks to empty to give a clean start for the model.</p> In\u00a0[31]: Copied! <pre>my_model.reinit()\n</pre> my_model.reinit() <p>We can run the model with the run function</p> In\u00a0[32]: Copied! <pre>results = my_model.run()\n</pre> results = my_model.run() <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r 17%|\u2588\u258b        | 245/1456 [00:00&lt;00:00, 2449.63it/s]</pre> <pre>\r 34%|\u2588\u2588\u2588\u258e      | 490/1456 [00:00&lt;00:00, 2332.71it/s]</pre> <pre>\r 50%|\u2588\u2588\u2588\u2588\u2589     | 724/1456 [00:00&lt;00:00, 2312.33it/s]</pre> <pre>\r 66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258c   | 956/1456 [00:00&lt;00:00, 2310.81it/s]</pre> <pre>\r 82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1188/1456 [00:00&lt;00:00, 2304.01it/s]</pre> <pre>\r 97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1419/1456 [00:00&lt;00:00, 2286.90it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:00&lt;00:00, 2303.23it/s]</pre> <pre>\n</pre> <p>.. and plot the results!</p> In\u00a0[33]: Copied! <pre>flows = pd.DataFrame(results[0])\n\nf, axs = plt.subplots(2, 1)\nflows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").flow.plot(ax=axs[0])\nflows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").phosphate.plot(ax=axs[1])\n</pre> flows = pd.DataFrame(results[0])  f, axs = plt.subplots(2, 1) flows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").flow.plot(ax=axs[0]) flows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").phosphate.plot(ax=axs[1]) Out[33]: <pre>&lt;Axes: xlabel='time'&gt;</pre> In\u00a0[34]: Copied! <pre>surface_input_data = {}\nfor pollutant in [\"srp\", \"nhx\", \"noy\"]:\n    for source in [\"manure\", \"fertiliser\", \"dry\", \"wet\"]:\n        amount = 1e-7  # kg/m2/timestep\n        ts = create_timeseries(\n            amount, dates_monthyear, \"{0}-{1}\".format(pollutant, source)\n        )\n        ts = ts.set_index([\"variable\", \"date\"]).value.to_dict()\n        surface_input_data = {**surface_input_data, **ts}\n\nprint(surface_input_data[(\"nhx-manure\", example_date.to_period(\"M\"))])\n</pre>  surface_input_data = {} for pollutant in [\"srp\", \"nhx\", \"noy\"]:     for source in [\"manure\", \"fertiliser\", \"dry\", \"wet\"]:         amount = 1e-7  # kg/m2/timestep         ts = create_timeseries(             amount, dates_monthyear, \"{0}-{1}\".format(pollutant, source)         )         ts = ts.set_index([\"variable\", \"date\"]).value.to_dict()         surface_input_data = {**surface_input_data, **ts}  print(surface_input_data[(\"nhx-manure\", example_date.to_period(\"M\"))]) <pre>1e-07\n</pre> <p>Because the surface represents the nitrogen and phosphorus cycles, we need to simulate a greater number of pollutants</p> In\u00a0[35]: Copied! <pre>constants.set_default_pollutants()\n</pre> constants.set_default_pollutants() <p>As with the other surfaces, we create the surface by passing it as a dictionary to the created Land node. I will use the parameters for Maize for this growing surface</p> In\u00a0[36]: Copied! <pre>crop_factor_stages = [0.0, 0.0, 0.3, 0.3, 1.2, 1.2, 0.325, 0.0, 0.0]\ncrop_factor_stage_dates = [0, 90, 91, 121, 161, 213, 244, 245, 366]\nsowing_day = 91\nharvest_day = 244\nET_depletion_factor = 0.55\nrooting_depth = 0.5\n\nsurface = {\n    \"type_\": \"GrowingSurface\",\n    \"surface\": \"my_growing_surface\",\n    \"area\": 10,\n    \"rooting_depth\": rooting_depth,\n    \"crop_factor_stage_dates\": crop_factor_stage_dates,\n    \"crop_factor_stages\": crop_factor_stages,\n    \"sowing_day\": sowing_day,\n    \"harvest_day\": harvest_day,\n    \"ET_depletion_factor\": ET_depletion_factor,\n    \"data_input_dict\": surface_input_data,\n    \"wilting_point\": 0.05,\n    \"field_capacity\": 0.1,\n}\n\nland = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface])\n</pre> crop_factor_stages = [0.0, 0.0, 0.3, 0.3, 1.2, 1.2, 0.325, 0.0, 0.0] crop_factor_stage_dates = [0, 90, 91, 121, 161, 213, 244, 245, 366] sowing_day = 91 harvest_day = 244 ET_depletion_factor = 0.55 rooting_depth = 0.5  surface = {     \"type_\": \"GrowingSurface\",     \"surface\": \"my_growing_surface\",     \"area\": 10,     \"rooting_depth\": rooting_depth,     \"crop_factor_stage_dates\": crop_factor_stage_dates,     \"crop_factor_stages\": crop_factor_stages,     \"sowing_day\": sowing_day,     \"harvest_day\": harvest_day,     \"ET_depletion_factor\": ET_depletion_factor,     \"data_input_dict\": surface_input_data,     \"wilting_point\": 0.05,     \"field_capacity\": 0.1, }  land = Land(name=\"my_land\", data_input_dict=land_inputs, surfaces=[surface]) <p>We see that the inflows includes IHACRES from the pervious surface. But has also added a range of other functions related to deposition.</p> In\u00a0[37]: Copied! <pre>print(land.get_surface(\"my_growing_surface\").inflows)\n</pre> print(land.get_surface(\"my_growing_surface\").inflows) <pre>[&lt;bound method GrowingSurface.calc_crop_cover of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method Surface.atmospheric_deposition of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method Surface.precipitation_deposition of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method PerviousSurface.ihacres of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.effective_precipitation_flushing of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.fertiliser of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.manure of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;]\n</pre> <p>And in particular with the bio-chemical processes occurring within nutrient pools</p> In\u00a0[38]: Copied! <pre>print(land.get_surface(\"my_growing_surface\").processes)\n</pre> print(land.get_surface(\"my_growing_surface\").processes) <pre>[&lt;bound method PerviousSurface.calculate_soil_temperature of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.calc_temperature_dependence_factor of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.calc_soil_moisture_dependence_factor of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.soil_pool_transformation of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.calc_crop_uptake of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.erosion of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.denitrification of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;, &lt;bound method GrowingSurface.adsorption of &lt;wsimod.nodes.land.GrowingSurface object at 0x7fddbc2ce9d0&gt;&gt;]\n</pre> <p>Let's recreate our model with this Maize surface and run the model</p> In\u00a0[39]: Copied! <pre>node = Node(name=\"my_river\")\ngw = Groundwater(name=\"my_groundwater\", area=10, capacity=100)\noutlet = Waste(name=\"my_outlet\")\n\narc1 = Arc(in_port=land, out_port=node, name=\"quickflow\")\narc2 = Arc(in_port=land, out_port=gw, name=\"percolation\")\narc3 = Arc(in_port=gw, out_port=node, name=\"baseflow\")\narc4 = Arc(in_port=node, out_port=outlet, name=\"outflow\")\nmy_model = Model()\n\nmy_model.add_instantiated_nodes([land, node, gw, outlet])\nmy_model.add_instantiated_arcs([arc1, arc2, arc3, arc4])\n\nmy_model.dates = dates\n\nresults = my_model.run()\n</pre> node = Node(name=\"my_river\") gw = Groundwater(name=\"my_groundwater\", area=10, capacity=100) outlet = Waste(name=\"my_outlet\")  arc1 = Arc(in_port=land, out_port=node, name=\"quickflow\") arc2 = Arc(in_port=land, out_port=gw, name=\"percolation\") arc3 = Arc(in_port=gw, out_port=node, name=\"baseflow\") arc4 = Arc(in_port=node, out_port=outlet, name=\"outflow\") my_model = Model()  my_model.add_instantiated_nodes([land, node, gw, outlet]) my_model.add_instantiated_arcs([arc1, arc2, arc3, arc4])  my_model.dates = dates  results = my_model.run() <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r  9%|\u2589         | 138/1456 [00:00&lt;00:00, 1377.57it/s]</pre> <pre>\r 19%|\u2588\u2589        | 276/1456 [00:00&lt;00:00, 1324.12it/s]</pre> <pre>\r 28%|\u2588\u2588\u258a       | 409/1456 [00:00&lt;00:00, 1310.58it/s]</pre> <pre>\r 37%|\u2588\u2588\u2588\u258b      | 541/1456 [00:00&lt;00:00, 1294.53it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258c     | 671/1456 [00:00&lt;00:00, 1295.97it/s]</pre> <pre>\r 55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 801/1456 [00:00&lt;00:00, 1297.05it/s]</pre> <pre>\r 64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 931/1456 [00:00&lt;00:00, 1295.74it/s]</pre> <pre>\r 73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1061/1456 [00:00&lt;00:00, 1295.07it/s]</pre> <pre>\r 82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1191/1456 [00:00&lt;00:00, 1288.28it/s]</pre> <pre>\r 91%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1320/1456 [00:01&lt;00:00, 1285.41it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1449/1456 [00:01&lt;00:00, 1274.24it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:01&lt;00:00, 1291.16it/s]</pre> <pre>\n</pre> <p>We can now plot the results</p> In\u00a0[40]: Copied! <pre>flows = pd.DataFrame(results[0])\n\nf, axs = plt.subplots(2, 1)\nflows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").flow.plot(ax=axs[0])\nflows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").phosphate.plot(ax=axs[1])\n</pre>  flows = pd.DataFrame(results[0])  f, axs = plt.subplots(2, 1) flows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").flow.plot(ax=axs[0]) flows.groupby(\"arc\").get_group(\"outflow\").set_index(\"time\").phosphate.plot(ax=axs[1]) Out[40]: <pre>&lt;Axes: xlabel='time'&gt;</pre> <p>Observe the differences between the two sets of timeseries: Flows look more or less the same (dynamically), which makes sense since they both use IHACRES for hydrology. Only small differences will arise because the crops change the evapotranspiration coefficient</p> <p>Meanwhile, phosphate levels look much more interesting with the GrowingSurface, and are not solely dependent on the hydrology.</p>"},{"location":"demo/scripts/land_demo/#land-nodes-hydrology-and-agriculture-py","title":"Land nodes - hydrology and agriculture (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Data</p> </li> <li><p>Basic surface</p> </li> <li><p>Pervious surface</p> </li> <li><p>Connecting land nodes in a model</p> <p>5.1 Model object</p> </li> <li><p>Growing surface</p> </li> </ol>"},{"location":"demo/scripts/land_demo/#introduction","title":"Introduction\u00b6","text":"<p>A land node is the object that interfaces with other WSIMOD nodes. Each land node can have one or more surfaces. Each surface can be parameterised differently or follow different equations, similar to the hyrological response unit concept in hydrological models.</p> <p>The different surfaces within WSIMOD are used to capture hydrological, agricultural, and urban runoff processes. In this demo we will see how they all work.</p>"},{"location":"demo/scripts/land_demo/#imports-and-forcing-data","title":"Imports and forcing data\u00b6","text":""},{"location":"demo/scripts/land_demo/#basic-surface","title":"Basic surface\u00b6","text":""},{"location":"demo/scripts/land_demo/#pervious-surface","title":"Pervious surface\u00b6","text":""},{"location":"demo/scripts/land_demo/#connecting-land-nodes-in-a-model","title":"Connecting land nodes in a model\u00b6","text":"<p>As mentioned, the land node expects to be able to discharge to groundwater, and rivers (where a river could be the River node or just a generic Node). We also provide a Waste node, which is just a model outlet.</p>"},{"location":"demo/scripts/land_demo/#model-object","title":"Model object\u00b6","text":"<p>We can put these nodes and arcs into the Model object to have a functioning hydrological model.</p> <p>We start by creating a model object.</p>"},{"location":"demo/scripts/land_demo/#growing-surface","title":"Growing surface\u00b6","text":"<p>Hydrology is nice, but anyone using WSIMOD probably isn't interested in hydrology only! The GrowingSurface adds a lot of sophisticated behaviour for agriculture and water quality.</p> <p>Our GrowingSurface needs a bit more data than other surfaces, for fertiliser, manure and atmospheric deposition of ammonia, nitrate and phosphate. We will make up this data.</p> <p>Surface pollution data varies at a monthly timestep rather than daily, though it is applied each day.</p>"},{"location":"demo/scripts/oxford_demo/","title":"WSIMOD model demonstration - Oxford (.py)","text":"<p>Import packages</p> In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\n\nfrom wsimod.arcs.arcs import Arc\nfrom wsimod.core import constants\nfrom wsimod.nodes.catchment import Catchment\nfrom wsimod.nodes.demand import ResidentialDemand\nfrom wsimod.nodes.land import Land\nfrom wsimod.nodes.nodes import Node\nfrom wsimod.nodes.sewer import Sewer\nfrom wsimod.nodes.storage import Groundwater, Reservoir\nfrom wsimod.nodes.waste import Waste\nfrom wsimod.nodes.wtw import FWTW, WWTW\nfrom wsimod.orchestration.model import Model\n\nos.environ[\"USE_PYGEOS\"] = \"0\"\nimport geopandas as gpd\nfrom matplotlib import pyplot as plt\nfrom shapely.geometry import LineString\n</pre>  import os  import pandas as pd  from wsimod.arcs.arcs import Arc from wsimod.core import constants from wsimod.nodes.catchment import Catchment from wsimod.nodes.demand import ResidentialDemand from wsimod.nodes.land import Land from wsimod.nodes.nodes import Node from wsimod.nodes.sewer import Sewer from wsimod.nodes.storage import Groundwater, Reservoir from wsimod.nodes.waste import Waste from wsimod.nodes.wtw import FWTW, WWTW from wsimod.orchestration.model import Model  os.environ[\"USE_PYGEOS\"] = \"0\" import geopandas as gpd from matplotlib import pyplot as plt from shapely.geometry import LineString <p>Load input data</p> In\u00a0[2]: Copied! <pre># Select the root path for the data folder. Use the appropriate value for your case.\ndata_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")\n\ninput_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\")\ninput_data = pd.read_csv(input_fid)\ninput_data.loc[input_data.variable == \"flow\", \"value\"] *= constants.M3_S_TO_M3_DT\ninput_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M\ninput_data.date = pd.to_datetime(input_data.date)\ndata_input_dict = input_data.set_index([\"variable\", \"date\"]).value.to_dict()\ndata_input_dict = (\n    input_data.groupby(\"site\")\n    .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n    .to_dict()\n)\nprint(input_data.sample(10))\n</pre>  # Select the root path for the data folder. Use the appropriate value for your case. data_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")  input_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\") input_data = pd.read_csv(input_fid) input_data.loc[input_data.variable == \"flow\", \"value\"] *= constants.M3_S_TO_M3_DT input_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M input_data.date = pd.to_datetime(input_data.date) data_input_dict = input_data.set_index([\"variable\", \"date\"]).value.to_dict() data_input_dict = (     input_data.groupby(\"site\")     .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())     .to_dict() ) print(input_data.sample(10)) <pre>           site       date     variable         value\n45496    thames 2010-02-26       sodium  1.711429e-02\n18431  cherwell 2011-10-18     chloride  1.053800e-01\n12401  cherwell 2011-03-26     fluoride  1.800000e-04\n48496  evenlode 2010-05-25    potassium  2.887500e-03\n70624  cherwell 2011-03-09         flow  3.697920e+05\n75512    thames 2012-08-10         flow  1.235520e+06\n59772  evenlode 2009-05-18    magnesium  4.400000e-03\n5641     thames 2012-08-27  temperature  1.615714e+01\n18894  cherwell 2013-01-23     chloride  5.245000e-02\n72733  evenlode 2012-12-21         flow  1.684800e+06\n</pre> <pre>/tmp/ipykernel_3210/946595242.py:12: FutureWarning: DataFrameGroupBy.apply operated on the grouping columns. This behavior is deprecated, and in a future version of pandas the grouping columns will be excluded from the operation. Either pass `include_groups=False` to exclude the groupings or explicitly select the grouping columns after groupby to silence this warning.\n  .apply(lambda x: x.set_index([\"variable\", \"date\"]).value.to_dict())\n</pre> <p>Input data is stored in dicts</p> In\u00a0[3]: Copied! <pre>print(data_input_dict[\"cherwell\"][(\"boron\", pd.to_datetime(\"2010-11-20\"))])\n</pre>   print(data_input_dict[\"cherwell\"][(\"boron\", pd.to_datetime(\"2010-11-20\"))]) <pre>6.985714285714286e-05\n</pre> <p>We select dates that are available in the input data</p> In\u00a0[4]: Copied! <pre>dates = input_data.date.unique()\ndates = dates[dates.argsort()]\ndates = [pd.Timestamp(x) for x in dates]\nprint(dates[0:10])\n</pre>   dates = input_data.date.unique() dates = dates[dates.argsort()] dates = [pd.Timestamp(x) for x in dates] print(dates[0:10]) <pre>[Timestamp('2009-03-03 00:00:00'), Timestamp('2009-03-04 00:00:00'), Timestamp('2009-03-05 00:00:00'), Timestamp('2009-03-06 00:00:00'), Timestamp('2009-03-07 00:00:00'), Timestamp('2009-03-08 00:00:00'), Timestamp('2009-03-09 00:00:00'), Timestamp('2009-03-10 00:00:00'), Timestamp('2009-03-11 00:00:00'), Timestamp('2009-03-12 00:00:00')]\n</pre> <p>We can specify the pollutants. In this example we choose based on what pollutants we have input data for.</p> In\u00a0[5]: Copied! <pre>constants.POLLUTANTS = input_data.variable.unique().tolist()\nconstants.POLLUTANTS.remove(\"flow\")\nconstants.POLLUTANTS.remove(\"precipitation\")\nconstants.POLLUTANTS.remove(\"et0\")\nconstants.NON_ADDITIVE_POLLUTANTS = [\"temperature\"]\nconstants.ADDITIVE_POLLUTANTS = list(\n    set(constants.POLLUTANTS).difference(constants.NON_ADDITIVE_POLLUTANTS)\n)\nconstants.FLOAT_ACCURACY = 1e-11\nprint(constants.POLLUTANTS)\n</pre>   constants.POLLUTANTS = input_data.variable.unique().tolist() constants.POLLUTANTS.remove(\"flow\") constants.POLLUTANTS.remove(\"precipitation\") constants.POLLUTANTS.remove(\"et0\") constants.NON_ADDITIVE_POLLUTANTS = [\"temperature\"] constants.ADDITIVE_POLLUTANTS = list(     set(constants.POLLUTANTS).difference(constants.NON_ADDITIVE_POLLUTANTS) ) constants.FLOAT_ACCURACY = 1e-11 print(constants.POLLUTANTS) <pre>['temperature', 'silicon', 'fluoride', 'chloride', 'nitrate', 'sulphate', 'nitrogen', 'sodium', 'potassium', 'calcium', 'magnesium', 'boron']\n</pre> <p>For waste nodes, no parameters are needed, they are just the model outlet</p> In\u00a0[6]: Copied! <pre>thames_above_abingdon = Waste(name=\"thames_above_abingdon\")\n</pre> thames_above_abingdon = Waste(name=\"thames_above_abingdon\") <p>For junctions and abstraction locations, we can simply use the default nodes</p> In\u00a0[7]: Copied! <pre>farmoor_abstraction = Node(name=\"farmoor_abstraction\")\nevenlode_thames = Node(name=\"evenlode_thames\")\ncherwell_ray = Node(name=\"cherwell_ray\")\ncherwell_thames = Node(name=\"cherwell_thames\")\nthames_mixer = Node(name=\"thames_mixer\")\n</pre> farmoor_abstraction = Node(name=\"farmoor_abstraction\") evenlode_thames = Node(name=\"evenlode_thames\") cherwell_ray = Node(name=\"cherwell_ray\") cherwell_thames = Node(name=\"cherwell_thames\") thames_mixer = Node(name=\"thames_mixer\") <p>For catchment nodes, we only need to specify the input data (as a dictionary format).</p> In\u00a0[8]: Copied! <pre>evenlode = Catchment(name=\"evenlode\", data_input_dict=data_input_dict[\"evenlode\"])\nthames = Catchment(name=\"thames\", data_input_dict=data_input_dict[\"thames\"])\nray = Catchment(name=\"ray\", data_input_dict=data_input_dict[\"ray\"])\ncherwell = Catchment(name=\"cherwell\", data_input_dict=data_input_dict[\"cherwell\"])\n</pre> evenlode = Catchment(name=\"evenlode\", data_input_dict=data_input_dict[\"evenlode\"]) thames = Catchment(name=\"thames\", data_input_dict=data_input_dict[\"thames\"]) ray = Catchment(name=\"ray\", data_input_dict=data_input_dict[\"ray\"]) cherwell = Catchment(name=\"cherwell\", data_input_dict=data_input_dict[\"cherwell\"]) <p>We can see that, even though we provided mimimal information (name and input data) each node comes with many predefined functions.</p> In\u00a0[9]: Copied! <pre>print(dir(evenlode))\n</pre> print(dir(evenlode)) <pre>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'apply_overrides', 'blend_vqip', 'check_basic', 'compare_vqip', 'concentration_to_total', 'copy_vqip', 'data_input_dict', 'ds_vqip', 'ds_vqip_c', 'empty_vqip', 'empty_vqip_predefined', 'end_timestep', 'end_timestep_', 'extract_vqip', 'extract_vqip_c', 'get_avail', 'get_connected', 'get_data_input', 'get_direction_arcs', 'get_flow', 'in_arcs', 'in_arcs_type', 'mass_balance', 'mass_balance_ds', 'mass_balance_in', 'mass_balance_out', 'name', 'node_mass_balance', 'out_arcs', 'out_arcs_type', 'pull_check', 'pull_check_abstraction', 'pull_check_basic', 'pull_check_deny', 'pull_check_handler', 'pull_distributed', 'pull_set', 'pull_set_abstraction', 'pull_set_deny', 'pull_set_handler', 'push_check', 'push_check_accept', 'push_check_basic', 'push_check_deny', 'push_check_handler', 'push_distributed', 'push_set', 'push_set_deny', 'push_set_handler', 'query_handler', 'reinit', 'route', 'sum_vqip', 't', 'total_in', 'total_out', 'total_to_concentration', 'unrouted_water', 'v_change_vqip', 'v_change_vqip_c', 'v_distill_vqip', 'v_distill_vqip_c']\n</pre> In\u00a0[10]: Copied! <pre>oxford_fwtw = FWTW(\n    service_reservoir_storage_capacity=1e5,\n    service_reservoir_storage_area=2e4,\n    treatment_throughput_capacity=4.5e4,\n    name=\"oxford_fwtw\",\n)\n</pre>  oxford_fwtw = FWTW(     service_reservoir_storage_capacity=1e5,     service_reservoir_storage_area=2e4,     treatment_throughput_capacity=4.5e4,     name=\"oxford_fwtw\", ) <p>Each node type has different types of functionality available</p> In\u00a0[11]: Copied! <pre>print(dir(oxford_fwtw))\n</pre>  print(dir(oxford_fwtw)) <pre>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', '_liquor_multiplier', '_percent_solids', 'apply_overrides', 'blend_vqip', 'calculate_volume', 'check_basic', 'compare_vqip', 'concentration_to_total', 'copy_vqip', 'current_input', 'data_input_dict', 'ds_vqip', 'ds_vqip_c', 'empty_vqip', 'empty_vqip_predefined', 'end_timestep', 'end_timestep_', 'extract_vqip', 'extract_vqip_c', 'get_connected', 'get_data_input', 'get_direction_arcs', 'get_excess_throughput', 'in_arcs', 'in_arcs_type', 'liquor', 'liquor_multiplier', 'mass_balance', 'mass_balance_ds', 'mass_balance_in', 'mass_balance_out', 'name', 'node_mass_balance', 'out_arcs', 'out_arcs_type', 'percent_solids', 'previous_pulled', 'process_parameters', 'pull_check', 'pull_check_basic', 'pull_check_deny', 'pull_check_fwtw', 'pull_check_handler', 'pull_distributed', 'pull_set', 'pull_set_deny', 'pull_set_fwtw', 'pull_set_handler', 'push_check', 'push_check_accept', 'push_check_basic', 'push_check_deny', 'push_check_handler', 'push_distributed', 'push_set', 'push_set_deny', 'push_set_handler', 'query_handler', 'reinit', 'service_reservoir_initial_storage', 'service_reservoir_storage_area', 'service_reservoir_storage_capacity', 'service_reservoir_storage_elevation', 'service_reservoir_tank', 'solids', 'sum_vqip', 't', 'total_deficit', 'total_in', 'total_out', 'total_pulled', 'total_to_concentration', 'treat_current_input', 'treat_water', 'treated', 'treatment_throughput_capacity', 'unpushed_sludge', 'v_change_vqip', 'v_change_vqip_c', 'v_distill_vqip', 'v_distill_vqip_c']\n</pre> <p>The FWTW node has a tank representing the service reservoirs, we can see that it has been initialised empty.</p> In\u00a0[12]: Copied! <pre>print(oxford_fwtw.service_reservoir_tank.storage)\n</pre>  print(oxford_fwtw.service_reservoir_tank.storage) <pre>{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 0}\n</pre> <p>If we try to pull water from the FWTW, it responds that there is no water to pull.</p> In\u00a0[13]: Copied! <pre>print(oxford_fwtw.pull_check({\"volume\": 10}))\n</pre>  print(oxford_fwtw.pull_check({\"volume\": 10})) <pre>{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 0}\n</pre> <p>If we add in some water, we see the pull check responds that water is available.</p> In\u00a0[14]: Copied! <pre>oxford_fwtw.service_reservoir_tank.storage[\"volume\"] += 25\nprint(oxford_fwtw.pull_check({\"volume\": 10}))\n</pre>  oxford_fwtw.service_reservoir_tank.storage[\"volume\"] += 25 print(oxford_fwtw.pull_check({\"volume\": 10})) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 10.0}\n</pre> <p>When we set a pull request, we see that we successfully receive the water and the tank is updated.</p> In\u00a0[15]: Copied! <pre>reply = oxford_fwtw.pull_set({\"volume\": 10})\nprint(reply)\nprint(oxford_fwtw.service_reservoir_tank.storage)\n</pre>   reply = oxford_fwtw.pull_set({\"volume\": 10}) print(reply) print(oxford_fwtw.service_reservoir_tank.storage) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 10.0}\n{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 15.0}\n</pre> <p>Data inputs are a single dictionary</p> In\u00a0[16]: Copied! <pre>land_inputs = data_input_dict[\"oxford_land\"]\n\nprint(land_inputs[(\"precipitation\", pd.to_datetime(\"2010-11-20\"))])\nprint(land_inputs[(\"et0\", pd.to_datetime(\"2010-11-20\"))])\nprint(land_inputs[(\"temperature\", pd.to_datetime(\"2009-10-15\"))])\n</pre>  land_inputs = data_input_dict[\"oxford_land\"]  print(land_inputs[(\"precipitation\", pd.to_datetime(\"2010-11-20\"))]) print(land_inputs[(\"et0\", pd.to_datetime(\"2010-11-20\"))]) print(land_inputs[(\"temperature\", pd.to_datetime(\"2009-10-15\"))]) <pre>0.0003\n0.002\n13.107142857142858\n</pre> <p>Assign some default pollutant deposition values (kg/m2/d)</p> In\u00a0[17]: Copied! <pre>pollutant_deposition = {\n    \"boron\": 100e-10,\n    \"calcium\": 70e-7,\n    \"chloride\": 60e-10,\n    \"fluoride\": 0.2e-7,\n    \"magnesium\": 6e-7,\n    \"nitrate\": 2e-9,\n    \"nitrogen\": 4e-7,\n    \"potassium\": 7e-7,\n    \"silicon\": 7e-9,\n    \"sodium\": 30e-9,\n    \"sulphate\": 70e-7,\n}\n</pre> pollutant_deposition = {     \"boron\": 100e-10,     \"calcium\": 70e-7,     \"chloride\": 60e-10,     \"fluoride\": 0.2e-7,     \"magnesium\": 6e-7,     \"nitrate\": 2e-9,     \"nitrogen\": 4e-7,     \"potassium\": 7e-7,     \"silicon\": 7e-9,     \"sodium\": 30e-9,     \"sulphate\": 70e-7, } <p>Create two surfaces as a list of dicts</p> In\u00a0[18]: Copied! <pre>surface = [\n    {\n        \"type_\": \"PerviousSurface\",\n        \"area\": 2e7,\n        \"pollutant_load\": pollutant_deposition,\n        \"surface\": \"rural\",\n        \"field_capacity\": 0.3,\n        \"depth\": 0.5,\n        \"initial_storage\": 2e7 * 0.4 * 0.5,\n    },\n    {\n        \"type_\": \"ImperviousSurface\",\n        \"area\": 1e7,\n        \"pollutant_load\": pollutant_deposition,\n        \"surface\": \"urban\",\n        \"initial_storage\": 5e6,\n    },\n]\n</pre> surface = [     {         \"type_\": \"PerviousSurface\",         \"area\": 2e7,         \"pollutant_load\": pollutant_deposition,         \"surface\": \"rural\",         \"field_capacity\": 0.3,         \"depth\": 0.5,         \"initial_storage\": 2e7 * 0.4 * 0.5,     },     {         \"type_\": \"ImperviousSurface\",         \"area\": 1e7,         \"pollutant_load\": pollutant_deposition,         \"surface\": \"urban\",         \"initial_storage\": 5e6,     }, ] <p>Create the land node from these surfaces and the input data</p> In\u00a0[19]: Copied! <pre>oxford_land = Land(surfaces=surface, name=\"oxford_land\", data_input_dict=land_inputs)\n</pre> oxford_land = Land(surfaces=surface, name=\"oxford_land\", data_input_dict=land_inputs) <p>We can see the land node has various tanks that have been initialised empty</p> In\u00a0[20]: Copied! <pre>print(oxford_land.surface_runoff.storage)\nprint(oxford_land.subsurface_runoff.storage)\nprint(oxford_land.percolation.storage)\n</pre>  print(oxford_land.surface_runoff.storage) print(oxford_land.subsurface_runoff.storage) print(oxford_land.percolation.storage) <pre>{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 0}\n{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 0}\n{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 0}\n</pre> <p>We can see the surfaces have also been initialised, although they are not empty because we provided 'initial_storage' parameters.</p> In\u00a0[21]: Copied! <pre>rural_surface = oxford_land.get_surface(\"rural\")\nurban_surface = oxford_land.get_surface(\"urban\")\nprint(\"{0}-{1}\".format(\"rural\", rural_surface.storage))\nprint(\"{0}-{1}\".format(\"urban\", urban_surface.storage))\n</pre> rural_surface = oxford_land.get_surface(\"rural\") urban_surface = oxford_land.get_surface(\"urban\") print(\"{0}-{1}\".format(\"rural\", rural_surface.storage)) print(\"{0}-{1}\".format(\"urban\", urban_surface.storage)) <pre>rural-{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 4000000.0}\nurban-{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 5000000.0}\n</pre> <p>We can run a timestep of the land node with the 'run' command</p> In\u00a0[22]: Copied! <pre>oxford_land.t = pd.to_datetime(\"2012-12-22\")\n\noxford_land.run()\n</pre> oxford_land.t = pd.to_datetime(\"2012-12-22\")  oxford_land.run() <p>We can see that the land and surface tanks have been updated</p> In\u00a0[23]: Copied! <pre>print(oxford_land.surface_runoff.storage)\nprint(oxford_land.subsurface_runoff.storage)\nprint(oxford_land.percolation.storage)\n\nprint(\"{0}-{1}\".format(\"rural\", rural_surface.storage))\nprint(\"{0}-{1}\".format(\"urban\", urban_surface.storage))\n</pre> print(oxford_land.surface_runoff.storage) print(oxford_land.subsurface_runoff.storage) print(oxford_land.percolation.storage)  print(\"{0}-{1}\".format(\"rural\", rural_surface.storage)) print(\"{0}-{1}\".format(\"urban\", urban_surface.storage)) <pre>{'temperature': 3.521534008631931, 'silicon': 0.00020062235262918442, 'fluoride': 0.0005732067217976697, 'chloride': 0.0001719620165393009, 'nitrate': 5.732067217976698e-05, 'sulphate': 0.20062235262918443, 'nitrogen': 0.011464134435953396, 'sodium': 0.0008598100826965045, 'potassium': 0.020062235262918445, 'calcium': 0.20062235262918443, 'magnesium': 0.017196201653930095, 'boron': 0.00028660336089883487, 'volume': 12400.000000000002}\n{'temperature': 0.9722493642718524, 'silicon': 0.0017554455855053634, 'fluoride': 0.0050155588157296096, 'chloride': 0.0015046676447188828, 'nitrate': 0.000501555881572961, 'sulphate': 1.7554455855053634, 'nitrogen': 0.1003111763145922, 'sodium': 0.007523338223594414, 'potassium': 0.17554455855053633, 'calcium': 1.7554455855053634, 'magnesium': 0.1504667644718883, 'boron': 0.0025077794078648048, 'volume': 58900.0}\n{'temperature': 0.3349282031818326, 'silicon': 0.005868203814403644, 'fluoride': 0.016766296612581843, 'chloride': 0.005029888983774552, 'nitrate': 0.001676629661258184, 'sulphate': 5.868203814403645, 'nitrogen': 0.3353259322516368, 'sodium': 0.02514944491887276, 'potassium': 0.5868203814403645, 'calcium': 5.868203814403645, 'magnesium': 0.5029888983774553, 'boron': 0.008383148306290921, 'volume': 176700.00000000003}\nrural-{'temperature': 6.203473168254872, 'silicon': 0.1321757282474618, 'fluoride': 0.3776449378498909, 'chloride': 0.11329348135496725, 'nitrate': 0.037764493784989084, 'sulphate': 132.17572824746182, 'nitrogen': 7.552898756997817, 'sodium': 0.5664674067748363, 'potassium': 13.21757282474618, 'calcium': 132.17572824746182, 'magnesium': 11.329348135496726, 'boron': 0.18882246892494545, 'volume': 3980000.0}\nurban-{'temperature': 0.13343969249141666, 'silicon': 0.06999999999999999, 'fluoride': 0.2, 'chloride': 0.06, 'nitrate': 0.02, 'sulphate': 70.0, 'nitrogen': 4.0, 'sodium': 0.3, 'potassium': 7.0, 'calcium': 70.0, 'magnesium': 6.0, 'boron': 0.1, 'volume': 5104000.0}\n</pre> In\u00a0[24]: Copied! <pre>oxford = ResidentialDemand(\n    name=\"oxford\",\n    population=2e5,\n    per_capita=0.15,\n    pollutant_load={\n        \"boron\": 500 * constants.UG_L_TO_KG_M3 * 0.15,\n        \"calcium\": 150 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"chloride\": 180 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"fluoride\": 0.4 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"magnesium\": 30 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"nitrate\": 60 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"nitrogen\": 50 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"potassium\": 30 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"silicon\": 20 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"sodium\": 200 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"sulphate\": 250 * constants.MG_L_TO_KG_M3 * 0.15,\n        \"temperature\": 14,\n    },\n    data_input_dict=land_inputs,\n)\n# pollutant_load calculated based on expected effluent at WWTW\n</pre> oxford = ResidentialDemand(     name=\"oxford\",     population=2e5,     per_capita=0.15,     pollutant_load={         \"boron\": 500 * constants.UG_L_TO_KG_M3 * 0.15,         \"calcium\": 150 * constants.MG_L_TO_KG_M3 * 0.15,         \"chloride\": 180 * constants.MG_L_TO_KG_M3 * 0.15,         \"fluoride\": 0.4 * constants.MG_L_TO_KG_M3 * 0.15,         \"magnesium\": 30 * constants.MG_L_TO_KG_M3 * 0.15,         \"nitrate\": 60 * constants.MG_L_TO_KG_M3 * 0.15,         \"nitrogen\": 50 * constants.MG_L_TO_KG_M3 * 0.15,         \"potassium\": 30 * constants.MG_L_TO_KG_M3 * 0.15,         \"silicon\": 20 * constants.MG_L_TO_KG_M3 * 0.15,         \"sodium\": 200 * constants.MG_L_TO_KG_M3 * 0.15,         \"sulphate\": 250 * constants.MG_L_TO_KG_M3 * 0.15,         \"temperature\": 14,     },     data_input_dict=land_inputs, ) # pollutant_load calculated based on expected effluent at WWTW In\u00a0[25]: Copied! <pre>farmoor = Reservoir(\n    name=\"farmoor\", capacity=1e7, initial_storage=1e7, area=1.5e6, datum=62\n)\n</pre> farmoor = Reservoir(     name=\"farmoor\", capacity=1e7, initial_storage=1e7, area=1.5e6, datum=62 ) In\u00a0[26]: Copied! <pre>distribution = Node(name=\"oxford_distribution\")\n</pre>  distribution = Node(name=\"oxford_distribution\") In\u00a0[27]: Copied! <pre>oxford_wwtw = WWTW(\n    stormwater_storage_capacity=2e4,\n    stormwater_storage_area=2e4,\n    treatment_throughput_capacity=5e4,\n    name=\"oxford_wwtw\",\n)\n</pre>  oxford_wwtw = WWTW(     stormwater_storage_capacity=2e4,     stormwater_storage_area=2e4,     treatment_throughput_capacity=5e4,     name=\"oxford_wwtw\", ) In\u00a0[28]: Copied! <pre>combined_sewer = Sewer(\n    capacity=4e6, pipe_timearea={0: 0.8, 1: 0.15, 2: 0.05}, name=\"combined_sewer\"\n)\n</pre> combined_sewer = Sewer(     capacity=4e6, pipe_timearea={0: 0.8, 1: 0.15, 2: 0.05}, name=\"combined_sewer\" ) In\u00a0[29]: Copied! <pre>gw = Groundwater(capacity=3.2e9, area=3.2e8, name=\"gw\", residence_time=20)\n</pre>  gw = Groundwater(capacity=3.2e9, area=3.2e8, name=\"gw\", residence_time=20) In\u00a0[30]: Copied! <pre>nodelist = [\n    thames_above_abingdon,\n    evenlode,\n    thames,\n    ray,\n    cherwell,\n    oxford,\n    distribution,\n    farmoor,\n    oxford_fwtw,\n    oxford_wwtw,\n    combined_sewer,\n    oxford_land,\n    gw,\n    farmoor_abstraction,\n    evenlode_thames,\n    cherwell_ray,\n    cherwell_thames,\n    thames_mixer,\n]\n\nprint(nodelist)\n</pre> nodelist = [     thames_above_abingdon,     evenlode,     thames,     ray,     cherwell,     oxford,     distribution,     farmoor,     oxford_fwtw,     oxford_wwtw,     combined_sewer,     oxford_land,     gw,     farmoor_abstraction,     evenlode_thames,     cherwell_ray,     cherwell_thames,     thames_mixer, ]  print(nodelist) <pre>[&lt;wsimod.nodes.waste.Waste object at 0x7f623ebbf490&gt;, &lt;wsimod.nodes.catchment.Catchment object at 0x7f623eb51210&gt;, &lt;wsimod.nodes.catchment.Catchment object at 0x7f623eb510d0&gt;, &lt;wsimod.nodes.catchment.Catchment object at 0x7f623eb4f210&gt;, &lt;wsimod.nodes.catchment.Catchment object at 0x7f623eb4e190&gt;, &lt;wsimod.nodes.demand.ResidentialDemand object at 0x7f623ecdc490&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623ecdc350&gt;, &lt;wsimod.nodes.storage.Reservoir object at 0x7f623ecdd510&gt;, &lt;wsimod.nodes.wtw.FWTW object at 0x7f623ebbf790&gt;, &lt;wsimod.nodes.wtw.WWTW object at 0x7f623ec956d0&gt;, &lt;wsimod.nodes.sewer.Sewer object at 0x7f623ec8f710&gt;, &lt;wsimod.nodes.land.Land object at 0x7f623ece9410&gt;, &lt;wsimod.nodes.storage.Groundwater object at 0x7f623ec8e1d0&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623ebbed90&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623ebbd910&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623ebbcb10&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623ebbc910&gt;, &lt;wsimod.nodes.nodes.Node object at 0x7f623eb96f90&gt;]\n</pre> In\u00a0[31]: Copied! <pre># Standard simple arcs\nfwtw_to_distribution = Arc(\n    in_port=oxford_fwtw, out_port=distribution, name=\"fwtw_to_distribution\"\n)\nprint(fwtw_to_distribution)\n</pre>  # Standard simple arcs fwtw_to_distribution = Arc(     in_port=oxford_fwtw, out_port=distribution, name=\"fwtw_to_distribution\" ) print(fwtw_to_distribution) <pre>&lt;wsimod.arcs.arcs.Arc object at 0x7f623ec8c650&gt;\n</pre> <p>As with nodes, even though we only gave it a few parameters, the arc comes with a lot built in</p> In\u00a0[32]: Copied! <pre>print(dir(fwtw_to_distribution))\n</pre> print(dir(fwtw_to_distribution)) <pre>['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'apply_overrides', 'arc_mass_balance', 'blend_vqip', 'capacity', 'compare_vqip', 'concentration_to_total', 'copy_vqip', 'ds_vqip', 'ds_vqip_c', 'empty_vqip', 'empty_vqip_predefined', 'end_timestep', 'extract_vqip', 'extract_vqip_c', 'flow_in', 'flow_out', 'get_excess', 'in_port', 'mass_balance', 'mass_balance_ds', 'mass_balance_in', 'mass_balance_out', 'name', 'out_port', 'preference', 'reinit', 'send_pull_check', 'send_pull_request', 'send_push_check', 'send_push_request', 'sum_vqip', 'total_to_concentration', 'v_change_vqip', 'v_change_vqip_c', 'v_distill_vqip', 'v_distill_vqip_c', 'vqip_in', 'vqip_out']\n</pre> <p>We can see that the arc links the two nodes</p> In\u00a0[33]: Copied! <pre>print(fwtw_to_distribution.in_port)\n</pre>   print(fwtw_to_distribution.in_port) <pre>&lt;wsimod.nodes.wtw.FWTW object at 0x7f623ebbf790&gt;\n</pre> In\u00a0[34]: Copied! <pre>print(fwtw_to_distribution.out_port)\n</pre>   print(fwtw_to_distribution.out_port) <pre>&lt;wsimod.nodes.nodes.Node object at 0x7f623ecdc350&gt;\n</pre> <p>And that it has updated the nodes that it is connecting.</p> In\u00a0[35]: Copied! <pre>print(oxford_fwtw.out_arcs)\n</pre>   print(oxford_fwtw.out_arcs) <pre>{'fwtw_to_distribution': &lt;wsimod.arcs.arcs.Arc object at 0x7f623ec8c650&gt;}\n</pre> In\u00a0[36]: Copied! <pre>print(distribution.in_arcs)\n</pre>   print(distribution.in_arcs) <pre>{'fwtw_to_distribution': &lt;wsimod.arcs.arcs.Arc object at 0x7f623ec8c650&gt;}\n</pre> <p>We use arcs to send checks and requests..</p> In\u00a0[37]: Copied! <pre>print(fwtw_to_distribution.send_pull_check({\"volume\": 20}))\n</pre>   print(fwtw_to_distribution.send_pull_check({\"volume\": 20})) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 15.0}\n</pre> In\u00a0[38]: Copied! <pre>reply = fwtw_to_distribution.send_pull_request({\"volume\": 20})\nprint(reply)\n</pre>   reply = fwtw_to_distribution.send_pull_request({\"volume\": 20}) print(reply) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 15.0}\n</pre> <p>They convey this information to the nodes that they connect to, which update their state variables</p> In\u00a0[39]: Copied! <pre>print(oxford_fwtw.service_reservoir_tank.storage)\n</pre>   print(oxford_fwtw.service_reservoir_tank.storage) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 0.0}\n</pre> <p>In turn, the arcs update their own state variables.</p> In\u00a0[40]: Copied! <pre>print(fwtw_to_distribution.flow_in)\nprint(fwtw_to_distribution.flow_out)\n</pre>   print(fwtw_to_distribution.flow_in) print(fwtw_to_distribution.flow_out) <pre>15.0\n15.0\n</pre> In\u00a0[41]: Copied! <pre>abstraction_to_farmoor = Arc(\n    in_port=farmoor_abstraction,\n    out_port=farmoor,\n    name=\"abstraction_to_farmoor\",\n    capacity=5e4,\n)\n</pre> abstraction_to_farmoor = Arc(     in_port=farmoor_abstraction,     out_port=farmoor,     name=\"abstraction_to_farmoor\",     capacity=5e4, ) <p>A bit more sophisticated is the 'preference' parameter. We use preference to express where we would prefer the model to send water. In this example, the sewer can send water to both the treatment plant and directly into the river. Of course we would always to prefer to send water to the plant, so we give it a very high preference. Discharging into the river should only be done if there is no capacity left at the WWTW, so we give the arc a very low preference.</p> In\u00a0[42]: Copied! <pre>sewer_to_wwtw = Arc(\n    in_port=combined_sewer, out_port=oxford_wwtw, preference=1e10, name=\"sewer_to_wwtw\"\n)\nsewer_overflow = Arc(\n    in_port=combined_sewer,\n    out_port=thames_mixer,\n    preference=1e-10,\n    name=\"sewer_overflow\",\n)\n</pre> sewer_to_wwtw = Arc(     in_port=combined_sewer, out_port=oxford_wwtw, preference=1e10, name=\"sewer_to_wwtw\" ) sewer_overflow = Arc(     in_port=combined_sewer,     out_port=thames_mixer,     preference=1e-10,     name=\"sewer_overflow\", ) In\u00a0[43]: Copied! <pre>evenlode_to_thames = Arc(\n    in_port=evenlode, out_port=evenlode_thames, name=\"evenlode_to_thames\"\n)\n\nthames_to_thames = Arc(\n    in_port=thames, out_port=evenlode_thames, name=\"thames_to_thames\"\n)\n\nray_to_cherwell = Arc(in_port=ray, out_port=cherwell_ray, name=\"ray_to_cherwell\")\n\ncherwell_to_cherwell = Arc(\n    in_port=cherwell, out_port=cherwell_ray, name=\"cherwell_to_cherwell\"\n)\n\nthames_to_farmoor = Arc(\n    in_port=evenlode_thames, out_port=farmoor_abstraction, name=\"thames_to_farmoor\"\n)\n\nfarmoor_to_mixer = Arc(\n    in_port=farmoor_abstraction, out_port=thames_mixer, name=\"farmoor_to_mixer\"\n)\n\ncherwell_to_mixer = Arc(\n    in_port=cherwell_ray, out_port=thames_mixer, name=\"cherwell_to_mixer\"\n)\n\nwwtw_to_mixer = Arc(in_port=oxford_wwtw, out_port=thames_mixer, name=\"wwtw_to_mixer\")\n\nmixer_to_waste = Arc(\n    in_port=thames_mixer, out_port=thames_above_abingdon, name=\"mixer_to_waste\"\n)\n\ndistribution_to_demand = Arc(\n    in_port=distribution, out_port=oxford, name=\"distribution_to_demand\"\n)\n\nreservoir_to_fwtw = Arc(in_port=farmoor, out_port=oxford_fwtw, name=\"reservoir_to_fwtw\")\n\nfwtw_to_sewer = Arc(in_port=oxford_fwtw, out_port=combined_sewer, name=\"fwtw_to_sewer\")\n\ndemand_to_sewer = Arc(in_port=oxford, out_port=combined_sewer, name=\"demand_to_sewer\")\n\nland_to_sewer = Arc(in_port=oxford_land, out_port=combined_sewer, name=\"land_to_sewer\")\n\nland_to_gw = Arc(in_port=oxford_land, out_port=gw, name=\"land_to_gw\")\n\ngarden_to_gw = Arc(in_port=oxford, out_port=gw, name=\"garden_to_gw\")\n\ngw_to_mixer = Arc(in_port=gw, out_port=thames_mixer, name=\"gw_to_mixer\")\n</pre>   evenlode_to_thames = Arc(     in_port=evenlode, out_port=evenlode_thames, name=\"evenlode_to_thames\" )  thames_to_thames = Arc(     in_port=thames, out_port=evenlode_thames, name=\"thames_to_thames\" )  ray_to_cherwell = Arc(in_port=ray, out_port=cherwell_ray, name=\"ray_to_cherwell\")  cherwell_to_cherwell = Arc(     in_port=cherwell, out_port=cherwell_ray, name=\"cherwell_to_cherwell\" )  thames_to_farmoor = Arc(     in_port=evenlode_thames, out_port=farmoor_abstraction, name=\"thames_to_farmoor\" )  farmoor_to_mixer = Arc(     in_port=farmoor_abstraction, out_port=thames_mixer, name=\"farmoor_to_mixer\" )  cherwell_to_mixer = Arc(     in_port=cherwell_ray, out_port=thames_mixer, name=\"cherwell_to_mixer\" )  wwtw_to_mixer = Arc(in_port=oxford_wwtw, out_port=thames_mixer, name=\"wwtw_to_mixer\")  mixer_to_waste = Arc(     in_port=thames_mixer, out_port=thames_above_abingdon, name=\"mixer_to_waste\" )  distribution_to_demand = Arc(     in_port=distribution, out_port=oxford, name=\"distribution_to_demand\" )  reservoir_to_fwtw = Arc(in_port=farmoor, out_port=oxford_fwtw, name=\"reservoir_to_fwtw\")  fwtw_to_sewer = Arc(in_port=oxford_fwtw, out_port=combined_sewer, name=\"fwtw_to_sewer\")  demand_to_sewer = Arc(in_port=oxford, out_port=combined_sewer, name=\"demand_to_sewer\")  land_to_sewer = Arc(in_port=oxford_land, out_port=combined_sewer, name=\"land_to_sewer\")  land_to_gw = Arc(in_port=oxford_land, out_port=gw, name=\"land_to_gw\")  garden_to_gw = Arc(in_port=oxford, out_port=gw, name=\"garden_to_gw\")  gw_to_mixer = Arc(in_port=gw, out_port=thames_mixer, name=\"gw_to_mixer\") <p>Again, we keep all the arcs in a tidy list together.</p> In\u00a0[44]: Copied! <pre>arclist = [\n    evenlode_to_thames,\n    thames_to_thames,\n    ray_to_cherwell,\n    cherwell_to_cherwell,\n    thames_to_farmoor,\n    farmoor_to_mixer,\n    cherwell_to_mixer,\n    wwtw_to_mixer,\n    sewer_overflow,\n    mixer_to_waste,\n    abstraction_to_farmoor,\n    distribution_to_demand,\n    demand_to_sewer,\n    land_to_sewer,\n    sewer_to_wwtw,\n    fwtw_to_sewer,\n    fwtw_to_distribution,\n    reservoir_to_fwtw,\n    land_to_gw,\n    garden_to_gw,\n    gw_to_mixer,\n]\n</pre> arclist = [     evenlode_to_thames,     thames_to_thames,     ray_to_cherwell,     cherwell_to_cherwell,     thames_to_farmoor,     farmoor_to_mixer,     cherwell_to_mixer,     wwtw_to_mixer,     sewer_overflow,     mixer_to_waste,     abstraction_to_farmoor,     distribution_to_demand,     demand_to_sewer,     land_to_sewer,     sewer_to_wwtw,     fwtw_to_sewer,     fwtw_to_distribution,     reservoir_to_fwtw,     land_to_gw,     garden_to_gw,     gw_to_mixer, ] In\u00a0[45]: Copied! <pre>location_fn = os.path.join(data_folder, \"raw\", \"points_locations.geojson\")\nnodes_gdf = gpd.read_file(location_fn).set_index(\"name\")\narcs_gdf = []\n\nfor arc in arclist:\n    arcs_gdf.append(\n        {\n            \"name\": arc.name,\n            \"geometry\": LineString(\n                [\n                    nodes_gdf.loc[arc.in_port.name, \"geometry\"],\n                    nodes_gdf.loc[arc.out_port.name, \"geometry\"],\n                ]\n            ),\n        }\n    )\n\narcs_gdf = gpd.GeoDataFrame(arcs_gdf, crs=nodes_gdf.crs)\n</pre>  location_fn = os.path.join(data_folder, \"raw\", \"points_locations.geojson\") nodes_gdf = gpd.read_file(location_fn).set_index(\"name\") arcs_gdf = []  for arc in arclist:     arcs_gdf.append(         {             \"name\": arc.name,             \"geometry\": LineString(                 [                     nodes_gdf.loc[arc.in_port.name, \"geometry\"],                     nodes_gdf.loc[arc.out_port.name, \"geometry\"],                 ]             ),         }     )  arcs_gdf = gpd.GeoDataFrame(arcs_gdf, crs=nodes_gdf.crs) <p>Because we converted the information as GeoDataFrames, we can simply plot them below</p> In\u00a0[46]: Copied! <pre>f, ax = plt.subplots()\narcs_gdf.plot(ax=ax)\nnodes_gdf.plot(color=\"r\", ax=ax, zorder=10)\n</pre>  f, ax = plt.subplots() arcs_gdf.plot(ax=ax) nodes_gdf.plot(color=\"r\", ax=ax, zorder=10) Out[46]: <pre>&lt;Axes: &gt;</pre> In\u00a0[47]: Copied! <pre>date = dates[0]\n\nfor node in nodelist:\n    node.t = date\n\nprint(date)\nprint(oxford_fwtw.t)\n</pre> date = dates[0]  for node in nodelist:     node.t = date  print(date) print(oxford_fwtw.t) <pre>2009-03-03 00:00:00\n2009-03-03 00:00:00\n</pre> <p>We can see the service reservoirs are empty but the supply reservoir is not!</p> In\u00a0[48]: Copied! <pre>print(oxford_fwtw.service_reservoir_tank.storage)\nprint(farmoor.tank.storage)\n</pre>  print(oxford_fwtw.service_reservoir_tank.storage) print(farmoor.tank.storage) <pre>{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 0.0}\n{'temperature': 0, 'silicon': 0, 'fluoride': 0, 'chloride': 0, 'nitrate': 0, 'sulphate': 0, 'nitrogen': 0, 'sodium': 0, 'potassium': 0, 'calcium': 0, 'magnesium': 0, 'boron': 0, 'volume': 10000000.0}\n</pre> <p>If we call the FWTW's treat_water function it will pull water from the supply reservoir and update its service reservoirs</p> In\u00a0[49]: Copied! <pre>oxford_fwtw.treat_water()\n\nprint(oxford_fwtw.service_reservoir_tank.storage)\nprint(farmoor.tank.storage)\n</pre>  oxford_fwtw.treat_water()  print(oxford_fwtw.service_reservoir_tank.storage) print(farmoor.tank.storage) <pre>{'temperature': 0.0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 43641.0}\n{'temperature': 0, 'silicon': 0.0, 'fluoride': 0.0, 'chloride': 0.0, 'nitrate': 0.0, 'sulphate': 0.0, 'nitrogen': 0.0, 'sodium': 0.0, 'potassium': 0.0, 'calcium': 0.0, 'magnesium': 0.0, 'boron': 0.0, 'volume': 9955000.0}\n</pre> <p>This information is tracked in the arcs that enter the FWTW</p> In\u00a0[50]: Copied! <pre>print(oxford_fwtw.in_arcs)\n</pre>   print(oxford_fwtw.in_arcs) <pre>{'reservoir_to_fwtw': &lt;wsimod.arcs.arcs.Arc object at 0x7f623ec38290&gt;}\n</pre> In\u00a0[51]: Copied! <pre>print(reservoir_to_fwtw.flow_in)\nprint(reservoir_to_fwtw.flow_out)\n</pre>   print(reservoir_to_fwtw.flow_in) print(reservoir_to_fwtw.flow_out) <pre>45000.0\n45000.0\n</pre> <p>Although none of that water has yet entered the distribution network (only some small flow from the earlier demonstration)</p> In\u00a0[52]: Copied! <pre>print(fwtw_to_distribution.flow_in)\n</pre>   print(fwtw_to_distribution.flow_in) <pre>15.0\n</pre> <p>That is because no water consumption demand had yet been generated.</p> <p>If we call the demand node's create_demand function we see that the distribution arc becomes utilised.</p> In\u00a0[53]: Copied! <pre>oxford.create_demand()\nprint(fwtw_to_distribution.flow_in)\n</pre>  oxford.create_demand() print(fwtw_to_distribution.flow_in) <pre>30015.0\n</pre> <p>We also see that this gets pushed onwards into the sewer system</p> In\u00a0[54]: Copied! <pre>print(demand_to_sewer.flow_in)\n</pre> print(demand_to_sewer.flow_in) <pre>30000.0\n</pre> <p>Many nodes have functions intended to be called during orchestration. These functions are described in the documentation. For example, we see in the Land node API reference that the 'run' function is intended to be called from orchestration.</p> In\u00a0[55]: Copied! <pre>oxford_land.run()\n</pre> oxford_land.run() <p>Below we call the functions for other nodes</p> In\u00a0[56]: Copied! <pre># Discharge GW\ngw.distribute()\n\n# Discharge sewers (pushed to other sewers or WWTW)\ncombined_sewer.make_discharge()\n\n# Run WWTW model\noxford_wwtw.calculate_discharge()\n\n# Make abstractions\nfarmoor.make_abstractions()\n\n# Discharge WW\noxford_wwtw.make_discharge()\n\n# Route catchments\nevenlode.route()\nthames.route()\nray.route()\ncherwell.route()\n</pre>  # Discharge GW gw.distribute()  # Discharge sewers (pushed to other sewers or WWTW) combined_sewer.make_discharge()  # Run WWTW model oxford_wwtw.calculate_discharge()  # Make abstractions farmoor.make_abstractions()  # Discharge WW oxford_wwtw.make_discharge()  # Route catchments evenlode.route() thames.route() ray.route() cherwell.route() In\u00a0[57]: Copied! <pre>for node in nodelist:\n    in_, ds_, out_ = node.node_mass_balance()\n</pre>  for node in nodelist:     in_, ds_, out_ = node.node_mass_balance() <pre>mass balance error for volume of 15.0 in oxford_distribution\nmass balance error for volume of -15.0 in oxford_fwtw\n</pre> <p>We should also call the end_timestep function in nodes and arcs. This is important for mass balance testing and capturing the behaviour of some dynamic processes in nodes.</p> In\u00a0[58]: Copied! <pre>for node in nodelist:\n    node.end_timestep()\n\nfor arc in arclist:\n    arc.end_timestep()\n</pre>  for node in nodelist:     node.end_timestep()  for arc in arclist:     arc.end_timestep() In\u00a0[59]: Copied! <pre>my_model = Model()\nmy_model.add_instantiated_nodes(nodelist)\nmy_model.add_instantiated_arcs(arclist)\nmy_model.dates = dates\n</pre>  my_model = Model() my_model.add_instantiated_nodes(nodelist) my_model.add_instantiated_arcs(arclist) my_model.dates = dates <p>The model object lets us reinitialise the nodes/arcs, and run all of the orchestration with a 'run' function.</p> In\u00a0[60]: Copied! <pre>my_model.reinit()\n\nflows, _, _, _ = my_model.run()\n</pre>  my_model.reinit()  flows, _, _, _ = my_model.run() <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r  2%|\u258f         | 33/1456 [00:00&lt;00:04, 324.26it/s]</pre> <pre>\r  5%|\u258d         | 66/1456 [00:00&lt;00:04, 322.53it/s]</pre> <pre>\r  7%|\u258b         | 99/1456 [00:00&lt;00:04, 322.26it/s]</pre> <pre>\r  9%|\u2589         | 132/1456 [00:00&lt;00:04, 322.60it/s]</pre> <pre>\r 11%|\u2588\u258f        | 165/1456 [00:00&lt;00:04, 320.12it/s]</pre> <pre>\r 14%|\u2588\u258e        | 198/1456 [00:00&lt;00:03, 318.09it/s]</pre> <pre>\r 16%|\u2588\u258c        | 230/1456 [00:00&lt;00:03, 317.14it/s]</pre> <pre>\r 18%|\u2588\u258a        | 262/1456 [00:00&lt;00:03, 314.32it/s]</pre> <pre>\r 20%|\u2588\u2588        | 294/1456 [00:00&lt;00:03, 310.23it/s]</pre> <pre>\r 22%|\u2588\u2588\u258f       | 326/1456 [00:01&lt;00:03, 310.35it/s]</pre> <pre>\r 25%|\u2588\u2588\u258d       | 358/1456 [00:01&lt;00:03, 311.66it/s]</pre> <pre>\r 27%|\u2588\u2588\u258b       | 390/1456 [00:01&lt;00:03, 312.84it/s]</pre> <pre>\r 29%|\u2588\u2588\u2589       | 422/1456 [00:01&lt;00:03, 313.46it/s]</pre> <pre>\r 31%|\u2588\u2588\u2588       | 454/1456 [00:01&lt;00:03, 314.51it/s]</pre> <pre>\r 33%|\u2588\u2588\u2588\u258e      | 486/1456 [00:01&lt;00:03, 314.01it/s]</pre> <pre>\r 36%|\u2588\u2588\u2588\u258c      | 518/1456 [00:01&lt;00:02, 314.56it/s]</pre> <pre>\r 38%|\u2588\u2588\u2588\u258a      | 550/1456 [00:01&lt;00:02, 310.86it/s]</pre> <pre>\r 40%|\u2588\u2588\u2588\u2589      | 582/1456 [00:01&lt;00:02, 311.56it/s]</pre> <pre>\r 42%|\u2588\u2588\u2588\u2588\u258f     | 614/1456 [00:01&lt;00:02, 308.31it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258d     | 646/1456 [00:02&lt;00:02, 309.75it/s]</pre> <pre>\r 46%|\u2588\u2588\u2588\u2588\u258b     | 677/1456 [00:02&lt;00:02, 305.32it/s]</pre> <pre>\r 49%|\u2588\u2588\u2588\u2588\u258a     | 709/1456 [00:02&lt;00:02, 307.90it/s]</pre> <pre>\r 51%|\u2588\u2588\u2588\u2588\u2588     | 741/1456 [00:02&lt;00:02, 309.88it/s]</pre> <pre>\r 53%|\u2588\u2588\u2588\u2588\u2588\u258e    | 773/1456 [00:02&lt;00:02, 311.90it/s]</pre> <pre>\r 55%|\u2588\u2588\u2588\u2588\u2588\u258c    | 805/1456 [00:02&lt;00:02, 313.34it/s]</pre> <pre>\r 57%|\u2588\u2588\u2588\u2588\u2588\u258b    | 837/1456 [00:02&lt;00:01, 311.44it/s]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2589    | 869/1456 [00:02&lt;00:01, 312.53it/s]</pre> <pre>\r 62%|\u2588\u2588\u2588\u2588\u2588\u2588\u258f   | 901/1456 [00:02&lt;00:01, 313.59it/s]</pre> <pre>\r 64%|\u2588\u2588\u2588\u2588\u2588\u2588\u258d   | 933/1456 [00:02&lt;00:01, 313.27it/s]</pre> <pre>\r 66%|\u2588\u2588\u2588\u2588\u2588\u2588\u258b   | 965/1456 [00:03&lt;00:01, 313.96it/s]</pre> <pre>\r 68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 997/1456 [00:03&lt;00:01, 313.46it/s]</pre> <pre>\r 71%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588   | 1029/1456 [00:03&lt;00:01, 313.56it/s]</pre> <pre>\r 73%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e  | 1061/1456 [00:03&lt;00:01, 313.32it/s]</pre> <pre>\r 75%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c  | 1093/1456 [00:03&lt;00:01, 311.12it/s]</pre> <pre>\r 77%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1125/1456 [00:03&lt;00:01, 312.62it/s]</pre> <pre>\r 79%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589  | 1157/1456 [00:03&lt;00:00, 311.96it/s]</pre> <pre>\r 82%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258f | 1189/1456 [00:03&lt;00:00, 312.06it/s]</pre> <pre>\r 84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1221/1456 [00:03&lt;00:00, 311.22it/s]</pre> <pre>\r 86%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c | 1253/1456 [00:04&lt;00:00, 310.62it/s]</pre> <pre>\r 88%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a | 1285/1456 [00:04&lt;00:00, 311.15it/s]</pre> <pre>\r 90%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588 | 1317/1456 [00:04&lt;00:00, 311.44it/s]</pre> <pre>\r 93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1349/1456 [00:04&lt;00:00, 311.76it/s]</pre> <pre>\r 95%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d| 1381/1456 [00:04&lt;00:00, 309.60it/s]</pre> <pre>\r 97%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b| 1413/1456 [00:04&lt;00:00, 310.47it/s]</pre> <pre>\r 99%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2589| 1445/1456 [00:04&lt;00:00, 310.95it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:04&lt;00:00, 312.57it/s]</pre> <pre>\n</pre> <p>The model outputs flows as a dictionary which can be converted to a dataframe</p> In\u00a0[61]: Copied! <pre>flows = pd.DataFrame(flows)\n\nprint(flows.sample(10))\n</pre>  flows = pd.DataFrame(flows)  print(flows.sample(10)) <pre>                     arc           flow       time  temperature      silicon  \\\n15610      wwtw_to_mixer   30927.835047 2011-03-16    12.851023    26.255192   \n3267     demand_to_sewer   30000.000000 2009-08-05    20.363333   600.000000   \n8105         gw_to_mixer   16012.319302 2010-03-23     7.003461     0.097770   \n20094         land_to_gw    3909.200273 2011-10-15    14.509779     0.060135   \n19728     mixer_to_waste  215272.581766 2011-09-28    15.586675  1420.287524   \n3246     demand_to_sewer   30000.000000 2009-08-04    20.300000   600.000000   \n17773      wwtw_to_mixer   30972.155285 2011-06-27    19.985006    25.424868   \n27305   farmoor_to_mixer  805417.786760 2012-09-23    12.026997  5021.309075   \n8680       wwtw_to_mixer   30927.835047 2010-04-20    14.186607    24.814092   \n12690  cherwell_to_mixer  202780.800000 2010-10-28     8.202964  1763.863201   \n\n         fluoride      chloride      nitrate      sulphate     nitrogen  \\\n15610    0.526166    211.148560    66.181418    296.807459    56.499095   \n3267    12.000000   5400.000000  1800.000000   7500.000000  1500.000000   \n8105     0.279342      0.083803     0.027934     97.769596     5.586834   \n20094    0.171815      0.051544     0.017181     60.135229     3.436299   \n19728   31.283776  11802.923210   946.466293  13463.625990   953.447447   \n3246    12.000000   5400.000000  1800.000000   7500.000000  1500.000000   \n17773    0.530576    211.017033    65.841305    297.933580    56.338042   \n27305  100.810350  22686.622149  5067.594914  34703.522091  5754.865401   \n8680     0.499744    202.955396    64.853372    285.189411    54.989594   \n12690   24.661769  12724.520379  1165.901605  15346.312457  1285.919218   \n\n             sodium    potassium       calcium    magnesium      boron  \n15610    219.966387    33.986784    245.926312    34.594559   0.547285  \n3267    6000.000000   900.000000   4500.000000   900.000000  15.000000  \n8105       0.419013     9.776960     97.769596     8.380251   0.139671  \n20094      0.257722     6.013523     60.135229     5.154448   0.085907  \n19728   9012.681710  1685.702421  18471.986847  1292.875280  14.344778  \n3246    6000.000000   900.000000   4500.000000   900.000000  15.000000  \n17773    219.946560    34.055696    248.580379    34.693852   0.547155  \n27305  13885.691085  2882.863169  83026.814272  3759.503851  31.659908  \n8680     214.938272    33.085452    226.942479    33.681976   0.538218  \n12690   8606.592823  1669.405989  20521.278720  1569.574491  18.729693  \n</pre> In\u00a0[62]: Copied! <pre>mixer_val_df = pd.read_csv(os.path.join(data_folder, \"raw\", \"mixer_wims_val.csv\"))\nmixer_val_df.date = pd.to_datetime(mixer_val_df.date)\nmixer_val_df = mixer_val_df.loc[mixer_val_df.date.isin(dates)]\nval_pollutants = mixer_val_df.variable.unique()\nmixer_val_df = mixer_val_df.pivot(index=\"date\", columns=\"variable\", values=\"value\")\n</pre>  mixer_val_df = pd.read_csv(os.path.join(data_folder, \"raw\", \"mixer_wims_val.csv\")) mixer_val_df.date = pd.to_datetime(mixer_val_df.date) mixer_val_df = mixer_val_df.loc[mixer_val_df.date.isin(dates)] val_pollutants = mixer_val_df.variable.unique() mixer_val_df = mixer_val_df.pivot(index=\"date\", columns=\"variable\", values=\"value\") <p>We get rid of the first day of flows because our tanks were initialised empty and will not be informative</p> In\u00a0[63]: Copied! <pre>flows = flows.loc[flows.time != dates[0]]\n</pre> flows = flows.loc[flows.time != dates[0]] <p>We convert our flows, which are simulated in kg/d into a concentration value (kg/m3/d).</p> In\u00a0[64]: Copied! <pre>flows_plot = flows.copy()\n\n# Convert to KG/M3\nfor pol in set(val_pollutants):\n    if pol != \"temperature\":\n        flows_plot[pol] /= flows_plot.flow\n</pre> flows_plot = flows.copy()  # Convert to KG/M3 for pol in set(val_pollutants):     if pol != \"temperature\":         flows_plot[pol] /= flows_plot.flow <p>We pick the model outlet as a validation location and make a pretty plot - fantastic!</p> In\u00a0[65]: Copied! <pre>plot_arc = \"mixer_to_waste\"\nf, axs = plt.subplots(val_pollutants.size, 1)\nfor pol, ax in zip(val_pollutants, axs):\n    ax.plot(\n        flows_plot.loc[flows_plot.arc == plot_arc, [pol, \"time\"]].set_index(\"time\"),\n        color=\"b\",\n        label=\"simulation\",\n    )\n    ax.plot(mixer_val_df[pol], ls=\"\", marker=\"o\", color=\"r\", label=\"spot sample\")\n    ax.set_ylabel(pol)\nplt.legend()\n</pre>  plot_arc = \"mixer_to_waste\" f, axs = plt.subplots(val_pollutants.size, 1) for pol, ax in zip(val_pollutants, axs):     ax.plot(         flows_plot.loc[flows_plot.arc == plot_arc, [pol, \"time\"]].set_index(\"time\"),         color=\"b\",         label=\"simulation\",     )     ax.plot(mixer_val_df[pol], ls=\"\", marker=\"o\", color=\"r\", label=\"spot sample\")     ax.set_ylabel(pol) plt.legend() Out[65]: <pre>&lt;matplotlib.legend.Legend at 0x7f623eb3b890&gt;</pre>"},{"location":"demo/scripts/oxford_demo/#wsimod-model-demonstration-oxford-py","title":"WSIMOD model demonstration - Oxford (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Data</p> </li> <li><p>Nodes</p> <p>3.1 Freshwater Treatment Works</p> <p>3.2 Land</p> <p>3.3 Demand</p> <p>3.4 Reservoir</p> <p>3.5 Distribution</p> <p>3.6 Wastewater Treatment Works</p> <p>3.7 Sewers</p> <p>3.8 Groundwater</p> <p>3.9 Node list</p> </li> <li><p>Arcs</p> <p>4.1 Arc parameters</p> <p>4.2 Create the arcs</p> </li> <li><p>Mapping</p> </li> <li><p>Orchestration</p> <p>6.1 Orchestrating an individual timestep</p> <p>6.2 Ending a timestep</p> </li> <li><p>Model object</p> <p>7.1 Validation</p> </li> </ol>"},{"location":"demo/scripts/oxford_demo/#we-will-cover-a-demo-wsimod-case-study","title":"We will cover a demo WSIMOD case study\u00b6","text":"<p>The glamorous town of Oxford will be our demo case study. Below, we will create these nodes and arcs, orchestrate them into a model, and run simulations.</p> <p></p> <p>Although GIS is pretty, the schematic below is a more accurate representation of what will be created. WSIMOD treats everything as a node or an arc.</p> <p></p>"},{"location":"demo/scripts/oxford_demo/#imports-and-forcing-data","title":"Imports and forcing data\u00b6","text":""},{"location":"demo/scripts/oxford_demo/#create-nodes","title":"Create nodes\u00b6","text":""},{"location":"demo/scripts/oxford_demo/#freshwater-treatment-works","title":"Freshwater treatment works\u00b6","text":"<p>Each type of node uses different parameters (see API reference). Below we create a freshwater treatment works (FWTW)</p>"},{"location":"demo/scripts/oxford_demo/#land","title":"Land\u00b6","text":"<p>We will now create a land node, it is a bit involved so you might want to skip ahead to demand, or check out the land node tutorial</p>"},{"location":"demo/scripts/oxford_demo/#residential-demand","title":"Residential demand\u00b6","text":"<p>The residential demand node requires population, per capita demand and a pollutant_load dictionary that defines how much (weight in kg) pollution is generated per person per day.</p>"},{"location":"demo/scripts/oxford_demo/#reservoir","title":"Reservoir\u00b6","text":"<p>A reservoir node is used to make abstractions from rivers and supply FWTWs</p>"},{"location":"demo/scripts/oxford_demo/#distribution","title":"Distribution\u00b6","text":"<p>We use a generic Node as a junction to represent the distribution network between the FWTW and households</p>"},{"location":"demo/scripts/oxford_demo/#wastewater-treatment-works","title":"Wastewater treatment works\u00b6","text":"<p>Wastewater treatment works (WWTW) are nodes that can store sewage water temporarily in storm tanks, and reduce the pollution amounts in water before releasing them onwards to rivers.</p>"},{"location":"demo/scripts/oxford_demo/#sewers","title":"Sewers\u00b6","text":"<p>Sewer nodes enable water to transition between households and WWTWs, and between impervious surfaces and rivers or WWTWs. They use a timearea diagram to represent travel time, which assigns a specified percentage of water to take a specified duration to pass through the sewer node.</p>"},{"location":"demo/scripts/oxford_demo/#groundwater","title":"Groundwater\u00b6","text":"<p>Groundwater nodes implement a simple residence time to determine baseflow</p>"},{"location":"demo/scripts/oxford_demo/#create-a-nodelist","title":"Create a nodelist\u00b6","text":"<p>To keep all the nodes in one place, we put them into a list</p>"},{"location":"demo/scripts/oxford_demo/#arcs","title":"Arcs\u00b6","text":"<p>Arcs link nodes. An example arc is the link between a FWTW and the distribution node</p>"},{"location":"demo/scripts/oxford_demo/#arc-parameters","title":"Arc parameters\u00b6","text":"<p>Besides the in/out ports and names, arcs can have a parameter for their capacity, to limit the flow that may pass through it each timestep. A typical example would be on river abstractions to a reservoir</p>"},{"location":"demo/scripts/oxford_demo/#create-arcs","title":"Create arcs\u00b6","text":"<p>Arcs are a bit less interesting than nodes because they generally don't capture complicated physical behaviours. So we just create all of them below.</p>"},{"location":"demo/scripts/oxford_demo/#mapping","title":"Mapping\u00b6","text":"<p>Remember, WSIMOD is an integrated model. Because it covers so many different things, it is very easy to make mistakes. Thus it is always good practice to plot your data!</p> <p>Below we load the node location data and create arcs from the information in the arclist.</p>"},{"location":"demo/scripts/oxford_demo/#orchestration","title":"Orchestration\u00b6","text":"<p>Orchestration is making the simulation happen by calling functions in the nodes. These functions simulate physical behaviour within the node, and cause pulls/pushes to happen which in turn triggers physical behaviour in other nodes.</p>"},{"location":"demo/scripts/oxford_demo/#orchestrating-an-individual-timestep","title":"Orchestrating an individual timestep\u00b6","text":"<p>We will start below by manually orchestrating a single timestep.</p> <p>We start by setting the date, so that every node knows what forcing data to read for this timestep.</p>"},{"location":"demo/scripts/oxford_demo/#ending-a-timestep","title":"Ending a timestep\u00b6","text":"<p>Because mistakes happen, it is essential to carry out mass balance testing. Each node has a mass balance function that can be called. We see a mass balance violation resulting from the demonstration with the FWTW earlier.</p>"},{"location":"demo/scripts/oxford_demo/#model-object","title":"Model object\u00b6","text":"<p>Of course it would be a massive pain to manually orchestrate every timestep. So instead we store node and arc information in a model object that will do the orchestration for us.</p> <p>Because we have already created the nodes/arcs above, we simply need to add the instantiated lists above.</p>"},{"location":"demo/scripts/oxford_demo/#validation-plots","title":"Validation plots\u00b6","text":"<p>Of course we shouldn't trust a model without proof, and this is doubly true for an integrated model whose errors may easily propagate.</p> <p>Thankfully we have rich in-river water quality sampling in Oxford that we can use for validation</p> <p>We load and format this data for dates and pollutants that overlap with what we have simulated</p>"},{"location":"demo/scripts/quickstart_demo/","title":"Quickstart (.py)","text":"<p>Import packages</p> In\u00a0[1]: Copied! <pre>import os\n\nimport pandas as pd\nfrom matplotlib import pyplot as plt\n\nfrom wsimod.core import constants\nfrom wsimod.orchestration.model import Model\n</pre>  import os  import pandas as pd from matplotlib import pyplot as plt  from wsimod.core import constants from wsimod.orchestration.model import Model <p>Load input data, in this example we use precipitation, temperature, and evapotranspiration (et0).</p> In\u00a0[2]: Copied! <pre># Select the root path for the data folder. Use the appropriate value for your case.\ndata_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")\n\n\ninput_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\")\ninput_data = pd.read_csv(input_fid)\ninput_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M\ninput_data.date = pd.to_datetime(input_data.date)\ninput_data = input_data.loc[input_data.site == \"oxford_land\"]\ndates = input_data.date.drop_duplicates()\nprint(input_data.sample(10))\n</pre>  # Select the root path for the data folder. Use the appropriate value for your case. data_folder = os.path.join(os.path.abspath(\"\"), \"docs\", \"demo\", \"data\")   input_fid = os.path.join(data_folder, \"processed\", \"timeseries_data.csv\") input_data = pd.read_csv(input_fid) input_data.loc[input_data.variable == \"precipitation\", \"value\"] *= constants.MM_TO_M input_data.date = pd.to_datetime(input_data.date) input_data = input_data.loc[input_data.site == \"oxford_land\"] dates = input_data.date.drop_duplicates() print(input_data.sample(10)) <pre>              site       date       variable      value\n77223  oxford_land 2009-04-27            et0   0.002000\n76092  oxford_land 2010-03-18  precipitation   0.002100\n78401  oxford_land 2012-07-18            et0   0.002000\n79938  oxford_land 2012-10-07    temperature  11.225000\n76921  oxford_land 2012-06-24  precipitation   0.000300\n78471  oxford_land 2012-09-26            et0   0.002000\n79554  oxford_land 2011-09-19    temperature  14.492857\n78475  oxford_land 2012-09-30            et0   0.002000\n76386  oxford_land 2011-01-06  precipitation   0.010600\n79171  oxford_land 2010-09-01    temperature  14.841667\n</pre> <p>Input data is stored in dicts, where a key is a variable on a given day.</p> In\u00a0[3]: Copied! <pre>land_inputs = input_data.set_index([\"variable\", \"date\"]).value.to_dict()\n\nexample_date = pd.to_datetime(\"2009-03-03\")\n\nprint(land_inputs[(\"precipitation\", example_date)])\nprint(land_inputs[(\"et0\", example_date)])\nprint(land_inputs[(\"temperature\", example_date)])\n</pre>  land_inputs = input_data.set_index([\"variable\", \"date\"]).value.to_dict()  example_date = pd.to_datetime(\"2009-03-03\")  print(land_inputs[(\"precipitation\", example_date)]) print(land_inputs[(\"et0\", example_date)]) print(land_inputs[(\"temperature\", example_date)]) <pre>0.015\n0.002\n7.625\n</pre> <p>Nodes can be defined as dictionaries of parameters. Different nodes require different parameters, you can see the documentation in the API to understand what parameters can be set. Although every node should have a type (type_) and a name.</p> In\u00a0[4]: Copied! <pre>sewer = {\"type_\": \"Sewer\", \"capacity\": 0.04, \"name\": \"my_sewer\"}\n\nsurface1 = {\n    \"type_\": \"ImperviousSurface\",\n    \"surface\": \"urban\",\n    \"area\": 10,\n    \"pollutant_load\": {\"phosphate\": 1e-7},\n}\n\nsurface2 = {\n    \"type_\": \"PerviousSurface\",\n    \"surface\": \"rural\",\n    \"area\": 100,\n    \"depth\": 0.5,\n    \"pollutant_load\": {\"phosphate\": 1e-7},\n}\n\nland = {\n    \"type_\": \"Land\",\n    \"data_input_dict\": land_inputs,\n    \"surfaces\": [surface1, surface2],\n    \"name\": \"my_land\",\n}\n\ngw = {\"type_\": \"Groundwater\", \"area\": 100, \"capacity\": 100, \"name\": \"my_groundwater\"}\n\nnode = {\"type_\": \"Node\", \"name\": \"my_river\"}\n\nwaste = {\"type_\": \"Waste\", \"name\": \"my_outlet\"}\n</pre>  sewer = {\"type_\": \"Sewer\", \"capacity\": 0.04, \"name\": \"my_sewer\"}  surface1 = {     \"type_\": \"ImperviousSurface\",     \"surface\": \"urban\",     \"area\": 10,     \"pollutant_load\": {\"phosphate\": 1e-7}, }  surface2 = {     \"type_\": \"PerviousSurface\",     \"surface\": \"rural\",     \"area\": 100,     \"depth\": 0.5,     \"pollutant_load\": {\"phosphate\": 1e-7}, }  land = {     \"type_\": \"Land\",     \"data_input_dict\": land_inputs,     \"surfaces\": [surface1, surface2],     \"name\": \"my_land\", }  gw = {\"type_\": \"Groundwater\", \"area\": 100, \"capacity\": 100, \"name\": \"my_groundwater\"}  node = {\"type_\": \"Node\", \"name\": \"my_river\"}  waste = {\"type_\": \"Waste\", \"name\": \"my_outlet\"} <p>Arcs can also be created as dictionaries, they don't typically need any numerical parameters (although there are some exceptions in the case study demo). Though they do need to specify the in_port (where the arc starts), and out_port (where it finishes). It's also handy to give each arc a name.</p> In\u00a0[5]: Copied! <pre>urban_drainage = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_land\",\n    \"out_port\": \"my_sewer\",\n    \"name\": \"urban_drainage\",\n}\n\npercolation = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_land\",\n    \"out_port\": \"my_groundwater\",\n    \"name\": \"percolation\",\n}\n\nrunoff = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_land\",\n    \"out_port\": \"my_river\",\n    \"name\": \"runoff\",\n}\n\nstorm_outflow = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_sewer\",\n    \"out_port\": \"my_river\",\n    \"name\": \"storm_outflow\",\n}\n\nbaseflow = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_groundwater\",\n    \"out_port\": \"my_river\",\n    \"name\": \"baseflow\",\n}\n\ncatchment_outflow = {\n    \"type_\": \"Arc\",\n    \"in_port\": \"my_river\",\n    \"out_port\": \"my_outlet\",\n    \"name\": \"catchment_outflow\",\n}\n</pre> urban_drainage = {     \"type_\": \"Arc\",     \"in_port\": \"my_land\",     \"out_port\": \"my_sewer\",     \"name\": \"urban_drainage\", }  percolation = {     \"type_\": \"Arc\",     \"in_port\": \"my_land\",     \"out_port\": \"my_groundwater\",     \"name\": \"percolation\", }  runoff = {     \"type_\": \"Arc\",     \"in_port\": \"my_land\",     \"out_port\": \"my_river\",     \"name\": \"runoff\", }  storm_outflow = {     \"type_\": \"Arc\",     \"in_port\": \"my_sewer\",     \"out_port\": \"my_river\",     \"name\": \"storm_outflow\", }  baseflow = {     \"type_\": \"Arc\",     \"in_port\": \"my_groundwater\",     \"out_port\": \"my_river\",     \"name\": \"baseflow\", }  catchment_outflow = {     \"type_\": \"Arc\",     \"in_port\": \"my_river\",     \"out_port\": \"my_outlet\",     \"name\": \"catchment_outflow\", } <p>We can create a model object and add dates</p> In\u00a0[6]: Copied! <pre>my_model = Model()\nmy_model.dates = dates\n</pre> my_model = Model() my_model.dates = dates <p>Add nodes in a list. The Model object will create the nodes from the dict entries.</p> In\u00a0[7]: Copied! <pre>my_model.add_nodes([sewer, land, gw, node, waste])\n</pre> my_model.add_nodes([sewer, land, gw, node, waste]) <p>Add arcs in a list.</p> In\u00a0[8]: Copied! <pre>my_model.add_arcs(\n    [urban_drainage, percolation, runoff, storm_outflow, baseflow, catchment_outflow]\n)\n</pre> my_model.add_arcs(     [urban_drainage, percolation, runoff, storm_outflow, baseflow, catchment_outflow] ) <p>Run the model</p> In\u00a0[9]: Copied! <pre>flows, _, _, _ = my_model.run()\nflows = pd.DataFrame(flows)\n</pre> flows, _, _, _ = my_model.run() flows = pd.DataFrame(flows) <pre>\r  0%|          | 0/1456 [00:00&lt;?, ?it/s]</pre> <pre>\r  9%|\u2589         | 137/1456 [00:00&lt;00:00, 1363.36it/s]</pre> <pre>\r 19%|\u2588\u2589        | 274/1456 [00:00&lt;00:00, 1238.01it/s]</pre> <pre>\r 27%|\u2588\u2588\u258b       | 399/1456 [00:00&lt;00:00, 1201.02it/s]</pre> <pre>\r 36%|\u2588\u2588\u2588\u258c      | 520/1456 [00:00&lt;00:00, 1193.42it/s]</pre> <pre>\r 44%|\u2588\u2588\u2588\u2588\u258d     | 640/1456 [00:00&lt;00:00, 1177.78it/s]</pre> <pre>\r 52%|\u2588\u2588\u2588\u2588\u2588\u258f    | 758/1456 [00:00&lt;00:00, 1176.27it/s]</pre> <pre>\r 60%|\u2588\u2588\u2588\u2588\u2588\u2588    | 876/1456 [00:00&lt;00:00, 1177.03it/s]</pre> <pre>\r 68%|\u2588\u2588\u2588\u2588\u2588\u2588\u258a   | 994/1456 [00:00&lt;00:00, 1177.89it/s]</pre> <pre>\r 76%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b  | 1112/1456 [00:00&lt;00:00, 1175.59it/s]</pre> <pre>\r 84%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d | 1230/1456 [00:01&lt;00:00, 1162.85it/s]</pre> <pre>\r 93%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e| 1347/1456 [00:01&lt;00:00, 1158.22it/s]</pre> <pre>\r100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 1456/1456 [00:01&lt;00:00, 1177.45it/s]</pre> <pre>\n</pre> <p>Plot results</p> In\u00a0[10]: Copied! <pre>f, axs_ = plt.subplots(3, 2, figsize=(10, 10))\n\nfor axs, variable in zip(axs_.T, [\"flow\", \"phosphate\"]):\n    flows_plot = flows.pivot(index=\"time\", columns=\"arc\", values=variable)\n    input_data.pivot(index=\"date\", columns=\"variable\", values=\"value\")[\n        [\"precipitation\"]\n    ].plot(ax=axs[0], xlabel=\"\", xticks=[], sharex=True)\n\n    flows_plot[[\"runoff\", \"urban_drainage\", \"percolation\"]].plot(\n        ax=axs[1], xlabel=\"\", xticks=[], sharex=True\n    )\n    flows_plot[[\"catchment_outflow\", \"storm_outflow\", \"baseflow\"]].plot(ax=axs[2])\naxs_[1, 0].set_title(\"Flows (m3/d)\")\naxs_[1, 1].set_title(\"Phosphate (kg/d)\")\nf.tight_layout()\n</pre> f, axs_ = plt.subplots(3, 2, figsize=(10, 10))  for axs, variable in zip(axs_.T, [\"flow\", \"phosphate\"]):     flows_plot = flows.pivot(index=\"time\", columns=\"arc\", values=variable)     input_data.pivot(index=\"date\", columns=\"variable\", values=\"value\")[         [\"precipitation\"]     ].plot(ax=axs[0], xlabel=\"\", xticks=[], sharex=True)      flows_plot[[\"runoff\", \"urban_drainage\", \"percolation\"]].plot(         ax=axs[1], xlabel=\"\", xticks=[], sharex=True     )     flows_plot[[\"catchment_outflow\", \"storm_outflow\", \"baseflow\"]].plot(ax=axs[2]) axs_[1, 0].set_title(\"Flows (m3/d)\") axs_[1, 1].set_title(\"Phosphate (kg/d)\") f.tight_layout()"},{"location":"demo/scripts/quickstart_demo/#quickstart-py","title":"Quickstart (.py)\u00b6","text":"<p>Note - this script can also be opened in interactive Python if you wanted to play around. On the GitHub it is in docs/demo/scripts</p> <ol> <li><p>Introduction</p> </li> <li><p>Data</p> </li> <li><p>Create nodes</p> </li> <li><p>Create arcs</p> </li> <li><p>Create model</p> </li> <li><p>Run model</p> </li> <li><p>What next?</p> </li> </ol>"},{"location":"demo/scripts/quickstart_demo/#introduction","title":"Introduction\u00b6","text":"<p>WSIMOD is a Python package that lets you create nodes that represent physical things in the water cycle and enables them talk to each other. In this demo, we will create some nodes, some arcs (the things that link nodes), and make a model that lets us simulate the flow of water through the water cycle.</p> <p>We will create a simple catchment model that contains a hydrological node, a sewer node, a groundwater node, and a river node. Using these nodes, we will simulate a mixed urban-rural catchment.</p>"},{"location":"demo/scripts/quickstart_demo/#imports-and-forcing-data","title":"Imports and forcing data\u00b6","text":""},{"location":"demo/scripts/quickstart_demo/#create-nodes","title":"Create nodes\u00b6","text":""},{"location":"demo/scripts/quickstart_demo/#create-arcs","title":"Create arcs\u00b6","text":""},{"location":"demo/scripts/quickstart_demo/#create-model","title":"Create model\u00b6","text":""},{"location":"demo/scripts/quickstart_demo/#run-model","title":"Run model\u00b6","text":""},{"location":"demo/scripts/quickstart_demo/#what-next","title":"What next?\u00b6","text":"<p>If you are hydrologically minded then you might be interested in a more detailed tutorial for our Land node. If you want an overview to see how many different nodes in WSIMOD work, then the Oxford case study might be more interesting.</p>"},{"location":"paper/paper/","title":"Summary","text":"<p>The water cycle is highly interconnected; water fluxes in one part depend on  physical and human processes throughout. For example, rivers are a water  supply, a receiver of wastewater, and an aggregate of many hydrological,  biological, and chemical processes. Thus, simulations of the water cycle that have highly constrained boundaries may miss key interactions that create  unanticipated impacts or unexpected opportunities (Dobson &amp; Mijic, 2020; Liu, Dobson, &amp; Mijic, 2022).  Integrated environmental models aim to resolve the issue of boundary  conditions, however they have some key limitations (Rauch et al., 2017), and in  particular we find a significant need for a parsimonious, self-contained suite  that is accessible and easy to setup. </p>","tags":["Python","water quality","hydrology","integrated modelling","pollution"]},{"location":"paper/paper/#statement-of-need","title":"Statement of need","text":"<p>Traditional approaches to water system modelling broadly fall into highly  numerical models that excel in representing individual subsystems, or systems  dynamics models that create broad representations but that lack a physical  basis. Early attempts at a physical representation of the water cycle combined  existing numerical models through an integration framework (Rauch et al., 2017). While  successful, this approach has an incredibly high user burden because each  subsystem model is so detailed, and as a consequence is also difficult to  customise. To illustrate, SWAT is one of the most widespread models of the  rural water cycle (Arnold et al., 2012), while SWMM is the same but for the urban  water cycle (Giron\u00e1s, Roesner, Rossman, &amp; Davis, 2010). It has been demonstrated that these two software  can interface using the OpenMI integration framework (Shrestha, Leta, De Fraine, Van Griensven, &amp; Bauwens, 2013). Despite  this seemingly powerful combination of two near-ubiquitous models, integrated  applications have been limited, and we propose that this is for the same  reasons presented in (Rauch et al., 2017): user burden and customisation difficulty. </p> <p>Because of this need, we provide a parsimonious and self-contained suite for integrated water cycle modelling in the WSIMOD Python package. It  brings together a range of software developed over the course of three years  on the CAMELLIA project. Urban water  processes are based on those presented and validated in the CityWat  model (Dobson et al., 2021; Dobson &amp; Mijic, 2020; Dobson, Watson-Hill, Muhandes, Borup, &amp; Mijic, 2022; Muhandes, Dobson, &amp; Mijic, 2022), while hydrological and agricultural processes are from the CatchWat  model (Liu et al., 2022, 2023). WSIMOD also provides an interface for message passing between different model components, enabling all parts of the water  cycle to interact with all other parts. The result is a simulation model that is easy to set up, highly flexible and ideal for representing water quality and quantity in 'non-textbook' water systems (which in our experience is nearly  all of them). </p> <p>The package provides a variety of tutorials and examples to help modellers  create nodes (i.e., representations of subsystems within the water cycle),  connect them together with arcs (i.e., representing the fluxes between  subsystems), and orchestrate them into a model that creates simulations. </p>","tags":["Python","water quality","hydrology","integrated modelling","pollution"]},{"location":"paper/paper/#limitations","title":"Limitations","text":"<p>We highlight that WSIMOD is not intended to be a substitute for sophisticated  physical models, nor for a system dynamics approach. In applications where  detailed hydraulic/hydrological process representations are needed (e.g.,  informing the design of specific pipes, cases where processes are hard to quantify such as representing social drivers of population growth, etc.) there  are likely better tools available. Our case studies highlight  that WSIMOD is most useful in situations where physically representing  cross-sytem processes and thus capturing the impacts of cross-system  interactions are essential towards the questions you ask of your model.  Secondary benefits are that the parsimonious representations utilised are  computationally fast and flexible in capturing a wide range of system  interventions.</p>","tags":["Python","water quality","hydrology","integrated modelling","pollution"]},{"location":"paper/paper/#acknowledgements","title":"Acknowledgements","text":"<p>WSIMOD was developed by Barnaby Dobson and Leyang Liu.  Theoretical support was provided by Ana Mijic. Testing the WSIMOD over a variety of applications has been performed by  Fangjun Peng, Vladimir Krivstov and Samer Muhandes. Software development support was provided by Imperial College's Research  Software Engineering service, in particular from Diego Alonso and Dan Davies.</p> <p>We are incredibly grateful for the detailed software reviews provided by Taher Chegini and Joshua Larsen and editing by Chris Vernon. Their suggestions have significantly improved WSIMOD.</p> <p>The design of WSIMOD was significantly influenced by  CityDrain3 (Burger et al., 2016),  OpenMI (Gregersen, Gijsbers, &amp; Westen, 2007), smif (Usher &amp; Russell, 2019; Usher et al., 2018)<sup>1</sup> <sup>2</sup>, and the  following review (Belete, Voinov, &amp; Laniak, 2017).</p> <p>We acknowledge funding from the CAMELLIA project (Community Water Management  for a Liveable London), funded by the Natural Environment Research Council  (NERC) under grant NE/S003495/1.</p>","tags":["Python","water quality","hydrology","integrated modelling","pollution"]},{"location":"paper/paper/#references","title":"References","text":"<ol> <li> <p>Usher, W., &amp; Russell, T. (2019). A software framework for the integration of infrastructure simulation models. https://doi.org/10.5334/jors.265 \u21a9</p> </li> <li> <p>Usher, W., Russell, T., Schoenmakers, R., Robson, C., Cooper, F., Lestang, T., &amp; Dickinson, R. (2018). Nismod/smif v1.3.2. https://doi.org/10.5281/zenodo.1309336 \u21a9</p> </li> </ol>","tags":["Python","water quality","hydrology","integrated modelling","pollution"]}]}